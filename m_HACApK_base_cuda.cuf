module m_HACApK_base_cuda
  use cudafor
  use m_HACApK_calc_entry_ij
!  use m_ppohBEM_user_func_cuda
  implicit none

  real*8   ,texture,pointer,dimension(:,:) :: np_t
  integer*4,texture,pointer,dimension(:,:) :: face2node_t

  ! type workarray
  !    ! real*8,   dimension(:),pointer,    device :: zaa,zab
  !    ! integer*4,dimension(:),pointer,    device :: a_prefix,b_prefix
  !    real*8,   dimension(:),allocatable,    device :: zaa,zab
  !    integer*4,dimension(:),allocatable,    device :: a_prefix,b_prefix
  ! end type workarray
  
contains
#define NOTDEBUG 0
#if NOTDEBUG 
#include "m_HACApK_calc_entry_ij_cuda.inc"
#endif

  attributes(global) subroutine pre_calc_vec(xsyszs,aoo,aoi,lod,face2node,np,nd,lp61,l_face2,l_np2)

    integer*4,                 intent(in)    ,value  :: nd,lp61,l_face2,l_np2
    real*8,   dimension(nd,9), intent(out)           :: xsyszs
    real*8,   dimension(nd),   intent(out)           :: aoo
    real*8,   dimension(nd),   intent(in)            :: aoi
    integer*4,dimension(nd),   intent(in)            :: lod
    integer*4,dimension(3,l_face2),  intent(in)      :: face2node
    real*8,   dimension(3,l_np2),  intent(in)        :: np
    integer*4 :: n(3),i,j,tid

    tid = blockDim%x * (blockIdx%x -1) + threadIdx%x
    if(tid > nd) return
    j = lod(tid)
    
    n(1:3) = face2node(1:3, j) + 1
!    if(blockIdx%x == 1) print *, tid, n(1), n(2), n(3)
    xsyszs(tid,1:3) = np(1, n(1:3) )
    xsyszs(tid,4:6) = np(2, n(1:3) )
    xsyszs(tid,7:9) = np(3, n(1:3) )

    if(lp61 == 3) aoo(tid) = aoi(j)
!    aoo(tid) = 2.0d0

  end subroutine pre_calc_vec

  attributes(global) subroutine pre_calc_vec2(xyz,xsyszs,aoo,aoi,lod,face2node,np,nd,lp61,l_face2,l_np2)

    integer*4,                 intent(in)    ,value  :: nd,lp61,l_face2,l_np2
    real*8,   dimension(nd,3), intent(out)           :: xyz
    real*8,   dimension(nd,9), intent(out)           :: xsyszs
    real*8,   dimension(nd),   intent(out)           :: aoo
    real*8,   dimension(nd),   intent(in)            :: aoi
    integer*4,dimension(nd),   intent(in)            :: lod
    integer*4,dimension(3,l_face2),  intent(in)      :: face2node
    real*8,   dimension(3,l_np2),  intent(in)        :: np
    integer*4 :: n(3),i,j,tid
    real*8    :: xs(3),ys(3),zs(3)

    tid = blockDim%x * (blockIdx%x -1) + threadIdx%x
    if(tid > nd) return
    j = lod(tid)
    
    n(1:3) = face2node(1:3, j) + 1
!    if(blockIdx%x == 1) print *, tid, n(1), n(2), n(3)
    xs(1:3) = np(1, n(1:3))
    ys(1:3) = np(2, n(1:3))
    zs(1:3) = np(3, n(1:3))
    xsyszs(tid,1:3) = xs(1:3)
    xsyszs(tid,4:6) = ys(1:3)
    xsyszs(tid,7:9) = zs(1:3)
    xyz(tid,1) = (xs(1) + xs(2) + xs(3)) / 3d0
    xyz(tid,2) = (ys(1) + ys(2) + ys(3)) / 3d0
    xyz(tid,3) = (zs(1) + zs(2) + zs(3)) / 3d0

    if(lp61 == 3) aoo(tid) = aoi(j)
!    aoo(tid) = 2.0d0

  end subroutine pre_calc_vec2


! !  attributes(global) subroutine prefix_init(work,ndlp,ndtp,isnt_finished,len)
!   attributes(global) subroutine prefix_init(a_prefix,b_prefix,ndlp,ndtp,isnt_finished,len)

!     integer*4,dimension(:),    intent(out)           :: a_prefix,b_prefix
! !    type(workarray),           intent(inout)         :: work
!     integer*4,dimension(:),    intent(in)            :: ndlp,ndtp
!     integer*4,dimension(:),    intent(in)            :: isnt_finished
!     integer*4,                 intent(in)    ,value  :: len

! !    integer*4,dimension(:),pointer :: a_prefix,b_prefix

!     tid = blockDim%x * (blockIdx%x -1) + threadIdx%x
!     if(tid > len) return
!     ! a_prefix => work%a_prefix
!     ! b_prefix => work%b_prefix

!     a_prefix(tid) = ndlp(tid)*isnt_finished(tid)
!     b_prefix(tid) = ndtp(tid)*isnt_finished(tid)

!   end subroutine prefix_init

! !  attributes(global) subroutine atomic_prefix_sum(work,ndlp,ndtp,isnt_finished,len)
!   attributes(global) subroutine atomic_prefix_sum(a_prefix,b_prefix,len)

!     integer*4,dimension(:),    intent(out)           :: a_prefix,b_prefix
!     integer*4,                 intent(in)    ,value  :: len

!     integer*4 :: tid, i, 
!     tid = blockDim%x * (blockIdx%x -1) + threadIdx%x
!     if(tid > len) return
    
    
!     do while(i < len)
!        a_prefix(tid) = ndlp(tid)*isnt_finished(tid)
!        b_prefix(tid) = ndtp(tid)*isnt_finished(tid)
!        i = i * 2
! end

!   end subroutine prefix_init


!  attributes(global) subroutine prefix_init(work,ndlp,ndtp,isnt_finished,len)
!   attributes(global) subroutine atomic_prefix_sum(a_prefix,b_prefix,ndlp,ndtp,isnt_finished,len)

!     integer*4,dimension(:),    intent(out)           :: a_prefix,b_prefix
! !    type(workarray),           intent(inout)         :: work
!     integer*4,dimension(:),    intent(in)            :: ndlp,ndtp
!     integer*4,dimension(:),    intent(in)            :: isnt_finished
!     integer*4,                 intent(in)    ,value  :: len

! !    integer*4,dimension(:),pointer :: a_prefix,b_prefix
!     integer*4 :: tid, i, rid, istat, tmp

!     tid = blockDim%x * (blockIdx%x -1) + threadIdx%x
!     if(tid > len) return
!     ! a_prefix => work%a_prefix
!     ! b_prefix => work%b_prefix

!     a_prefix(tid) = ndlp(tid)*isnt_finished(tid)
!     b_prefix(tid) = ndtp(tid)*isnt_finished(tid)
    
!     i = 1
!     do while(i < len)
!        rid = tid - i
!        if(rid < 1) return
!        tmp = a_prefix(rid)
!        istat = atomicadd(a_prefix(tid),tmp)
!        tmp = b_prefix(rid)
!        istat = atomicadd(b_prefix(tid),tmp)
!        i = i * 2
!     end do

!   end subroutine atomic_prefix_sum

  attributes(global) subroutine atomic_prefix_sum(a_prefix,b_prefix,a_prefix_tmp,b_prefix_tmp,ndlp,ndtp,isnt_finished,len)

    integer*4,dimension(:),    intent(out)           :: a_prefix,b_prefix
    integer*4,dimension(:,:),  intent(out)           :: a_prefix_tmp,b_prefix_tmp
!    type(workarray),           intent(inout)         :: work
    integer*4,dimension(:),    intent(in)            :: ndlp,ndtp
    integer*4,dimension(:),    intent(in)            :: isnt_finished
    integer*4,                 intent(in)    ,value  :: len

!    integer*4,dimension(:),pointer :: a_prefix,b_prefix
    integer*4 :: tid, i, rid, istat, tmp, dimx, id, sww,swr, tmpl, tmpt

    tid = blockDim%x * (blockIdx%x -1) + threadIdx%x
    if (tid > len) return

    if(tid == 1) then
       tmpl = 1; tmpt = 1
    else
       tmpl = ndlp(tid-1)*isnt_finished(tid-1)
       tmpt = ndtp(tid-1)*isnt_finished(tid-1)
    endif
    istat = atomicexch(a_prefix_tmp(tid,1), tmpl)
    istat = atomicexch(b_prefix_tmp(tid,1), tmpt)
    istat = atomicexch(a_prefix_tmp(tid,2), tmpl)
    istat = atomicexch(b_prefix_tmp(tid,2), tmpt)

    call syncthreads()
    i = 1
    swr = 1; sww = 2
    do while(i < len)
       rid = tid - i
       if(rid < 1) then
          istat = atomicexch(a_prefix_tmp(tid,sww), a_prefix_tmp(tid,swr))
          istat = atomicexch(b_prefix_tmp(tid,sww), b_prefix_tmp(tid,swr))
       else
          istat = atomicexch(a_prefix_tmp(tid,sww), a_prefix_tmp(tid,swr) + a_prefix_tmp(rid,swr))
          istat = atomicexch(b_prefix_tmp(tid,sww), b_prefix_tmp(tid,swr) + b_prefix_tmp(rid,swr))
       endif
       i = i * 2
       tmp = swr
       swr = sww
       sww = tmp
    end do
    a_prefix(tid) = a_prefix_tmp(tid,swr)
    b_prefix(tid) = b_prefix_tmp(tid,swr)
  end subroutine atomic_prefix_sum


!  attributes(global) subroutine gang1_prefix_sum(a_prefix,b_prefix,lenl,lent,a_prefix_tmp,b_prefix_tmp,ndlp,ndtp,isnt_finished,len)
  attributes(global) subroutine gang1_prefix_sum(a_prefix,b_prefix,lenl,lent,a_strk,b_strk,a_prefix_tmp,b_prefix_tmp,ndlp,ndtp,isnt_finished,len,k,kmax)

    integer*4,dimension(len),   intent(out)           :: a_prefix,b_prefix
    integer*4,                  intent(out)           :: lenl,lent
    integer*4,dimension(kmax+1),intent(out)           :: a_strk,b_strk
    integer*4,dimension(len,2), intent(out)           :: a_prefix_tmp,b_prefix_tmp
!    type(workarray),           intent(inout)         :: work
    integer*4,dimension(len-1), intent(in)            :: ndlp,ndtp
    integer*4,dimension(len-1), intent(in)            :: isnt_finished
    integer*4,                  intent(in)    ,value  :: len,k,kmax

!    integer*4,dimension(:),pointer :: a_prefix,b_prefix
    integer*4 :: tid, i, rid, istat, tmp, dimx, id, sww,swr

    tid = threadIdx%x
    dimx = blockDim%x
    ! a_prefix => work%a_prefix
    ! b_prefix => work%b_prefix

    if(tid == 1) then
       a_prefix_tmp(1,1) = 1
       b_prefix_tmp(1,1) = 1
       a_prefix_tmp(1,2) = 1
       b_prefix_tmp(1,2) = 1
    endif
    do i = tid+1, len, dimx
       a_prefix_tmp(i,1) = ndlp(i-1)*isnt_finished(i-1)
       b_prefix_tmp(i,1) = ndtp(i-1)*isnt_finished(i-1)
       a_prefix_tmp(i,2) = ndlp(i-1)*isnt_finished(i-1)
       b_prefix_tmp(i,2) = ndtp(i-1)*isnt_finished(i-1)
    enddo
    call syncthreads()
    i = 1
    swr = 1; sww = 2
    do while(i < len)
       call syncthreads()
       do id = tid, len, dimx
          rid = id - i
          if(rid < 1) then
             a_prefix_tmp(id,sww) = a_prefix_tmp(id,swr)
             b_prefix_tmp(id,sww) = b_prefix_tmp(id,swr)
          else
             a_prefix_tmp(id,sww) = a_prefix_tmp(id,swr) + a_prefix_tmp(rid,swr)
             b_prefix_tmp(id,sww) = b_prefix_tmp(id,swr) + b_prefix_tmp(rid,swr)
          endif
       enddo
       call syncthreads()
       i = i * 2
       tmp = swr
       swr = sww
       sww = tmp
    end do
    do id = tid, len, dimx
       a_prefix(id) = a_prefix_tmp(id,swr)
       b_prefix(id) = b_prefix_tmp(id,swr)
       if(id == len) then
          lenl = a_prefix_tmp(id,swr)
          lent = b_prefix_tmp(id,swr)
          a_strk(k+1) = lenl + a_strk(k)
          b_strk(k+1) = lent + b_strk(k)
       endif
    enddo
    ! if(tid == 1) then
    !    do i = 1, len
    !       print *, i,a_prefix(i)
    !    enddo
    ! end if
  end subroutine gang1_prefix_sum


  attributes(global) subroutine opt_prefix_sum_pre(a_prefix,b_prefix,a_prefix_reduce,b_prefix_reduce,ndlp,ndtp,isnt_finished,len,lenr,loclen)
    integer*4,dimension(len),   intent(out)           :: a_prefix,b_prefix
    integer*4,dimension(lenr),  intent(out)           :: a_prefix_reduce,b_prefix_reduce
    integer*4,dimension(len-1), intent(in)            :: ndlp,ndtp
    integer*4,dimension(len-1), intent(in)            :: isnt_finished
    integer*4,                  intent(in)    ,value  :: len,lenr,loclen
    integer*4 :: tid, bid, i, j, wid, tmp1, tmp2, dimx, rid, atmp, btmp, amax, bmax

    tid = blockDim%x * (blockIdx%x -1) * loclen + threadIdx%x
    bid = blockIdx%x
    wid = mod(threadIdx%x-1,32) + 1
    atmp = 0
    btmp = 0
    amax = 0
    bmax = 0

    do j = tid, min(bid*32*loclen,len), 32
       if(j == 1) then
          atmp = 1
          btmp = 1
       else
          atmp = ndlp(j-1)*isnt_finished(j-1)
          btmp = ndtp(j-1)*isnt_finished(j-1)
       endif

       i = 1
       do while(i < 32)
          tmp1 = __shfl_up(atmp,i)
          tmp2 = __shfl_up(btmp,i)
          if(wid > i) then
             atmp = atmp + tmp1
             btmp = btmp + tmp2
          endif
          i = i * 2
          call syncthreads()
       enddo
       atmp = atmp + amax
       btmp = btmp + bmax
       if(wid == 32) then 
          amax = atmp
          bmax = btmp
       end if
!       if(tid == 193) print *, atmp, btmp, amax, bmax
       a_prefix(j) = atmp
       b_prefix(j) = btmp
!       if(tid == 193) print *, j, a_prefix(j), b_prefix(j)
       amax = __shfl(amax,32)
       bmax = __shfl(bmax,32)
       call syncthreads()
       if(j == bid*32*loclen) then
!          rid = (j-1)/32 + 1
          a_prefix_reduce(bid) = amax
          b_prefix_reduce(bid) = bmax
       end if
    end do
  end subroutine opt_prefix_sum_pre


  attributes(global) subroutine opt_prefix_sum_mid(a_prefix_reduce,b_prefix_reduce,len)
    integer*4,dimension(len), intent(out)           :: a_prefix_reduce,b_prefix_reduce
    integer*4,                intent(in)    ,value  :: len
    integer*4 :: tid, dimx, i, j, wid, tmp1, tmp2, rid, atmp, btmp
    integer*4,shared,dimension(16) :: a_prefix_shared,b_prefix_shared

    tid = threadIdx%x
    wid = mod(threadIdx%x-1,32) + 1
    rid = (tid-1)/32 + 1
    dimx = blockDim%x
    if(tid > len) return
    atmp = a_prefix_reduce(tid)
    btmp = b_prefix_reduce(tid)
    if(tid <= 16) then
       a_prefix_shared(tid) = 0
       b_prefix_shared(tid) = 0
    end if

    i = 1
    do while(i < 32)
       tmp1 = __shfl_up(atmp,i)
       tmp2 = __shfl_up(btmp,i)
       if(wid > i) then
          atmp = atmp + tmp1
          btmp = btmp + tmp2
       endif
       i = i * 2
       call syncthreads()
    enddo
    a_prefix_reduce(tid) = atmp
    b_prefix_reduce(tid) = btmp
    if(wid == 32) then
       a_prefix_shared(rid) = atmp
       b_prefix_shared(rid) = btmp
    end if
    call syncthreads()
    if(tid == 1) then
       do i = 2, 16
          a_prefix_shared(i) = a_prefix_shared(i) + a_prefix_shared(i-1)
          b_prefix_shared(i) = b_prefix_shared(i) + b_prefix_shared(i-1)
       end do
    endif
    call syncthreads()
    if(rid-1 > 0) then
       a_prefix_reduce(tid) = a_prefix_reduce(tid) + a_prefix_shared(rid-1)
       b_prefix_reduce(tid) = b_prefix_reduce(tid) + b_prefix_shared(rid-1)
    end if
    
  end subroutine opt_prefix_sum_mid

  attributes(global) subroutine opt_prefix_sum_post(a_prefix,b_prefix,lenl,lent,a_strk,b_strk,a_prefix_reduce,b_prefix_reduce,len,lenr,k,loclen)
    integer*4,dimension(len),   intent(out)           :: a_prefix,b_prefix
    integer*4,                  intent(out)           :: lenl,lent
    integer*4,dimension(k+1),   intent(out)           :: a_strk,b_strk
    integer*4,dimension(lenr),  intent(in)            :: a_prefix_reduce,b_prefix_reduce
    integer*4,                  intent(in)    ,value  :: len,lenr,k,loclen
    integer*4 :: tid, bid, rid, atmp, btmp, i, dimx, amax, bmax

    tid = blockDim%x * (blockIdx%x -1) * loclen + threadIdx%x
    bid = blockIdx%x
    dimx = blockDim%x
    rid = (tid-1)/(32*loclen) + 1

    if(tid > len) return
    if(rid-1 > 0) then
       amax = a_prefix_reduce(rid-1)
       bmax = b_prefix_reduce(rid-1)
       do i = tid, min(bid*dimx*loclen,len),dimx
          atmp = a_prefix(i) + amax
          btmp = b_prefix(i) + bmax
          a_prefix(i) = atmp
          b_prefix(i) = btmp
          if(i == len) then
             lenl = atmp
             lent = btmp
             a_strk(k+1) = lenl + a_strk(k)
             b_strk(k+1) = lent + b_strk(k)
          endif
       end do
    end if

  end subroutine opt_prefix_sum_post



  attributes(global) subroutine opt_prefix_sum_pre_idx3(idx3,reduce,ndlp,ndtp,n_low,n_dense,lenr,loclen)
    integer*4,dimension(n_low+n_dense),intent(out)    :: idx3
    integer*4,dimension(lenr)   ,intent(out)          :: reduce
    integer*4,dimension(n_low+n_dense), intent(in)    :: ndlp,ndtp
    integer*4,                  intent(in)    ,value  :: n_low,n_dense,lenr,loclen
    integer*4 :: tid, bid, i, j, wid, tmp1, tmp2, dimx, rid, max

    tid = blockDim%x * (blockIdx%x -1) * loclen + threadIdx%x
    bid = blockIdx%x
    wid = mod(threadIdx%x-1,32) + 1
    tmp1 = 0
    tmp2 = 0
    max  = 0

    do j = tid, min(bid*32*loclen,n_dense), 32
       if(j == 1) then
          tmp1 = 1
       else
          tmp1 = ndlp(n_low+j-1)*ndtp(n_low+j-1)
       endif

       i = 1
       do while(i < 32)
          tmp2 = __shfl_up(tmp1,i)
          if(wid > i) then
             tmp1 = tmp1 + tmp2
          endif
          i = i * 2
          call syncthreads()
       enddo
       tmp1 = tmp1 + max
       if(wid == 32) then 
          max = tmp1
       end if
       idx3(n_low+j) = tmp1
       max = __shfl(max,32)
       call syncthreads()
       if(j == bid*32*loclen) then
          reduce(bid) = max
       end if
    end do
  end subroutine opt_prefix_sum_pre_idx3


  attributes(global) subroutine opt_prefix_sum_mid_idx3(reduce,len)
    integer*4,dimension(len), intent(out)           :: reduce
    integer*4,                intent(in)    ,value  :: len
    integer*4 :: tid, dimx, i, j, wid, tmp1, tmp2, rid, atmp, btmp
    integer*4,shared,dimension(16) :: a_prefix_shared

    tid = threadIdx%x
    wid = mod(threadIdx%x-1,32) + 1
    rid = (tid-1)/32 + 1
    dimx = blockDim%x
    if(tid > len) return
    atmp = reduce(tid)
    if(tid <= 16) then
       a_prefix_shared(tid) = 0
    end if

    i = 1
    do while(i < 32)
       tmp1 = __shfl_up(atmp,i)
       if(wid > i) then
          atmp = atmp + tmp1
       endif
       i = i * 2
       call syncthreads()
    enddo
    reduce(tid) = atmp
    if(wid == 32) then
       a_prefix_shared(rid) = atmp
    end if
    call syncthreads()
    if(tid == 1) then
       do i = 2, 16
          a_prefix_shared(i) = a_prefix_shared(i) + a_prefix_shared(i-1)
       end do
    endif
    call syncthreads()
    if(rid-1 > 0) then
       reduce(tid) = reduce(tid) + a_prefix_shared(rid-1)
    end if
    
  end subroutine opt_prefix_sum_mid_idx3


  attributes(global) subroutine opt_prefix_sum_post_idx3(idx3,lend,reduce,n_low,n_dense,lenr,loclen)
    integer*4,dimension(n_low+n_dense),intent(out)    :: idx3
    integer*4,                  intent(out)           :: lend
    integer*4,dimension(lenr),  intent(in)            :: reduce
    integer*4,                  intent(in)    ,value  :: n_low,n_dense,lenr,loclen
    integer*4 :: tid, bid, rid, atmp, btmp, i, dimx, amax, bmax

    tid = blockDim%x * (blockIdx%x -1) * loclen + threadIdx%x
    bid = blockIdx%x
    dimx = blockDim%x
    rid = (tid-1)/(32*loclen) + 1

    if(tid > n_dense) return
    if(rid-1 > 0) then
       amax = reduce(rid-1)
       do i = tid, min(bid*dimx*loclen,n_dense),dimx
          atmp = idx3(n_low+i) + amax
          idx3(n_low+i) = atmp
          if(i == n_dense) then
             lend = atmp
          endif
       end do
    end if

  end subroutine opt_prefix_sum_post_idx3


  attributes(global) subroutine create_blockid_pre(dis,reduce,src,len,lenr,loclen)
    integer*4,dimension(len)  ,intent(out)     :: dis
    integer*4,dimension(lenr) ,intent(out)     :: reduce
    integer*4,dimension(len-1),intent(in)      :: src
    integer*4                 ,intent(in),value:: len,lenr,loclen
    integer*4 :: tid, bid, i, j, wid, tmp1, tmp2, dimx, rid, max

    tid = blockDim%x * (blockIdx%x -1) * loclen + threadIdx%x
    bid = blockIdx%x
    wid = mod(threadIdx%x-1,32) + 1
    tmp1 = 0
    tmp2 = 0
    max  = 0

    if(len <= 32) then
       j = tid
       if(j == 1) then
          tmp1 = 1
       else
          tmp1 = src(j-1)
       endif
       
       i = 1
       do while(i < 32)
          tmp2 = __shfl_up(tmp1,i)
          if(wid > i) then
             tmp1 = tmp1 + tmp2
          endif
          i = i * 2
          call syncthreads()
       enddo
       tmp1 = tmp1 + max
       if(wid == len) then 
          max = tmp1
       end if
       dis(j) = tmp1
       max = __shfl(max,len)
       call syncthreads()
       if(j == len) then
          reduce(bid) = max
       end if
    else
       do j = tid, min(bid*32*loclen,len), 32
          if(j == 1) then
             tmp1 = 1
          else
             tmp1 = src(j-1)
          endif
          
          i = 1
          do while(i < 32)
             tmp2 = __shfl_up(tmp1,i)
             if(wid > i) then
                tmp1 = tmp1 + tmp2
             endif
             i = i * 2
             call syncthreads()
          enddo
          tmp1 = tmp1 + max
          if(wid == 32) then 
             max = tmp1
          end if
          dis(j) = tmp1
          max = __shfl(max,32)
          ! if(len <= 32) then
          !    max = __shfl(max,len)
          ! else
          !   max = __shfl(max,32)
!          endif
          call syncthreads()
          if(j == bid*32*loclen) then
             reduce(bid) = max
          end if
       end do
    end if
  end subroutine create_blockid_pre


  attributes(global) subroutine create_blockid_mid(reduce,len)
    integer*4,dimension(len), intent(out)           :: reduce
    integer*4,                intent(in)    ,value  :: len
    integer*4 :: tid, dimx, i, j, wid, tmp1, tmp2, rid, atmp, btmp
    integer*4,shared,dimension(16) :: a_prefix_shared

    tid = threadIdx%x
    wid = mod(threadIdx%x-1,32) + 1
    rid = (tid-1)/32 + 1
    dimx = blockDim%x
    if(tid > len) return
    atmp = reduce(tid)
    if(tid <= 16) then
       a_prefix_shared(tid) = 0
    end if

    i = 1
    do while(i < 32)
       tmp1 = __shfl_up(atmp,i)
       if(wid > i) then
          atmp = atmp + tmp1
       endif
       i = i * 2
       call syncthreads()
    enddo
    reduce(tid) = atmp
    if(wid == 32) then
       a_prefix_shared(rid) = atmp
    end if
    call syncthreads()
    if(tid == 1) then
       do i = 2, 16
          a_prefix_shared(i) = a_prefix_shared(i) + a_prefix_shared(i-1)
       end do
    endif
    call syncthreads()
    if(rid-1 > 0) then
       reduce(tid) = reduce(tid) + a_prefix_shared(rid-1)
    end if
    
  end subroutine create_blockid_mid

  attributes(global) subroutine create_blockid_post(dis,lenb,reduce,len,lenr,loclen)
    integer*4,dimension(len) ,  intent(out)           :: dis
    integer*4,                  intent(out)           :: lenb
    integer*4,dimension(lenr),  intent(in)            :: reduce
    integer*4,                  intent(in)    ,value  :: len,lenr,loclen
    integer*4 :: tid, bid, rid, atmp, btmp, i, dimx, amax, bmax

    tid = blockDim%x * (blockIdx%x -1) * loclen + threadIdx%x
    bid = blockIdx%x
    dimx = blockDim%x
    rid = (tid-1)/(32*loclen) + 1

    if(tid > len) return
    if(rid-1 > 0) then
       amax = reduce(rid-1)
       do i = tid, min(bid*dimx*loclen,len),dimx
          atmp = dis(i) + amax
          dis(i) = atmp
          if(i == len) then
             lenb = atmp
          endif
       end do
    else
       lenb = dis(len)
    end if

  end subroutine create_blockid_post

  attributes(global) subroutine create_blockid(dis,src,isnt_finished,blockIdIdx,lenb,n_low)
    integer*4, dimension(n_low), intent(out)  :: dis
    integer*4, dimension(n_low), intent(in)   :: src
    integer*4, dimension(n_low)          , intent(inout):: isnt_finished
    integer*4, dimension(n_low+1)        , intent(inout):: blockIdIdx
    integer*4                            , value        :: lenb,n_low
    integer*4 :: tid,bid

    tid = blockDim%x * (blockIdx%x -1) + threadIdx%x
    if(tid > lenb) return

    bid = blockIdIdx(tid)
    if(isnt_finished(tid) == 1) then
       dis(bid) = src(tid)
    endif
  end subroutine create_blockid

  attributes(global) subroutine update_flags(isnt_finished,lenb,n_low)
    integer*4, dimension(n_low), intent(out)  :: isnt_finished
    integer*4                  , value        :: lenb,n_low
    integer*4 :: tid,bid,gid
    tid = blockDim%x * (blockIdx%x -1) + threadIdx%x
    if(tid > lenb) return
    isnt_finished(tid) = 1
  end subroutine update_flags


  attributes(global) subroutine opt_prefix_sum_pre_idx3_2D(idx3,reduce,ndlp,ndtp,n_low,n_dense,lenr,loclen,ndt_max)
    integer*4,dimension(n_dense*ndt_max),intent(out)  :: idx3
    integer*4,dimension(lenr)           ,intent(out)  :: reduce
    integer*4,dimension(n_low+n_dense)  ,intent(in)   :: ndlp,ndtp
    integer*4,                           intent(in),value :: n_low,n_dense,lenr,loclen,ndt_max
    integer*4 :: ndl, ndt
    integer*4 :: tid, bid, i, j, wid, tmp1, tmp2, dimx, rid, max

    tid = blockDim%x * (blockIdx%x -1) * loclen + threadIdx%x
    bid = blockIdx%x
    wid = mod(threadIdx%x-1,32) + 1
    tmp1 = 0
    tmp2 = 0
    max  = 0

    do j = tid, min(bid*32*loclen,n_dense*ndt_max+1), 32
       if(j == 1) then
          tmp1 = 1
       else
          ndl  = ndlp(n_low+(mod(j-2,n_dense)+1))
          ndt  = ndtp(n_low+(mod(j-2,n_dense)+1))
          if(ndt < (j-2)/n_dense+1) then
             tmp1 = 0
          else
             tmp1 = ndl
          endif
       endif
       
       i = 1
       do while(i < 32)
          tmp2 = __shfl_up(tmp1,i)
          if(wid > i) then
             tmp1 = tmp1 + tmp2
          endif
          i = i * 2
          call syncthreads()
       enddo
       tmp1 = tmp1 + max
       if(wid == 32) then 
          max = tmp1
       end if
       idx3(j) = tmp1
       max = __shfl(max,32)
       call syncthreads()
       if(j == bid*32*loclen) then
          reduce(bid) = max
       end if
    end do

  end subroutine opt_prefix_sum_pre_idx3_2D
  

  attributes(global) subroutine opt_prefix_sum_mid_idx3_2D(reduce,len,ndt_max)
    integer*4,dimension(len), intent(out)        :: reduce
    integer*4,                intent(in) ,value  :: len,ndt_max
    integer*4 :: tid, dimx, i, j, wid, tmp1, tmp2, rid, atmp, btmp
    integer*4,shared,dimension(16) :: a_prefix_shared

    tid = threadIdx%x
    wid = mod(threadIdx%x-1,32) + 1
    rid = (tid-1)/32 + 1
    dimx = blockDim%x
    if(tid > len) return
    atmp = reduce(tid)
    if(tid <= 16) then
       a_prefix_shared(tid) = 0
    end if

    i = 1
    do while(i < 32)
       tmp1 = __shfl_up(atmp,i)
       if(wid > i) then
          atmp = atmp + tmp1
       endif
       i = i * 2
       call syncthreads()
    enddo
    reduce(tid) = atmp
    if(wid == 32) then
       a_prefix_shared(rid) = atmp
    end if
    call syncthreads()
    if(tid == 1) then
       do i = 2, 16
          a_prefix_shared(i) = a_prefix_shared(i) + a_prefix_shared(i-1)
       end do
    endif
    call syncthreads()
    if(rid-1 > 0) then
       reduce(tid) = reduce(tid) + a_prefix_shared(rid-1)
    end if
    
  end subroutine opt_prefix_sum_mid_idx3_2D


  attributes(global) subroutine opt_prefix_sum_post_idx3_2D(idx3,lend,reduce,n_low,n_dense,lenr,loclen,ndt_max)
    integer*4,dimension(n_dense*ndt_max),intent(out)  :: idx3
    integer*4,                           intent(out)  :: lend
    integer*4,dimension(lenr)           ,intent(in)   :: reduce
    integer*4,                           intent(in),value  :: n_low,n_dense,lenr,loclen,ndt_max
    integer*4 :: tid, bid, rid, atmp, btmp, i, dimx, amax, bmax

    tid = blockDim%x * (blockIdx%x -1) * loclen + threadIdx%x
    bid = blockIdx%x
    dimx = blockDim%x
    rid = (tid-1)/(32*loclen) + 1

    if(tid > n_dense*ndt_max+1) return
    if(rid-1 > 0) then
       amax = reduce(rid-1)
       do i = tid, min(bid*dimx*loclen,n_dense*ndt_max+1),dimx
          atmp = idx3(i) + amax
          idx3(i) = atmp
          if(i == n_dense+1) then
             lend = atmp-1
          endif
       end do
    end if

  end subroutine opt_prefix_sum_post_idx3_2D


#if 0
  attributes(global) subroutine opt_prefix_sum_pre(a_prefix_tmp,b_prefix_tmp,a_prefix_reduce,b_prefix_reduce,ndlp,ndtp,isnt_finished,len,lenr)
    integer*4,dimension(len),   intent(out)           :: a_prefix_tmp,b_prefix_tmp
    integer*4,dimension(lenr),  intent(out)           :: a_prefix_reduce,b_prefix_reduce
    integer*4,dimension(len-1), intent(in)            :: ndlp,ndtp
    integer*4,dimension(len-1), intent(in)            :: isnt_finished
    integer*4,                  intent(in)    ,value  :: len,lenr
    integer*4 :: tid, i, wid, tmp1, tmp2, dimx, rid, atmp, btmp

    tid = blockDim%x * (blockIdx%x -1) + threadIdx%x
    rid = (tid-1)/32 + 1
    wid = mod(threadIdx%x-1,32) + 1
    if(tid > len) return

    if(tid == 1) then
       atmp = 1
       btmp = 1
    else
       atmp = ndlp(tid-1)*isnt_finished(tid-1)
       btmp = ndtp(tid-1)*isnt_finished(tid-1)
    endif
    
    i = 1
    do while(i < 32)
       tmp1 = __shfl_up(atmp,i)
       tmp2 = __shfl_up(btmp,i)
       if(wid > i) then
          atmp = atmp + tmp1
          btmp = btmp + tmp2
       endif
       i = i * 2
       call syncthreads()
    enddo

    if(wid == 32) then
       a_prefix_reduce(rid) = atmp
       b_prefix_reduce(rid) = btmp
    endif
    a_prefix_tmp(tid) = atmp
    b_prefix_tmp(tid) = btmp
    
  end subroutine opt_prefix_sum_pre

  attributes(global) subroutine opt_prefix_sum_mid(a_prefix_reduce,b_prefix_reduce,len)
    integer*4,dimension(len), intent(out)           :: a_prefix_reduce,b_prefix_reduce
    integer*4,                intent(in)    ,value  :: len
    integer*4 :: tid, dimx, i, j, wid, tmp1, tmp2, rid, atmp, btmp
    integer*4,shared,dimension(16) :: a_prefix_shared,b_prefix_shared

    tid = threadIdx%x
    wid = mod(threadIdx%x-1,32) + 1
    rid = (tid-1)/32 + 1
    dimx = blockDim%x
    if(tid > len) return
    atmp = a_prefix_reduce(tid)
    btmp = b_prefix_reduce(tid)
    if(tid <= 16) then
       a_prefix_shared(tid) = 0
       b_prefix_shared(tid) = 0
    end if

    i = 1
    do while(i < 32)
       tmp1 = __shfl_up(atmp,i)
       tmp2 = __shfl_up(btmp,i)
       if(wid > i) then
          atmp = atmp + tmp1
          btmp = btmp + tmp2
       endif
       i = i * 2
       call syncthreads()
    enddo
    a_prefix_reduce(tid) = atmp
    b_prefix_reduce(tid) = btmp
    if(wid == 32) then
       a_prefix_shared(rid) = atmp
       b_prefix_shared(rid) = btmp
    end if
    call syncthreads()
    if(tid == 1) then
       do i = 2, 16
          a_prefix_shared(i) = a_prefix_shared(i) + a_prefix_shared(i-1)
          b_prefix_shared(i) = b_prefix_shared(i) + b_prefix_shared(i-1)
       end do
    endif
    call syncthreads()
    if(rid-1 > 0) then
       a_prefix_reduce(tid) = a_prefix_reduce(tid) + a_prefix_shared(rid-1)
       b_prefix_reduce(tid) = b_prefix_reduce(tid) + b_prefix_shared(rid-1)
    end if
    
  end subroutine opt_prefix_sum_mid

  attributes(global) subroutine opt_prefix_sum_post(a_prefix,b_prefix,lenl,lent,a_strk,b_strk,a_prefix_tmp,b_prefix_tmp,a_prefix_reduce,b_prefix_reduce,len,lenr,k)
    integer*4,dimension(len),   intent(out)           :: a_prefix,b_prefix
    integer*4,                  intent(out)           :: lenl,lent
    integer*4,dimension(k+1),   intent(out)           :: a_strk,b_strk
    integer*4,dimension(len),   intent(out)           :: a_prefix_tmp,b_prefix_tmp
    integer*4,dimension(lenr),  intent(in)            :: a_prefix_reduce,b_prefix_reduce
    integer*4,                  intent(in)    ,value  :: len,lenr,k
    integer*4 :: tid, rid, atmp, btmp

    tid = blockDim%x * (blockIdx%x -1) + threadIdx%x
    rid = (tid-1)/32 + 1

    if(tid > len) return
    if(rid-1 > 0) then
       atmp = a_prefix_tmp(tid) + a_prefix_reduce(rid-1)
       btmp = b_prefix_tmp(tid) + b_prefix_reduce(rid-1)
    else
       atmp = a_prefix_tmp(tid)
       btmp = b_prefix_tmp(tid)
    end if
    a_prefix(tid) = atmp
    b_prefix(tid) = btmp
    if(tid == len) then
       lenl = atmp
       lent = btmp
       a_strk(k+1) = lenl + a_strk(k)
       b_strk(k+1) = lent + b_strk(k)
    endif

  end subroutine opt_prefix_sum_post
#endif
!   attributes(global) subroutine prefix_init(a_prefix,b_prefix,ndlp,ndtp,isnt_finished,len)

!     integer*4,dimension(:),    intent(out)           :: a_prefix,b_prefix
! !    type(workarray),           intent(inout)         :: work
!     integer*4,dimension(:),    intent(in)            :: ndlp,ndtp
!     integer*4,dimension(:),    intent(in)            :: isnt_finished
!     integer*4,                 intent(in)    ,value  :: len

! !    integer*4,dimension(:),pointer :: a_prefix,b_prefix

!     tid = blockDim%x * (blockIdx%x -1) + threadIdx%x
!     if(tid > len) return
!     ! a_prefix => work%a_prefix
!     ! b_prefix => work%b_prefix

!     a_prefix(tid) = ndlp(tid)*isnt_finished(tid)
!     b_prefix(tid) = ndtp(tid)*isnt_finished(tid)

!   end subroutine prefix_init

!   attributes(global) subroutine step_prefix_sum(a_prefix,b_prefix,ndlp,ndtp,isnt_finished,len)

!     integer*4,dimension(:),    intent(out)           :: a_prefix,b_prefix
! !    type(workarray),           intent(inout)         :: work
!     integer*4,dimension(:),    intent(in)            :: ndlp,ndtp
!     integer*4,dimension(:),    intent(in)            :: isnt_finished
!     integer*4,                 intent(in)    ,value  :: len

! !    integer*4,dimension(:),pointer :: a_prefix,b_prefix
!     integer*4 :: tid, i, rid, istat, tmp

!     tid = blockDim%x * (blockIdx%x -1) + threadIdx%x
!     if(tid > len) return
!     ! a_prefix => work%a_prefix
!     ! b_prefix => work%b_prefix

!     a_prefix(tid) = ndlp(tid)*isnt_finished(tid)
!     b_prefix(tid) = ndtp(tid)*isnt_finished(tid)
    
!     i = 1
!     do while(i < len)
!        rid = tid - i
!        if(rid < 1) return
!        tmp = a_prefix(rid)
!        istat = atomicadd(a_prefix(tid),tmp)
!        tmp = b_prefix(rid)
!        istat = atomicadd(b_prefix(tid),tmp)
!        i = i * 2
!     end do

!   end subroutine step_prefix_sum

  attributes(global) subroutine init_leafval(znrms,leafist,znrmmat,ndlp,ndtp,nstrtlp,nstrttp,len)
    real*8   ,dimension(len),  intent(out)           :: znrms
    integer*4,dimension(len),  intent(out)           :: leafist
    real*8   ,                               value   :: znrmmat
    integer*4,dimension(len),  intent(in)            :: ndlp,ndtp
    integer*4,dimension(len),  intent(in)            :: nstrtlp,nstrttp
    integer*4,                               value   :: len
    integer*4 :: tid
    tid = blockDim%x * (blockIdx%x - 1) + threadIdx%x
    if(tid > len) return
    znrms(tid) = znrmmat*sqrt(real(ndlp(tid))*real(ndtp(tid)))
    
    if(nstrtlp(tid)>nstrttp(tid)) then
       leafist(tid)=1
    else
       leafist(tid)=ndlp(tid)
    end if

  end subroutine init_leafval

  attributes(global) subroutine init_leafval2(znrms,leafist,isnt_finished,kstop,znrmmat,ndlp,ndtp,nstrtlp,nstrttp,len,kmax)
    real*8   ,dimension(len),  intent(out)           :: znrms
    integer*4,dimension(len),  intent(out)           :: leafist,isnt_finished,kstop
    real*8   ,                               value   :: znrmmat
    integer*4,dimension(len),  intent(in)            :: ndlp,ndtp
    integer*4,dimension(len),  intent(in)            :: nstrtlp,nstrttp
    integer*4,                               value   :: len,kmax
    integer*4 :: tid,ndl,ndt
    tid = blockDim%x * (blockIdx%x - 1) + threadIdx%x
    if(tid > len) return
    ndl = ndlp(tid)
    ndt = ndtp(tid)
    znrms(tid) = znrmmat*sqrt(real(ndl)*real(ndt))
    isnt_finished(tid) = 1
    kstop(tid) = min(kmax,min(ndl,ndt))
    if(nstrtlp(tid)>nstrttp(tid)) then
       leafist(tid)=1
    else
       leafist(tid)=ndlp(tid)
    end if

  end subroutine init_leafval2

  attributes(global) subroutine init_leafval3(znrms,leafist,isnt_finished,kstop,znrmmat,ndlp,ndtp,nstrtlp,nstrttp,len,kmax,notConvergedBlocks)
    real*8   ,dimension(len),  intent(out)           :: znrms
    integer*4,dimension(len),  intent(out)           :: leafist,kstop
    integer*4,dimension(len,2),intent(out)           :: isnt_finished
    integer*4,dimension(len,2),intent(out)           :: notConvergedBlocks
    real*8   ,                               value   :: znrmmat
    integer*4,dimension(len),  intent(in)            :: ndlp,ndtp
    integer*4,dimension(len),  intent(in)            :: nstrtlp,nstrttp
    integer*4,                               value   :: len,kmax
    integer*4 :: tid,ndl,ndt
    tid = blockDim%x * (blockIdx%x - 1) + threadIdx%x
    if(tid > len) return
    ndl = ndlp(tid)
    ndt = ndtp(tid)
    znrms(tid) = znrmmat*sqrt(real(ndl)*real(ndt))
    isnt_finished(tid,1) = 1
    isnt_finished(tid,2) = 1
    notConvergedBlocks(tid,1) = tid
    notConvergedBlocks(tid,2) = tid
    kstop(tid) = min(kmax,min(ndl,ndt))
    if(nstrtlp(tid)>nstrttp(tid)) then
       leafist(tid)=1
    else
       leafist(tid)=ndlp(tid)
    end if

  end subroutine init_leafval3


  attributes(global) subroutine calc_length_pre(tmpl,tmpt,ndlp,ndtp,len,tmplen)
    integer*4,dimension(tmplen),intent(out)          :: tmpl,tmpt
    integer*4,dimension(len),   intent(in)           :: ndlp,ndtp
    integer*4,                               value   :: len,tmplen
    integer*4 :: tid,ndl,ndt,tmp1,tmp2,lid,wid,wdim,i,tx,bx
    integer*4,shared,dimension(16):: ishared1,ishared2
    tx  = threadIdx%x
    bx  = blockIdx%x
    tid = blockDim%x * (bx - 1) + tx
    lid = mod(tx-1,32) + 1
    wid = (tx-1)/32 + 1
    wdim= blockDim%x / 32
    if(tid > len) return
    tmp1 = ndlp(tid)
    tmp2 = ndtp(tid)

    tmp1 = tmp1 + __shfl_xor(tmp1,16)
    tmp1 = tmp1 + __shfl_xor(tmp1,8)
    tmp1 = tmp1 + __shfl_xor(tmp1,4)
    tmp1 = tmp1 + __shfl_xor(tmp1,2)
    tmp1 = tmp1 + __shfl_xor(tmp1,1)

    tmp2 = tmp2 + __shfl_xor(tmp2,16)
    tmp2 = tmp2 + __shfl_xor(tmp2,8)
    tmp2 = tmp2 + __shfl_xor(tmp2,4)
    tmp2 = tmp2 + __shfl_xor(tmp2,2)
    tmp2 = tmp2 + __shfl_xor(tmp2,1)
    call syncthreads()
    if(lid == 1) then
       ishared1(wid) = tmp1
       ishared2(wid) = tmp2
    end if
    call syncthreads()
    tmp1 = 0
    tmp2 = 0
    do i = 1, wdim
       tmp1 = tmp1 + ishared1(i)
       tmp2 = tmp2 + ishared2(i)
    end do
    if(tx == 1) then
       tmpl(bx) = tmp1
       tmpt(bx) = tmp2
!       print *, tid,tmp1, tmp2
    end if

  end subroutine calc_length_pre

  attributes(global) subroutine calc_length_post(lenl,lent,tmpl,tmpt,tmplen)
    integer*4,                  intent(out)          :: lenl,lent
    integer*4,dimension(tmplen),intent(in)           :: tmpl,tmpt
    integer*4,                               value   :: tmplen
    integer*4 :: tid,tmp1,tmp2,lid,wid,wdim,i
    integer*4,shared,dimension(16):: ishared1,ishared2
    tid = threadIdx%x
    lid = mod(threadIdx%x-1,32) + 1
    wid = (threadIdx%x-1)/32 + 1
    wdim= blockDim%x / 32
    tmp1 = 0
    tmp2 = 0
    do i = tid, tmplen, blockDim%x
       tmp1 = tmp1 + tmpl(i)
       tmp2 = tmp2 + tmpt(i)
    end do

    tmp1 = tmp1 + __shfl_xor(tmp1,16)
    tmp1 = tmp1 + __shfl_xor(tmp1,8)
    tmp1 = tmp1 + __shfl_xor(tmp1,4)
    tmp1 = tmp1 + __shfl_xor(tmp1,2)
    tmp1 = tmp1 + __shfl_xor(tmp1,1)

    tmp2 = tmp2 + __shfl_xor(tmp2,16)
    tmp2 = tmp2 + __shfl_xor(tmp2,8)
    tmp2 = tmp2 + __shfl_xor(tmp2,4)
    tmp2 = tmp2 + __shfl_xor(tmp2,2)
    tmp2 = tmp2 + __shfl_xor(tmp2,1)
    call syncthreads()
    if(lid == 1) then
       ishared1(wid) = tmp1
       ishared2(wid) = tmp2
    end if
    call syncthreads()
    tmp1 = 0
    tmp2 = 0
    do i = 1, wdim
       tmp1 = tmp1 + ishared1(i)
       tmp2 = tmp2 + ishared2(i)
    end do
    if(tid == 1) then
       lenl = tmp1
       lent = tmp2
    end if

  end subroutine calc_length_post

  attributes(global) subroutine init_msk(msk,len)
    integer*4, dimension(len),intent(out) :: msk
    integer*4, value                      :: len
    integer*4 :: tid
    tid = blockDim%x * (blockIdx%x - 1) + threadIdx%x
    if(tid > len) return
    msk(tid) = 0
  end subroutine init_msk

!  attributes(global) subroutine create_subid(work,subidl,subidt)
  attributes(global) subroutine create_subid(subidl,subidt,ndl_prefix,ndt_prefix,lenl,lent,n_low)

!    type(workarray),           intent(inout)         :: work
    integer*4,dimension(lenl), intent(out)           :: subidl
    integer*4,dimension(lent), intent(out)           :: subidt
    integer*4,dimension(n_low),intent(in)            :: ndl_prefix,ndt_prefix
    integer*4,                             value     :: lenl,lent,n_low

!    integer*4,dimension(:),    pointer               :: ndl_prefix,ndt_prefix
    integer*4 :: ip,tx,ndl,ndt,ndl_pre,ndt_pre,dimx,i

    ip = blockIdx%x
    tx = threadIdx%x
    dimx = blockDim%x

    ! ndl_prefix => work%a_prefix
    ! ndt_prefix => work%b_prefix

    ndl    =ndl_prefix(ip+1)-ndl_prefix(ip)
    ndt    =ndt_prefix(ip+1)-ndt_prefix(ip)
    ndl_pre=ndl_prefix(ip)-1
    ndt_pre=ndt_prefix(ip)-1

    do i = tx,ndt,dimx
       subidt(ndt_pre+i) = ip
    enddo
    do i = tx,ndl,dimx
       subidl(ndl_pre+i) = ip
    enddo

  end subroutine create_subid


  attributes(global) subroutine create_subid2(subidl,subidt,ndl_prefix,ndt_prefix,lenl,lent,n_low,notConvergedBlocks,lenb)
    integer*4,dimension(lenl), intent(out)           :: subidl
    integer*4,dimension(lent), intent(out)           :: subidt
    integer*4,dimension(n_low),intent(in)            :: ndl_prefix,ndt_prefix
    integer*4,dimension(n_low),intent(in)            :: notConvergedBlocks
    integer*4,                             value     :: lenl,lent,n_low,lenb

    integer*4 :: ip,tx,ndl,ndt,ndl_pre,ndt_pre,dimx,i

    ip = notConvergedBlocks(blockIdx%x)
    tx = threadIdx%x
    dimx = blockDim%x

    ! ndl_prefix => work%a_prefix
    ! ndt_prefix => work%b_prefix

    ndl    =ndl_prefix(ip+1)-ndl_prefix(ip)
    ndt    =ndt_prefix(ip+1)-ndt_prefix(ip)
    ndl_pre=ndl_prefix(ip)-1
    ndt_pre=ndt_prefix(ip)-1

    do i = tx,ndt,dimx
       subidt(ndt_pre+i) = ip
    enddo
    do i = tx,ndl,dimx
       subidl(ndl_pre+i) = ip
    enddo

  end subroutine create_subid2


  attributes(global) subroutine create_subid_dense(subidd,idx3,ndlp,ndtp,n_low,n_dence,len)

    integer*4,dimension(len)          ,intent(out)        :: subidd
    integer*4,dimension(n_low+n_dence),intent(in)         :: idx3
    integer*4,dimension(n_low+n_dence),intent(in)         :: ndlp,ndtp
    integer*4,                                     value  :: n_low,n_dence,len
    integer*4 :: ip,tx,dimx,i,pre,nd

    ip = blockIdx%x + n_low
    tx = threadIdx%x
    dimx = blockDim%x
    pre = idx3(ip)-1
    nd  = ndlp(ip)*ndtp(ip)
    do i = tx,nd,dimx
       subidd(pre+i) = ip
    enddo

  end subroutine create_subid_dense


  attributes(global) subroutine create_subid_dense_2D(subidd,idx3,n_low,n_dence,len,ndt_max)
    integer*4,dimension(len)              ,intent(out)        :: subidd
    integer*4,dimension(n_dence*ndt_max+1),intent(in)         :: idx3
    integer*4,                                         value  :: n_low,n_dence,len,ndt_max
    integer*4 :: ip,tx,dimx,i,pre,nd,bid

    bid = blockIdx%x
    ip = blockIdx%x
    tx = threadIdx%x
    dimx = blockDim%x
    pre = idx3(bid)-1
    nd  = idx3(bid+1)-idx3(bid)
    do i = tx,nd,dimx
       subidd(pre+i) = ip
    enddo

  end subroutine create_subid_dense_2D


#define PI (3.141592653589793)
#define EPSILON_0  (8.854187818 * 1d-12)
#define INV_4_PI_EPSILON_0 (1.d0 / (4d0 * PI * EPSILON_0))
  attributes(global) subroutine calc_vec_old                                                         &
!       (za,reduced_prefix,leafid,leafpib,msk,nd,nstrl,nstrt,true_prefix,ao,lp61,len,ndl_or_ndt)
       (zaa,zab,a_prefix,b_prefix,a_strk,b_strk,leafid,leafpib,msk,nd,nstrl,nstrt,ndl_prefix,ndt_prefix,xsyszs,ao,lp61,len,k,ndl_or_ndt,lza,n_low,lmsk,lxyz)
!       (work,leafid,leafpib,msk,nd,nstrl,nstrt,true_prefix,xsyszs,ao,lp61,len,ndl_or_ndt)

!     real*8,   dimension(lza),  intent(out)           :: zaa,zab
!     integer*4,dimension(n_low,k),intent(in)          :: a_prefix,b_prefix
!     integer*4,dimension(k),    intent(in)            :: a_strk,b_strk
! !    type(workarray),           intent(inout)         :: work
!     integer*4,dimension(n_low),intent(in)            :: leafid,leafpib
! !    integer*1,dimension(:),    intent(inout)         :: msk
!     integer*4,dimension(lmsk), intent(inout)         :: msk
!     integer*4,dimension(n_low),intent(in)            :: nd,nstrl,nstrt
!     integer*4,dimension(n_low),intent(in)            :: ndl_prefix,ndt_prefix
!     real*8,   dimension(lxyz,9),intent(in)           :: xsyszs
!     real*8,   dimension(lxyz), intent(in)            :: ao
    real*8,   dimension(lza),  intent(out)           :: zaa,zab
    integer*4,dimension(n_low+1,k),intent(in)        :: a_prefix,b_prefix
    integer*4,dimension(k),    intent(in)            :: a_strk,b_strk
!    type(workarray),           intent(inout)         :: work
    integer*4,dimension(n_low),intent(in)            :: leafid,leafpib
!    integer*1,dimension(:),    intent(inout)         :: msk
    integer*4,dimension(lmsk), intent(inout)         :: msk
    integer*4,dimension(n_low),intent(in)            :: nd,nstrl,nstrt
    integer*4,dimension(n_low),intent(in)            :: ndl_prefix,ndt_prefix
    real*8,   dimension(lxyz,9),intent(in)           :: xsyszs
    real*8,   dimension(lxyz), intent(in)            :: ao
    integer*4,                 intent(in)    ,value  :: lp61,len,k,lza,n_low,lmsk,lxyz
    integer*4,                 intent(in)    ,value  :: ndl_or_ndt ! ndl = 1, ndt = 0

    
    integer*4 :: ld,strl,strt,ip,pib,loci,ill,itt
    real*8    :: xs(3),ys(3),zs(3),x,y,z
    integer*4 :: tid,tpre,rpre,mskid
    real*8    :: dtmp, dtmp2

    real*8 :: r(3)
    real*8 :: xi, xj, yi, dx, dy, t, l, m, d, ti, tj
    real*8 :: theta, omega, q, g, zp, zpabs
    
    integer :: i, j
    real*8 :: u(3), v(3), w(3) 
    real*8 :: ox, oy, oz 

    tid = blockDim%x * (blockIdx%x - 1) + threadIdx%x
    if(tid > len) return

    ! if(ndl_or_ndt == 0) then
    !    za => work%zab
    !    reduced_prefix => work%b_prefix
    ! else
    !    za => work%zaa
    !    reduced_prefix => work%a_prefix
    ! endif

    ip      =leafid(tid)    

!    if(msk(mskid)==0) then

!       ld   =nd(ip)
    strl =nstrl(ip)
    strt =nstrt(ip)
    pib  =leafpib(ip)
    ! if(tid == 1) print *, "len", len
    ! if(tid == 1) print *, "ip", ip
    ! if(tid == 1) print *, "tpre", tpre
    ! if(tid == 1) print *, "rpre", rpre
    ! if(tid == 1) print *, "loci", loci
    ! if(tid == 1) print *, "mskid", mskid
    ! if(tid == 1) print *, "strl", strl
    ! if(tid == 1) print *, "strt", strt
    ! if(tid == 1) print *, "pib", pib
    ! if(tid == 1) print *, "ndl_or_ndt", ndl_or_ndt
    
    if(ndl_or_ndt == 0) then
       tpre  =ndt_prefix(ip)
       rpre  =b_prefix(ip,k)
       loci  =tid-rpre + 1
       ill   =pib +strl-1
       itt   =loci+strt-1
    else
       tpre  =ndl_prefix(ip)
       rpre  =a_prefix(ip,k)
       loci  =tid-rpre + 1
       ill   =loci+strl-1
       itt   =pib +strt-1
    end if
    mskid =tpre + loci -1
    if(msk(mskid) == 1) then
       dtmp2 = 0.0d0
    else
    
       xs(1:3) = xsyszs(ill, 1:3)
       ys(1:3) = xsyszs(ill, 4:6)
       zs(1:3) = xsyszs(ill, 7:9)
       x = (xs(1) + xs(2) + xs(3)) / 3d0
       y = (ys(1) + ys(2) + ys(3)) / 3d0
       z = (zs(1) + zs(2) + zs(3)) / 3d0
       
       xs(1:3) = xsyszs(itt, 1:3)
       ys(1:3) = xsyszs(itt, 4:6)
       zs(1:3) = xsyszs(itt, 7:9)
       
       ! if(tid == 1) print *, "x", x
       ! if(tid == 1) print *, "y", y
       ! if(tid == 1) print *, "z", z
       ! if(tid == 1) print *, "xs", xs(1), xs(2), xs(3)
       ! if(tid == 1) print *, "ys", ys(1), ys(2), ys(3)
       ! if(tid == 1) print *, "zs", zs(1), zs(2), zs(3)
       
       !       dtmp = face_integral_cuda(xs, ys, zs, x, y, z)
       r(:) = sqrt( (xs(:) - x)**2 + (ys(:) - y)**2 + (zs(:) - z)**2 )
       
       u(1) = xs(2) - xs(1);  v(1) = xs(3) - xs(2)
       u(2) = ys(2) - ys(1);  v(2) = ys(3) - ys(2)
       u(3) = zs(2) - zs(1);  v(3) = zs(3) - zs(2)
       
       !    call cross_product_g(u, v, w)
       w(1) = u(2) * v(3) - u(3) * v(2)
       w(2) = u(3) * v(1) - u(1) * v(3)
       w(3) = u(1) * v(2) - u(2) * v(1)
       
       dtmp = 1 / sqrt( dot_product(w, w) )
       w(:) = w(:) * dtmp 
       !    if(tid == 1) print *, "w", w(1), w(2), w(3)
       u(1) = x - xs(1);  u(2) = y - ys(1);  u(3) = z - zs(1)
       zp = dot_product(u, w)
       ox = x - zp * w(1);  oy = y - zp * w(2);  oz = z - zp * w(3)
       zpabs = abs(zp)
       
       dtmp2 = 0d0
       do i = 1, 3
          j = mod(i, 3) + 1
          u(1) = xs(j) - ox;  u(2) = ys(j) - oy; u(3) = zs(j) - oz;
          xj = sqrt( dot_product(u, u) )
          dtmp = 1 / xj
          u(:) = u(:) * dtmp
          !       call cross_product_g(w, u, v) 
          v(1) = w(2) * u(3) - w(3) * u(2)
          v(2) = w(3) * u(1) - w(1) * u(3)
          v(3) = w(1) * u(2) - w(2) * u(1)
          xi = (xs(i) - ox) * u(1) + (ys(i) - oy) * u(2) + (zs(i) - oz) * u(3)
          yi = (xs(i) - ox) * v(1) + (ys(i) - oy) * v(2) + (zs(i) - oz) * v(3)
          
          dx = xj - xi;  dy = - yi ! (yj = 0)
          t = 1/sqrt( dx**2 + dy**2 )
          l = dx*t;  m = dy*t
          d = l * yi - m * xi
          ti = l * xi + m * yi;  tj = l * xj ! (yj = 0)
          
          !            theta = sign(1d0, yi) * acos( xi / sqrt( xi**2 + yi**2 ) ) ! (xj > 0, yj = 0)
          theta = atan2(yi, xi)
          omega = theta - atan2( r(i) * d, zpabs * ti ) + atan2( r(j) * d, zpabs * tj )
          q = log( (r(j) + tj) / ( r(i) + ti ) )
          g = d * q - zpabs * omega 
          dtmp2 = dtmp2 + g
       enddo
       
       !    if(tid == 1) print *, "dtmp2", dtmp2
       dtmp2 = abs(dtmp2) / (4d0 * PI * EPSILON_0)       
       !    if(tid == 1) print *, "dtmp2", dtmp2
       
       if(lp61==3) dtmp2=dtmp2*ao(ill)*ao(itt)
       !    za(tid) = dtmp2
       
       if(ndl_or_ndt == 0) then
          do i = 1, k-1, 1
             dtmp2 = dtmp2-zab(loci+b_prefix(ip,i)-1+b_strk(i)-1)*zaa(pib+a_prefix(ip,i)-1+a_strk(i)-1)
          enddo
       else
          do i = 1, k-1, 1
             dtmp2 = dtmp2-zaa(loci+a_prefix(ip,i)-1+a_strk(i)-1)*zab(pib+b_prefix(ip,i)-1+b_strk(i)-1)
          enddo
       endif

    end if
    if(ndl_or_ndt == 0) then
       zab(tid+b_strk(k)-1) = dtmp2
    else
       zaa(tid+a_strk(k)-1) = dtmp2
    endif

  end subroutine calc_vec_old

  attributes(global) subroutine calc_vec                                                         &
!       (za,reduced_prefix,leafid,leafpib,msk,nd,nstrl,nstrt,true_prefix,ao,lp61,len,ndl_or_ndt)
       (zaa,zab,a_prefix,b_prefix,a_strk,b_strk,leafid,leafpib,msk,nd,nstrl,nstrt,ndl_prefix,ndt_prefix,xsyszs,ao,lp61,len,k,ndl_or_ndt,lza,n_low,lmsk,lxyz)
!       (work,leafid,leafpib,msk,nd,nstrl,nstrt,true_prefix,xsyszs,ao,lp61,len,ndl_or_ndt)

!     real*8,   dimension(lza),  intent(out)           :: zaa,zab
!     integer*4,dimension(n_low,k),intent(in)          :: a_prefix,b_prefix
!     integer*4,dimension(k),    intent(in)            :: a_strk,b_strk
! !    type(workarray),           intent(inout)         :: work
!     integer*4,dimension(n_low),intent(in)            :: leafid,leafpib
! !    integer*1,dimension(:),    intent(inout)         :: msk
!     integer*4,dimension(lmsk), intent(inout)         :: msk
!     integer*4,dimension(n_low),intent(in)            :: nd,nstrl,nstrt
!     integer*4,dimension(n_low),intent(in)            :: ndl_prefix,ndt_prefix
!     real*8,   dimension(lxyz,9),intent(in)           :: xsyszs
!     real*8,   dimension(lxyz), intent(in)            :: ao
    real*8,   dimension(lza),  intent(out)           :: zaa,zab
    integer*4,dimension(n_low+1,k),intent(in)        :: a_prefix,b_prefix
    integer*4,dimension(k),    intent(in)            :: a_strk,b_strk
!    type(workarray),           intent(inout)         :: work
    integer*4,dimension(n_low),intent(in)            :: leafid,leafpib
!    integer*1,dimension(:),    intent(inout)         :: msk
    integer*4,dimension(lmsk), intent(inout)         :: msk
    integer*4,dimension(n_low),intent(in)            :: nd,nstrl,nstrt
    integer*4,dimension(n_low),intent(in)            :: ndl_prefix,ndt_prefix
    real*8,   dimension(lxyz,9),intent(in)           :: xsyszs
    real*8,   dimension(lxyz), intent(in)            :: ao
    integer*4,                 intent(in)    ,value  :: lp61,len,k,lza,n_low,lmsk,lxyz
    integer*4,                 intent(in)    ,value  :: ndl_or_ndt ! ndl = 1, ndt = 0

    
    integer*4 :: ld,strl,strt,ip,pib,loci,ill,itt
    real*8    :: xs(3),ys(3),zs(3),x,y,z
    integer*4 :: tid,tpre,rpre,mskid
    real*8    :: dtmp, dtmp2

    real*8 :: r(3)
    real*8 :: xi, xj, yi, dx, dy, t, l, m, d, ti, tj
    real*8 :: theta, omega, q, g, zp, zpabs
    
    integer :: i, j
    real*8 :: u(3), v(3), w(3) 
    real*8 :: ox, oy, oz 

    tid = blockDim%x * (blockIdx%x - 1) + threadIdx%x
    if(tid > len) return

    ! if(ndl_or_ndt == 0) then
    !    za => work%zab
    !    reduced_prefix => work%b_prefix
    ! else
    !    za => work%zaa
    !    reduced_prefix => work%a_prefix
    ! endif

    ip      =leafid(tid)    

!    if(msk(mskid)==0) then

!       ld   =nd(ip)
    strl =nstrl(ip)
    strt =nstrt(ip)
    pib  =leafpib(ip)
    ! if(tid == 1) print *, "len", len
    ! if(tid == 1) print *, "ip", ip
    ! if(tid == 1) print *, "tpre", tpre
    ! if(tid == 1) print *, "rpre", rpre
    ! if(tid == 1) print *, "loci", loci
    ! if(tid == 1) print *, "mskid", mskid
    ! if(tid == 1) print *, "strl", strl
    ! if(tid == 1) print *, "strt", strt
    ! if(tid == 1) print *, "pib", pib
    ! if(tid == 1) print *, "ndl_or_ndt", ndl_or_ndt
    
    if(ndl_or_ndt == 0) then
       tpre  =ndt_prefix(ip)
       rpre  =b_prefix(ip,k)
       loci  =tid-rpre + 1
       ill   =pib +strl-1
       itt   =loci+strt-1
    else
       tpre  =ndl_prefix(ip)
       rpre  =a_prefix(ip,k)
       loci  =tid-rpre + 1
       ill   =loci+strl-1
       itt   =pib +strt-1
    end if
    mskid =tpre + loci -1
    
    xs(1:3) = xsyszs(ill, 1:3)
    ys(1:3) = xsyszs(ill, 4:6)
    zs(1:3) = xsyszs(ill, 7:9)
    x = (xs(1) + xs(2) + xs(3)) / 3d0
    y = (ys(1) + ys(2) + ys(3)) / 3d0
    z = (zs(1) + zs(2) + zs(3)) / 3d0
    
    xs(1:3) = xsyszs(itt, 1:3)
    ys(1:3) = xsyszs(itt, 4:6)
    zs(1:3) = xsyszs(itt, 7:9)
    
    ! if(tid == 1) print *, "x", x
    ! if(tid == 1) print *, "y", y
    ! if(tid == 1) print *, "z", z
    ! if(tid == 1) print *, "xs", xs(1), xs(2), xs(3)
    ! if(tid == 1) print *, "ys", ys(1), ys(2), ys(3)
    ! if(tid == 1) print *, "zs", zs(1), zs(2), zs(3)
    
    !       dtmp = face_integral_cuda(xs, ys, zs, x, y, z)
    r(:) = sqrt( (xs(:) - x)**2 + (ys(:) - y)**2 + (zs(:) - z)**2 )
    
    u(1) = xs(2) - xs(1);  v(1) = xs(3) - xs(2)
    u(2) = ys(2) - ys(1);  v(2) = ys(3) - ys(2)
    u(3) = zs(2) - zs(1);  v(3) = zs(3) - zs(2)

    !    call cross_product_g(u, v, w)
    w(1) = u(2) * v(3) - u(3) * v(2)
    w(2) = u(3) * v(1) - u(1) * v(3)
    w(3) = u(1) * v(2) - u(2) * v(1)

    dtmp = 1 / sqrt( dot_product(w, w) )
    w(:) = w(:) * dtmp 
!    if(tid == 1) print *, "w", w(1), w(2), w(3)
    u(1) = x - xs(1);  u(2) = y - ys(1);  u(3) = z - zs(1)
    zp = dot_product(u, w)
    ox = x - zp * w(1);  oy = y - zp * w(2);  oz = z - zp * w(3)
    zpabs = abs(zp)

    dtmp2 = 0d0
    do i = 1, 3
       j = mod(i, 3) + 1
       u(1) = xs(j) - ox;  u(2) = ys(j) - oy; u(3) = zs(j) - oz;
       xj = sqrt( dot_product(u, u) )
       dtmp = 1 / xj
       u(:) = u(:) * dtmp
!       call cross_product_g(w, u, v) 
       v(1) = w(2) * u(3) - w(3) * u(2)
       v(2) = w(3) * u(1) - w(1) * u(3)
       v(3) = w(1) * u(2) - w(2) * u(1)
       xi = (xs(i) - ox) * u(1) + (ys(i) - oy) * u(2) + (zs(i) - oz) * u(3)
       yi = (xs(i) - ox) * v(1) + (ys(i) - oy) * v(2) + (zs(i) - oz) * v(3)
       
       dx = xj - xi;  dy = - yi ! (yj = 0)
       t = 1/sqrt( dx**2 + dy**2 )
       l = dx*t;  m = dy*t
       d = l * yi - m * xi
       ti = l * xi + m * yi;  tj = l * xj ! (yj = 0)
       
       !            theta = sign(1d0, yi) * acos( xi / sqrt( xi**2 + yi**2 ) ) ! (xj > 0, yj = 0)
       theta = atan2(yi, xi)
       omega = theta - atan2( r(i) * d, zpabs * ti ) + atan2( r(j) * d, zpabs * tj )
       q = log( (r(j) + tj) / ( r(i) + ti ) )
       g = d * q - zpabs * omega 
       dtmp2 = dtmp2 + g
    enddo
    
!    if(tid == 1) print *, "dtmp2", dtmp2
    dtmp2 = abs(dtmp2) / (4d0 * PI * EPSILON_0)       
!    if(tid == 1) print *, "dtmp2", dtmp2
    
    if(lp61==3) dtmp2=dtmp2*ao(ill)*ao(itt)
!    za(tid) = dtmp2

    if(ndl_or_ndt == 0) then
       do i = 1, k-1, 1
          dtmp2 = dtmp2-zab(loci+b_prefix(ip,i)-1+b_strk(i)-1)*zaa(pib+a_prefix(ip,i)-1+a_strk(i)-1)
       enddo
       if(msk(mskid) == 1) then
          dtmp2 = 0.0d0
       end if
       zab(tid+b_strk(k)-1) = dtmp2
    else
       do i = 1, k-1, 1
          dtmp2 = dtmp2-zaa(loci+a_prefix(ip,i)-1+a_strk(i)-1)*zab(pib+b_prefix(ip,i)-1+b_strk(i)-1)
       enddo
       if(msk(mskid) == 1) then
          dtmp2 = 0.0d0
       end if
       zaa(tid+a_strk(k)-1) = dtmp2
    endif


  end subroutine calc_vec

  attributes(global) subroutine calc_vec2                                                         &
!       (za,reduced_prefix,leafid,leafpib,msk,nd,nstrl,nstrt,true_prefix,ao,lp61,len,ndl_or_ndt)
       (zaa,zab,a_prefix,b_prefix,a_strk,b_strk,leafid,leafpib,msk,nd,nstrl,nstrt,ndl_prefix,ndt_prefix,xsyszs,xyz,ao,lp61,len,k,ndl_or_ndt,lza,n_low,lmsk,lxyz)
!       (work,leafid,leafpib,msk,nd,nstrl,nstrt,true_prefix,xsyszs,ao,lp61,len,ndl_or_ndt)

!     real*8,   dimension(lza),  intent(out)           :: zaa,zab
!     integer*4,dimension(n_low,k),intent(in)          :: a_prefix,b_prefix
!     integer*4,dimension(k),    intent(in)            :: a_strk,b_strk
! !    type(workarray),           intent(inout)         :: work
!     integer*4,dimension(n_low),intent(in)            :: leafid,leafpib
! !    integer*1,dimension(:),    intent(inout)         :: msk
!     integer*4,dimension(lmsk), intent(inout)         :: msk
!     integer*4,dimension(n_low),intent(in)            :: nd,nstrl,nstrt
!     integer*4,dimension(n_low),intent(in)            :: ndl_prefix,ndt_prefix
!     real*8,   dimension(lxyz,9),intent(in)           :: xsyszs
!     real*8,   dimension(lxyz), intent(in)            :: ao
    real*8,   dimension(lza),  intent(out)           :: zaa,zab
    integer*4,dimension(n_low+1,k),intent(in)        :: a_prefix,b_prefix
    integer*4,dimension(k),    intent(in)            :: a_strk,b_strk
!    type(workarray),           intent(inout)         :: work
    integer*4,dimension(n_low),intent(in)            :: leafid,leafpib
!    integer*1,dimension(:),    intent(inout)         :: msk
    integer*4,dimension(lmsk), intent(inout)         :: msk
    integer*4,dimension(n_low),intent(in)            :: nd,nstrl,nstrt
    integer*4,dimension(n_low),intent(in)            :: ndl_prefix,ndt_prefix
    real*8,   dimension(lxyz,9),intent(in)           :: xsyszs
    real*8,   dimension(lxyz,3),intent(in)           :: xyz
    real*8,   dimension(lxyz), intent(in)            :: ao
    integer*4,                 intent(in)    ,value  :: lp61,len,k,lza,n_low,lmsk,lxyz
    integer*4,                 intent(in)    ,value  :: ndl_or_ndt ! ndl = 1, ndt = 0

    
    integer*4 :: ld,strl,strt,ip,pib,loci,ill,itt
    real*8    :: xs(3),ys(3),zs(3),x,y,z
    integer*4 :: tid,tpre,rpre,mskid
    real*8    :: dtmp, dtmp2

    real*8 :: r(3)
    real*8 :: xi, xj, yi, dx, dy, t, l, m, d, ti, tj
    real*8 :: theta, omega, q, g, zp, zpabs
    
    integer :: i, j
    real*8 :: u(3), v(3), w(3) 
    real*8 :: ox, oy, oz 

    tid = blockDim%x * (blockIdx%x - 1) + threadIdx%x
    if(tid > len) return

    ! if(ndl_or_ndt == 0) then
    !    za => work%zab
    !    reduced_prefix => work%b_prefix
    ! else
    !    za => work%zaa
    !    reduced_prefix => work%a_prefix
    ! endif

    ip      =leafid(tid)    

!    if(msk(mskid)==0) then

!       ld   =nd(ip)
    strl =nstrl(ip)
    strt =nstrt(ip)
    pib  =leafpib(ip)
    ! if(tid == 1) print *, "len", len
    ! if(tid == 1) print *, "ip", ip
    ! if(tid == 1) print *, "tpre", tpre
    ! if(tid == 1) print *, "rpre", rpre
    ! if(tid == 1) print *, "loci", loci
    ! if(tid == 1) print *, "mskid", mskid
    ! if(tid == 1) print *, "strl", strl
    ! if(tid == 1) print *, "strt", strt
    ! if(tid == 1) print *, "pib", pib
    ! if(tid == 1) print *, "ndl_or_ndt", ndl_or_ndt
    
    if(ndl_or_ndt == 0) then
       tpre  =ndt_prefix(ip)
       rpre  =b_prefix(ip,k)
       loci  =tid-rpre + 1
       ill   =pib +strl-1
       itt   =loci+strt-1
    else
       tpre  =ndl_prefix(ip)
       rpre  =a_prefix(ip,k)
       loci  =tid-rpre + 1
       ill   =loci+strl-1
       itt   =pib +strt-1
    end if
    mskid =tpre + loci -1
    
    ! xs(1:3) = xsyszs(ill, 1:3)
    ! ys(1:3) = xsyszs(ill, 4:6)
    ! zs(1:3) = xsyszs(ill, 7:9)
    x = xyz(ill,1)
    y = xyz(ill,2)
    z = xyz(ill,3)
    
    xs(1:3) = xsyszs(itt, 1:3)
    ys(1:3) = xsyszs(itt, 4:6)
    zs(1:3) = xsyszs(itt, 7:9)
    
    ! if(tid == 1) print *, "x", x
    ! if(tid == 1) print *, "y", y
    ! if(tid == 1) print *, "z", z
    ! if(tid == 1) print *, "xs", xs(1), xs(2), xs(3)
    ! if(tid == 1) print *, "ys", ys(1), ys(2), ys(3)
    ! if(tid == 1) print *, "zs", zs(1), zs(2), zs(3)
    
    !       dtmp = face_integral_cuda(xs, ys, zs, x, y, z)
    r(:) = sqrt( (xs(:) - x)**2 + (ys(:) - y)**2 + (zs(:) - z)**2 )
    
    u(1) = xs(2) - xs(1);  v(1) = xs(3) - xs(2)
    u(2) = ys(2) - ys(1);  v(2) = ys(3) - ys(2)
    u(3) = zs(2) - zs(1);  v(3) = zs(3) - zs(2)

    !    call cross_product_g(u, v, w)
    w(1) = u(2) * v(3) - u(3) * v(2)
    w(2) = u(3) * v(1) - u(1) * v(3)
    w(3) = u(1) * v(2) - u(2) * v(1)

    dtmp = 1 / sqrt( dot_product(w, w) )
    w(:) = w(:) * dtmp 
!    if(tid == 1) print *, "w", w(1), w(2), w(3)
    u(1) = x - xs(1);  u(2) = y - ys(1);  u(3) = z - zs(1)
    zp = dot_product(u, w)
    ox = x - zp * w(1);  oy = y - zp * w(2);  oz = z - zp * w(3)
    zpabs = abs(zp)

    dtmp2 = 0d0
    do i = 1, 3
       j = mod(i, 3) + 1
       u(1) = xs(j) - ox;  u(2) = ys(j) - oy; u(3) = zs(j) - oz;
       xj = sqrt( dot_product(u, u) )
       dtmp = 1 / xj
       u(:) = u(:) * dtmp
!       call cross_product_g(w, u, v) 
       v(1) = w(2) * u(3) - w(3) * u(2)
       v(2) = w(3) * u(1) - w(1) * u(3)
       v(3) = w(1) * u(2) - w(2) * u(1)
       xi = (xs(i) - ox) * u(1) + (ys(i) - oy) * u(2) + (zs(i) - oz) * u(3)
       yi = (xs(i) - ox) * v(1) + (ys(i) - oy) * v(2) + (zs(i) - oz) * v(3)
       
       dx = xj - xi;  dy = - yi ! (yj = 0)
       t = 1/sqrt( dx**2 + dy**2 )
       l = dx*t;  m = dy*t
       d = l * yi - m * xi
       ti = l * xi + m * yi;  tj = l * xj ! (yj = 0)
       
       !            theta = sign(1d0, yi) * acos( xi / sqrt( xi**2 + yi**2 ) ) ! (xj > 0, yj = 0)
       theta = atan2(yi, xi)
       omega = theta - atan2( r(i) * d, zpabs * ti ) + atan2( r(j) * d, zpabs * tj )
       q = log( (r(j) + tj) / ( r(i) + ti ) )
       g = d * q - zpabs * omega 
       dtmp2 = dtmp2 + g
    enddo
    
!    if(tid == 1) print *, "dtmp2", dtmp2
    dtmp2 = abs(dtmp2) / (4d0 * PI * EPSILON_0)       
    !dtmp2 = abs(dtmp2) * INV_4_PI_EPSILON_0
!    if(tid == 1) print *, "dtmp2", dtmp2
    
    if(lp61==3) dtmp2=dtmp2*ao(ill)*ao(itt)
!    za(tid) = dtmp2

    if(ndl_or_ndt == 0) then
       do i = 1, k-1, 1
          dtmp2 = dtmp2-zab(loci+b_prefix(ip,i)-1+b_strk(i)-1)*zaa(pib+a_prefix(ip,i)-1+a_strk(i)-1)
       enddo
       if(msk(mskid) == 1) then
          dtmp2 = 0.0d0
       end if
       zab(tid+b_strk(k)-1) = dtmp2
    else
       do i = 1, k-1, 1
          dtmp2 = dtmp2-zaa(loci+a_prefix(ip,i)-1+a_strk(i)-1)*zab(pib+b_prefix(ip,i)-1+b_strk(i)-1)
       enddo
       if(msk(mskid) == 1) then
          dtmp2 = 0.0d0
       end if
       zaa(tid+a_strk(k)-1) = dtmp2
    endif


  end subroutine calc_vec2


  attributes(global) subroutine calc_vec_dense                                                         &
    (a3,leafid,idx3,ndl,ndt,nstrtl,nstrtt,ndl_prefix,ndt_prefix,xsyszs,xyz,ao,lp61,len,n_low,n_dense,lxyz)

    real*8,   dimension(len),intent(out)             :: a3
    integer*4,dimension(len),intent(in)              :: leafid
    integer*4,dimension(n_low+n_dense),intent(in)    :: idx3
    integer*4,dimension(n_low+n_dense),intent(in)    :: ndl,ndt
    integer*4,dimension(n_low+n_dense),intent(in)    :: nstrtl,nstrtt
    integer*4,dimension(n_low+n_dense),intent(in)    :: ndl_prefix,ndt_prefix
    real*8,   dimension(lxyz,9),intent(in)           :: xsyszs
    real*8,   dimension(lxyz,3),intent(in)           :: xyz
    real*8,   dimension(lxyz), intent(in)            :: ao
    integer*4,                 intent(in)    ,value  :: lp61,len,n_low,n_dense,lxyz
    
    integer*4 :: ld,strl,strt,ip,loci,ill,itt,ndlt
    real*8    :: xs(3),ys(3),zs(3),x,y,z
    integer*4 :: tid,tpre,rpre,mskid
    real*8    :: dtmp, dtmp2

    real*8 :: r(3)
    real*8 :: xi, xj, yi, dx, dy, t, l, m, d, ti, tj
    real*8 :: theta, omega, q, g, zp, zpabs
    
    integer :: i, j
    real*8 :: u(3), v(3), w(3) 
    real*8 :: ox, oy, oz 

    tid = blockDim%x * (blockIdx%x - 1) + threadIdx%x
    if(tid > len) return

    ip   =leafid(tid)    
    strl =nstrtl(ip)
    strt =nstrtt(ip)
    loci =tid-(idx3(ip)-idx3(n_low+1)) 
    ndlt =ndt(ip)
    ill  =(loci-1)/ndlt+1+strl-1
    itt  =mod(loci-1,ndlt)+1+strt-1
   
    x = xyz(ill,1)
    y = xyz(ill,2)
    z = xyz(ill,3)
    
    xs(1:3) = xsyszs(itt, 1:3)
    ys(1:3) = xsyszs(itt, 4:6)
    zs(1:3) = xsyszs(itt, 7:9)

!     if(blockIdx%x == 1) then
! !       print *, tid, ip, strl, strt
! !       print *, tid, loci, ndlt, ill, itt
!        print *, tid, x, y, z
!     end if
#if 1

    r(:) = sqrt( (xs(:) - x)**2 + (ys(:) - y)**2 + (zs(:) - z)**2 )
    
    u(1) = xs(2) - xs(1);  v(1) = xs(3) - xs(2)
    u(2) = ys(2) - ys(1);  v(2) = ys(3) - ys(2)
    u(3) = zs(2) - zs(1);  v(3) = zs(3) - zs(2)

    !    call cross_product_g(u, v, w)
    w(1) = u(2) * v(3) - u(3) * v(2)
    w(2) = u(3) * v(1) - u(1) * v(3)
    w(3) = u(1) * v(2) - u(2) * v(1)

    dtmp = 1 / sqrt( dot_product(w, w) )
    w(:) = w(:) * dtmp 
!    if(tid == 1) print *, "w", w(1), w(2), w(3)
    u(1) = x - xs(1);  u(2) = y - ys(1);  u(3) = z - zs(1)
    zp = dot_product(u, w)
    ox = x - zp * w(1);  oy = y - zp * w(2);  oz = z - zp * w(3)
    zpabs = abs(zp)

    dtmp2 = 0d0
    do i = 1, 3
       j = mod(i, 3) + 1
       u(1) = xs(j) - ox;  u(2) = ys(j) - oy; u(3) = zs(j) - oz;
       xj = sqrt( dot_product(u, u) )
       dtmp = 1 / xj
       u(:) = u(:) * dtmp
!       call cross_product_g(w, u, v) 
       v(1) = w(2) * u(3) - w(3) * u(2)
       v(2) = w(3) * u(1) - w(1) * u(3)
       v(3) = w(1) * u(2) - w(2) * u(1)
       xi = (xs(i) - ox) * u(1) + (ys(i) - oy) * u(2) + (zs(i) - oz) * u(3)
       yi = (xs(i) - ox) * v(1) + (ys(i) - oy) * v(2) + (zs(i) - oz) * v(3)
       
       dx = xj - xi;  dy = - yi ! (yj = 0)
       t = 1/sqrt( dx**2 + dy**2 )
       l = dx*t;  m = dy*t
       d = l * yi - m * xi
       ti = l * xi + m * yi;  tj = l * xj ! (yj = 0)
       
       !            theta = sign(1d0, yi) * acos( xi / sqrt( xi**2 + yi**2 ) ) ! (xj > 0, yj = 0)
       theta = atan2(yi, xi)
       omega = theta - atan2( r(i) * d, zpabs * ti ) + atan2( r(j) * d, zpabs * tj )
       q = log( (r(j) + tj) / ( r(i) + ti ) )
       g = d * q - zpabs * omega 
       dtmp2 = dtmp2 + g
    enddo
    
    dtmp2 = abs(dtmp2) / (4d0 * PI * EPSILON_0)       
    if(lp61==3) dtmp2=dtmp2*ao(ill)*ao(itt)
    a3(tid) = dtmp2
#endif

  end subroutine calc_vec_dense


  attributes(global) subroutine calc_vec_dense_2D                                                         &
    (a3,leafid,idx3,ndl,ndt,nstrtl,nstrtt,ndl_prefix,ndt_prefix,xsyszs,xyz,ao,lp61,len,n_low,n_dense,lxyz,ndt_max)

    real*8,   dimension(len),intent(out)             :: a3
    integer*4,dimension(len),intent(in)              :: leafid
    integer*4,dimension(n_dense*ndt_max+1),intent(in):: idx3
    integer*4,dimension(n_low+n_dense),intent(in)    :: ndl,ndt
    integer*4,dimension(n_low+n_dense),intent(in)    :: nstrtl,nstrtt
    integer*4,dimension(n_low+n_dense),intent(in)    :: ndl_prefix,ndt_prefix
    real*8,   dimension(lxyz,9),intent(in)           :: xsyszs
    real*8,   dimension(lxyz,3),intent(in)           :: xyz
    real*8,   dimension(lxyz), intent(in)            :: ao
    integer*4,                 intent(in)    ,value  :: lp61,len,n_low,n_dense,lxyz,ndt_max
    
    integer*4 :: ld,strl,strt,ip,loci,ill,itt,ndlt,lid
    real*8    :: xs(3),ys(3),zs(3),x,y,z
    integer*4 :: tid,tpre,rpre,mskid
    real*8    :: dtmp, dtmp2

    real*8 :: r(3)
    real*8 :: xi, xj, yi, dx, dy, t, l, m, d, ti, tj
    real*8 :: theta, omega, q, g, zp, zpabs
    
    integer :: i, j
    real*8 :: u(3), v(3), w(3) 
    real*8 :: ox, oy, oz 

    tid = blockDim%x * (blockIdx%x - 1) + threadIdx%x
    if(tid > len) return

    lid  =leafid(tid)
    ip   =mod(lid-1,n_dense)+1+n_low
    strl =nstrtl(ip)
    strt =nstrtt(ip)
    loci =tid-idx3(lid)+1
    ill  =loci+strl-1
    itt  =(lid-1)/n_dense+1+strt-1
   
    x = xyz(ill,1)
    y = xyz(ill,2)
    z = xyz(ill,3)
    
    xs(1:3) = xsyszs(itt, 1:3)
    ys(1:3) = xsyszs(itt, 4:6)
    zs(1:3) = xsyszs(itt, 7:9)

!     if(blockIdx%x == 1) then
! !       print *, tid, ip, strl, strt
! !       print *, tid, loci, ndlt, ill, itt
!        print *, tid, x, y, z
!     end if
#if 1

    r(:) = sqrt( (xs(:) - x)**2 + (ys(:) - y)**2 + (zs(:) - z)**2 )
    
    u(1) = xs(2) - xs(1);  v(1) = xs(3) - xs(2)
    u(2) = ys(2) - ys(1);  v(2) = ys(3) - ys(2)
    u(3) = zs(2) - zs(1);  v(3) = zs(3) - zs(2)

    !    call cross_product_g(u, v, w)
    w(1) = u(2) * v(3) - u(3) * v(2)
    w(2) = u(3) * v(1) - u(1) * v(3)
    w(3) = u(1) * v(2) - u(2) * v(1)

    dtmp = 1 / sqrt( dot_product(w, w) )
    w(:) = w(:) * dtmp 
!    if(tid == 1) print *, "w", w(1), w(2), w(3)
    u(1) = x - xs(1);  u(2) = y - ys(1);  u(3) = z - zs(1)
    zp = dot_product(u, w)
    ox = x - zp * w(1);  oy = y - zp * w(2);  oz = z - zp * w(3)
    zpabs = abs(zp)

    dtmp2 = 0d0
    do i = 1, 3
       j = mod(i, 3) + 1
       u(1) = xs(j) - ox;  u(2) = ys(j) - oy; u(3) = zs(j) - oz;
       xj = sqrt( dot_product(u, u) )
       dtmp = 1 / xj
       u(:) = u(:) * dtmp
!       call cross_product_g(w, u, v) 
       v(1) = w(2) * u(3) - w(3) * u(2)
       v(2) = w(3) * u(1) - w(1) * u(3)
       v(3) = w(1) * u(2) - w(2) * u(1)
       xi = (xs(i) - ox) * u(1) + (ys(i) - oy) * u(2) + (zs(i) - oz) * u(3)
       yi = (xs(i) - ox) * v(1) + (ys(i) - oy) * v(2) + (zs(i) - oz) * v(3)
       
       dx = xj - xi;  dy = - yi ! (yj = 0)
       t = 1/sqrt( dx**2 + dy**2 )
       l = dx*t;  m = dy*t
       d = l * yi - m * xi
       ti = l * xi + m * yi;  tj = l * xj ! (yj = 0)
       
       !            theta = sign(1d0, yi) * acos( xi / sqrt( xi**2 + yi**2 ) ) ! (xj > 0, yj = 0)
       theta = atan2(yi, xi)
       omega = theta - atan2( r(i) * d, zpabs * ti ) + atan2( r(j) * d, zpabs * tj )
       q = log( (r(j) + tj) / ( r(i) + ti ) )
       g = d * q - zpabs * omega 
       dtmp2 = dtmp2 + g
    enddo
    
    dtmp2 = abs(dtmp2) / (4d0 * PI * EPSILON_0)       
    if(lp61==3) dtmp2=dtmp2*ao(ill)*ao(itt)
    a3(tid) = dtmp2
#endif

  end subroutine calc_vec_dense_2D


  attributes(global) subroutine calc_mat                                                         &
    (a3,leafid,idx3,idx3_2D,ndl,ndt,nstrtl,nstrtt,ndl_prefix,ndt_prefix,xsyszs,xyz,ao,lp61,len,n_low,n_dense,lxyz,ndt_max)

    real*8,   dimension(len),intent(out)             :: a3
    integer*4,dimension(len),intent(in)              :: leafid
    integer*4,dimension(n_low+n_dense+1),intent(in)  :: idx3
    integer*4,dimension(n_dense*ndt_max+1),intent(in):: idx3_2D
    integer*4,dimension(n_low+n_dense),intent(in)    :: ndl,ndt
    integer*4,dimension(n_low+n_dense),intent(in)    :: nstrtl,nstrtt
    integer*4,dimension(n_low+n_dense),intent(in)    :: ndl_prefix,ndt_prefix
    real*8,   dimension(lxyz,9),intent(in)           :: xsyszs
    real*8,   dimension(lxyz,3),intent(in)           :: xyz
    real*8,   dimension(lxyz), intent(in)            :: ao
    integer*4,                 intent(in)    ,value  :: lp61,len,n_low,n_dense,lxyz,ndt_max
    
    integer*4 :: ld,strl,strt,ip,loci,ill,itt,ndlt,lid,loct,locl
    real*8    :: xs(3),ys(3),zs(3),x,y,z
    integer*4 :: tid,tpre,rpre,mskid
    real*8    :: dtmp, dtmp2

    real*8 :: r(3)
    real*8 :: xi, xj, yi, dx, dy, t, l, m, d, ti, tj
    real*8 :: theta, omega, q, g, zp, zpabs
    
    integer :: i, j
    real*8 :: u(3), v(3), w(3) 
    real*8 :: ox, oy, oz 


    tid = blockDim%x * (blockIdx%x - 1) + threadIdx%x
    if(tid > len) return

    ip   =leafid(tid)    
    strl =nstrtl(ip)
    strt =nstrtt(ip)
    loci =tid-(idx3(ip)-idx3(n_low+1)) 
    ndlt =ndl(ip)
    locl =mod(loci-1,ndlt)+1
    loct =(loci-1)/ndlt+1
    ill  =locl+strl-1
    itt  =loct+strt-1
   
    x = xyz(ill,1)
    y = xyz(ill,2)
    z = xyz(ill,3)

    xs(1:3) = xsyszs(itt, 1:3)
    ys(1:3) = xsyszs(itt, 4:6)
    zs(1:3) = xsyszs(itt, 7:9)

!     if(blockIdx%x == 1) then
! !       print *, tid, ip, strl, strt
! !       print *, tid, loci, ndlt, ill, itt
!        print *, tid, x, y, z
!     end if
#if 1

    r(:) = sqrt( (xs(:) - x)**2 + (ys(:) - y)**2 + (zs(:) - z)**2 )
    
    u(1) = xs(2) - xs(1);  v(1) = xs(3) - xs(2)
    u(2) = ys(2) - ys(1);  v(2) = ys(3) - ys(2)
    u(3) = zs(2) - zs(1);  v(3) = zs(3) - zs(2)

    !    call cross_product_g(u, v, w)
    w(1) = u(2) * v(3) - u(3) * v(2)
    w(2) = u(3) * v(1) - u(1) * v(3)
    w(3) = u(1) * v(2) - u(2) * v(1)

    dtmp = 1 / sqrt( dot_product(w, w) )
    w(:) = w(:) * dtmp 
!    if(tid == 1) print *, "w", w(1), w(2), w(3)
    u(1) = x - xs(1);  u(2) = y - ys(1);  u(3) = z - zs(1)
    zp = dot_product(u, w)
    ox = x - zp * w(1);  oy = y - zp * w(2);  oz = z - zp * w(3)
    zpabs = abs(zp)

    dtmp2 = 0d0
    do i = 1, 3
       j = mod(i, 3) + 1
       u(1) = xs(j) - ox;  u(2) = ys(j) - oy; u(3) = zs(j) - oz;
       xj = sqrt( dot_product(u, u) )
       dtmp = 1 / xj
       u(:) = u(:) * dtmp
!       call cross_product_g(w, u, v) 
       v(1) = w(2) * u(3) - w(3) * u(2)
       v(2) = w(3) * u(1) - w(1) * u(3)
       v(3) = w(1) * u(2) - w(2) * u(1)
       xi = (xs(i) - ox) * u(1) + (ys(i) - oy) * u(2) + (zs(i) - oz) * u(3)
       yi = (xs(i) - ox) * v(1) + (ys(i) - oy) * v(2) + (zs(i) - oz) * v(3)
       
       dx = xj - xi;  dy = - yi ! (yj = 0)
       t = 1/sqrt( dx**2 + dy**2 )
       l = dx*t;  m = dy*t
       d = l * yi - m * xi
       ti = l * xi + m * yi;  tj = l * xj ! (yj = 0)
       
       !            theta = sign(1d0, yi) * acos( xi / sqrt( xi**2 + yi**2 ) ) ! (xj > 0, yj = 0)
       theta = atan2(yi, xi)
       omega = theta - atan2( r(i) * d, zpabs * ti ) + atan2( r(j) * d, zpabs * tj )
       q = log( (r(j) + tj) / ( r(i) + ti ) )
       g = d * q - zpabs * omega 
       dtmp2 = dtmp2 + g
    enddo
    
    dtmp2 = abs(dtmp2) / (4d0 * PI * EPSILON_0)       
    if(lp61==3) dtmp2=dtmp2*ao(ill)*ao(itt)
    a3(locl+idx3_2D(ip-n_low+(loct-1)*n_dense)-1) = dtmp2
!    a3(tid) = dtmp2
#endif

  end subroutine calc_mat

#undef INV_4_PI_EPSILON_0
#undef PI
#undef EPSILON_0

  attributes(global) subroutine za_update                                                               &
       (zabk,zabm,zaa,b_prefixk,b_prefixm,a_prefix,subid,leafpib,len,k)
!       (work,leafid,leafpib,lcol_msk,true_prefix,len,k)

!    type(workarray), dimension(:), intent(inout)     :: work
    real*8   ,dimension(:),    intent(inout)         :: zabk
    real*8   ,dimension(:),    intent(in)            :: zaa,zabm
    integer*4,dimension(:),    intent(in)            :: a_prefix,b_prefixk,b_prefixm
    integer*4,dimension(:),    intent(in)            :: subid,leafpib
    integer*4,                 intent(in)    ,value  :: len,k
    
    integer*4 :: tid,ip,pib,il,lid,ridb,rida
    tid = blockDim%x * (blockIdx%x - 1) + threadIdx%x
    if(tid > len) return
    ip  = subid(tid)    
    pib = leafpib(ip)
!    lid = tid-work(k)%b_prefix(ip)+1
    lid = tid-b_prefixk(ip)+1
    ! ridb = lid + work(il)%b_prefix(ip) -1
    ! rida = pib + work(il)%a_prefix(ip) -1
    ! work(k)%zab(tid) = work(k)%zab(tid)-work(k)%zab(rida)*work(k)%zaa(rida)
    ridb = lid + b_prefixm(ip) -1
    rida = pib + a_prefix(ip) -1
    zabk(tid) = zabk(tid)-zabm(ridb)*zaa(rida)

  end subroutine za_update

  attributes(global) subroutine za_msk                                                   &
       (zab,b_prefix,leafid,lcol_msk,true_prefix,len)
    real*8   ,dimension(:),    intent(out)           :: zab
    integer*4,dimension(:),    intent(in)            :: b_prefix
    integer*4,dimension(:),    intent(in)            :: leafid
!    integer*1,dimension(:),    intent(in)            :: lcol_msk 
    integer*4,dimension(:),    intent(in)            :: lcol_msk 
    integer*4,dimension(:),    intent(in)            :: true_prefix
    integer*4,                 intent(in)    ,value  :: len
    
    integer*4 :: tid, ip, lid, gid
    tid = blockDim%x * (blockIdx%x - 1) + threadIdx%x
    if(tid > len) return
    ip  = leafid(tid)    
    lid = tid-b_prefix(ip)+1
    gid = true_prefix(ip) + lid -1
    if(lcol_msk(gid) == 1) then
       zab(tid) = 0.0d0
    end if

  end subroutine za_msk

  attributes(global) subroutine maxabsval(za,reduced_prefix,strk,maxvals,leafist,leafjst,isnt_finished,ndt_prefix,ndl_prefix,lcol_msk,lrow_msk,nd,ndl_or_ndt,k,lza,n_low,l_mskc,l_mskr)
!  attributes(global) subroutine maxabsval(za,reduced_prefix,maxvals,leafist,leafjst,isnt_finished,ndt_prefix,ndl_prefix,lcol_msk,lrow_msk,nd,ndl_or_ndt)
!  attributes(global) subroutine maxabsval(work,maxvals,leafpib,za,isnt_finished,true_prefix,msk,nd,ndl_or_ndt)
!    type(workarray),           intent(inout)         :: work
    real*8   ,dimension(lza),  intent(inout)         :: za
    integer*4,dimension(n_low+1),intent(in)          :: reduced_prefix
    integer*4,dimension(k),    intent(in)            :: strk
    real*8   ,dimension(n_low),intent(out)           :: maxvals
    integer*4,dimension(n_low),intent(inout)         :: leafist,leafjst
    integer*4,dimension(n_low),intent(in)            :: isnt_finished
    integer*4,dimension(n_low),intent(in)            :: ndt_prefix,ndl_prefix
!    integer*1,dimension(:),    intent(in)            :: msk
    integer*4,dimension(l_mskc),intent(inout)        :: lcol_msk
    integer*4,dimension(l_mskr),intent(inout)        :: lrow_msk
    integer*4,dimension(n_low),intent(in)            :: nd
    integer*4,                 intent(in)    ,value  :: ndl_or_ndt,k,lza,n_low,l_mskc,l_mskr

    integer*4 :: ip,tx,ndlt,tpre,rpre,dimx,it,i,ii
    integer*4 :: ijst, pib
    real*8    :: maxvalue
    real*8           :: dtmp
    integer*4        :: itmp
    real*8,shared    :: dshared(8)
    integer*4,shared :: ishared(8)

    ip = blockIdx%x
    tx = threadIdx%x
    dimx = blockDim%x

    if(isnt_finished(ip)==0) return

    ! if(ndl_or_ndt == 0) then
    !    za => work%zab
    !    reduced_prefix => work%b_prefix
    ! else
    !    za => work%zaa
    !    reduced_prefix => work%a_prefix
    ! endif

    ndlt   =nd(ip)
    rpre   =reduced_prefix(ip)+strk(k)-1

    ijst = 0; maxvalue = 0.0d0
    
    if(ndl_or_ndt == 0) then
       tpre=ndt_prefix(ip)
       do it=tx,ndlt,dimx
          if(lcol_msk(tpre+it-1)==0) then
             dtmp = dabs(za(rpre+it-1))
             if(dtmp > maxvalue)then
                ijst = it;
                maxvalue = dtmp
             endif
          endif
       enddo
    else
       tpre=ndl_prefix(ip)
       pib = leafist(ip)
       lrow_msk(tpre+pib-1)=1
       do it=tx,ndlt,dimx
          if(lrow_msk(tpre+it-1)==0 .and. (it .ne. pib)) then
             dtmp = dabs(za(rpre+it-1))
             if(dtmp > maxvalue)then
                ijst = it;
                maxvalue = dtmp
             endif
          endif
       enddo
    end if
    dtmp = __shfl_xor(maxvalue,16)
    itmp = __shfl_xor(ijst,16)
    if(dtmp > maxvalue) then
       maxvalue = dtmp
       ijst     = itmp
    endif
    dtmp = __shfl_xor(maxvalue,8)
    itmp = __shfl_xor(ijst,8)
    if(dtmp > maxvalue) then
       maxvalue = dtmp
       ijst     = itmp
    endif
    dtmp = __shfl_xor(maxvalue,4)
    itmp = __shfl_xor(ijst,4)
    if(dtmp > maxvalue) then
       maxvalue = dtmp
       ijst     = itmp
    endif
    dtmp = __shfl_xor(maxvalue,2)
    itmp = __shfl_xor(ijst,2)
    if(dtmp > maxvalue) then
       maxvalue = dtmp
       ijst     = itmp
    endif
    dtmp = __shfl_xor(maxvalue,1)
    itmp = __shfl_xor(ijst,1)
    if(dtmp > maxvalue) then
       maxvalue = dtmp
       ijst     = itmp
    endif
    call syncthreads()
    if(mod(tx,32) == 1) then
       dshared(tx/32+1) = maxvalue
       ishared(tx/32+1) = ijst
    endif
    call syncthreads()
    do i = 1, dimx/32
       if(dshared(i) > maxvalue) then
          maxvalue = dshared(i)
          ijst     = ishared(i)
       endif
    enddo

    if(ndl_or_ndt == 0) then
       dtmp=1.0d0/za(rpre+ijst-1)
!       dtmp=1.0d0/maxvalue
       call syncthreads()
       do ii=tx,ndlt,dimx
          za(rpre+ii-1)=za(rpre+ii-1)*dtmp
       enddo
       if(tx == 1) then
          maxvals(ip) = maxvalue
          leafjst(ip) = ijst
          !       print *, "pib", ijst
       endif
    else
       if(tx == 1) then
          maxvals(ip) = maxvalue
          leafist(ip) = ijst
          pib         = leafjst(ip)
          tpre        = ndt_prefix(ip)
          lcol_msk(tpre+pib-1)=1
       endif
    endif

  end subroutine maxabsval

  attributes(global) subroutine maxabsval2(za,reduced_prefix,strk,maxvals,leafist,leafjst,notConvergedBlocks,ndt_prefix,ndl_prefix,lcol_msk,lrow_msk,nd,ndl_or_ndt,k,lza,n_low,l_mskc,l_mskr,lenb)
    real*8   ,dimension(lza),  intent(inout)         :: za
    integer*4,dimension(n_low+1),intent(in)          :: reduced_prefix
    integer*4,dimension(k),    intent(in)            :: strk
    real*8   ,dimension(n_low),intent(out)           :: maxvals
    integer*4,dimension(n_low),intent(inout)         :: leafist,leafjst
    integer*4,dimension(n_low),intent(in)            :: notConvergedBlocks
!    integer*4,dimension(n_low),intent(in)            :: isnt_finished
    integer*4,dimension(n_low),intent(in)            :: ndt_prefix,ndl_prefix
!    integer*1,dimension(:),    intent(in)            :: msk
    integer*4,dimension(l_mskc),intent(inout)        :: lcol_msk
    integer*4,dimension(l_mskr),intent(inout)        :: lrow_msk
    integer*4,dimension(n_low),intent(in)            :: nd
    integer*4,                 intent(in)    ,value  :: ndl_or_ndt,k,lza,n_low,l_mskc,l_mskr,lenb

    integer*4 :: ip,tx,ndlt,tpre,rpre,dimx,it,i,ii
    integer*4 :: ijst, pib
    real*8    :: maxvalue
    real*8           :: dtmp
    integer*4        :: itmp
    real*8,shared    :: dshared(8)
    integer*4,shared :: ishared(8)

    ip = notConvergedBlocks(blockIdx%x)
    tx = threadIdx%x
    dimx = blockDim%x

!    if(isnt_finished(ip)==0) return

    ! if(ndl_or_ndt == 0) then
    !    za => work%zab
    !    reduced_prefix => work%b_prefix
    ! else
    !    za => work%zaa
    !    reduced_prefix => work%a_prefix
    ! endif

    ndlt   =nd(ip)
    rpre   =reduced_prefix(ip)+strk(k)-1

    ijst = 0; maxvalue = 0.0d0
    
    if(ndl_or_ndt == 0) then
       tpre=ndt_prefix(ip)
       do it=tx,ndlt,dimx
          if(lcol_msk(tpre+it-1)==0) then
             dtmp = dabs(za(rpre+it-1))
             if(dtmp > maxvalue)then
                ijst = it;
                maxvalue = dtmp
             endif
          endif
       enddo
    else
       tpre=ndl_prefix(ip)
       pib = leafist(ip)
       lrow_msk(tpre+pib-1)=1
       do it=tx,ndlt,dimx
          if(lrow_msk(tpre+it-1)==0 .and. (it .ne. pib)) then
             dtmp = dabs(za(rpre+it-1))
             if(dtmp > maxvalue)then
                ijst = it;
                maxvalue = dtmp
             endif
          endif
       enddo
    end if
    dtmp = __shfl_xor(maxvalue,16)
    itmp = __shfl_xor(ijst,16)
    if(dtmp > maxvalue) then
       maxvalue = dtmp
       ijst     = itmp
    endif
    dtmp = __shfl_xor(maxvalue,8)
    itmp = __shfl_xor(ijst,8)
    if(dtmp > maxvalue) then
       maxvalue = dtmp
       ijst     = itmp
    endif
    dtmp = __shfl_xor(maxvalue,4)
    itmp = __shfl_xor(ijst,4)
    if(dtmp > maxvalue) then
       maxvalue = dtmp
       ijst     = itmp
    endif
    dtmp = __shfl_xor(maxvalue,2)
    itmp = __shfl_xor(ijst,2)
    if(dtmp > maxvalue) then
       maxvalue = dtmp
       ijst     = itmp
    endif
    dtmp = __shfl_xor(maxvalue,1)
    itmp = __shfl_xor(ijst,1)
    if(dtmp > maxvalue) then
       maxvalue = dtmp
       ijst     = itmp
    endif
    call syncthreads()
    if(mod(tx,32) == 1) then
       dshared(tx/32+1) = maxvalue
       ishared(tx/32+1) = ijst
    endif
    call syncthreads()
    do i = 1, dimx/32
       if(dshared(i) > maxvalue) then
          maxvalue = dshared(i)
          ijst     = ishared(i)
       endif
    enddo

    if(ndl_or_ndt == 0) then
       dtmp=1.0d0/za(rpre+ijst-1)
!       dtmp=1.0d0/maxvalue
       call syncthreads()
       do ii=tx,ndlt,dimx
          za(rpre+ii-1)=za(rpre+ii-1)*dtmp
       enddo
       if(tx == 1) then
          maxvals(ip) = maxvalue
          leafjst(ip) = ijst
          !       print *, "pib", ijst
       endif
    else
       if(tx == 1) then
          maxvals(ip) = maxvalue
          leafist(ip) = ijst
          pib         = leafjst(ip)
          tpre        = ndt_prefix(ip)
          lcol_msk(tpre+pib-1)=1
       endif
    endif

  end subroutine maxabsval2

  attributes(global) subroutine unrm(znrms,isnt_finished,ktp,zaa,zab,a_prefix,b_prefix,a_strk,b_strk,ndlp,ndtp,flag,kt,eps,kstop,lza,n_low)
!  attributes(global) subroutine unrm(znrms,isnt_finished,ktp,zaa,zab,a_prefix,b_prefix,ndlp,ndtp,flag,kt,eps,kstop)
    real*8   ,dimension(n_low),intent(inout)         :: znrms
    integer*4,dimension(n_low),intent(inout)         :: isnt_finished
    integer*4,dimension(n_low),intent(out)           :: ktp
    real*8   ,dimension(lza),  intent(in)            :: zaa,zab
    integer*4,dimension(n_low+1),intent(in)          :: a_prefix,b_prefix
    integer*4,dimension(kt),   intent(in)            :: a_strk,b_strk
    integer*4,dimension(n_low),intent(in)            :: ndlp,ndtp
    logical  ,                 intent(in)    ,value  :: flag
    integer*4,                 intent(in)    ,value  :: kt,n_low,lza
    real*8   ,                 intent(in)    ,value  :: eps
    integer*4,dimension(:),    intent(in)            :: kstop

    integer*4 :: ip,tx,pre,dimx,il,i
    integer*4 :: ndl,ndt
    real*8    :: zzz,zeps,znrm,zza
    real*8           :: dtmp
    integer*4        :: itmp
    real*8,shared    :: dshared(8)
    integer*4,shared :: ishared(8)

    ip = blockIdx%x
    tx = threadIdx%x
    dimx = blockDim%x

    if(isnt_finished(ip)==0) return

    ndl   =ndlp(ip)
    pre   =a_prefix(ip)+a_strk(kt)-1

    zzz=0.0d0
    do il=tx,ndl,dimx
       zza = zaa(pre+il-1)
       zzz = zzz + zza*zza
    enddo
    zzz = zzz + __shfl_xor(zzz,16)
    zzz = zzz + __shfl_xor(zzz,8)
    zzz = zzz + __shfl_xor(zzz,4)
    zzz = zzz + __shfl_xor(zzz,2)
    zzz = zzz + __shfl_xor(zzz,1)
    call syncthreads()
    if(mod(tx,32) == 1) then
       dshared(tx/32+1) = zzz
    endif
    call syncthreads()
    zzz = 0.0d0
    do i = 1, dimx/32
       zzz = zzz + dshared(i)
    enddo
    call syncthreads()
    zeps= dsqrt(zzz)

    ndt   =ndtp(ip)
    pre   =b_prefix(ip)+b_strk(kt)-1
    zzz=0.0d0
    do il=tx,ndt,dimx
       zza = abs(zab(pre+il-1))
       zzz = zzz + zza*zza
    enddo
    zzz = zzz + __shfl_xor(zzz,16)
    zzz = zzz + __shfl_xor(zzz,8)
    zzz = zzz + __shfl_xor(zzz,4)
    zzz = zzz + __shfl_xor(zzz,2)
    zzz = zzz + __shfl_xor(zzz,1)
    call syncthreads()
    if(mod(tx,32) == 1) then
       dshared(tx/32+1) = zzz
    endif
    call syncthreads()
    zzz = 0.0d0
    do i = 1, dimx/32
       zzz = zzz + dshared(i)
    enddo
    call syncthreads()
    zeps= zeps*dsqrt(zzz)

    znrm = znrms(ip)
    if(flag) znrm=zeps
    zeps=zeps/znrm
    if(zeps<eps .or. kstop(ip) == kt) then 
       if(tx == 1) then
          isnt_finished(ip) = 0
          ktp(ip) = kt
       endif
    endif
    if(tx == 1) znrms(ip) = znrm

  end subroutine unrm


  attributes(global) subroutine unrm2(znrms,isnt_finished,notConvergedBlocks,ktp,zaa,zab,a_prefix,b_prefix,a_strk,b_strk,ndlp,ndtp,flag,kt,eps,kstop,lza,n_low,lenb)
!  attributes(global) subroutine unrm(znrms,isnt_finished,ktp,zaa,zab,a_prefix,b_prefix,ndlp,ndtp,flag,kt,eps,kstop)
    real*8   ,dimension(n_low),intent(inout)         :: znrms
    integer*4,dimension(n_low,2),intent(inout)         :: isnt_finished
    integer*4,dimension(n_low),intent(in)            :: notConvergedBlocks
    integer*4,dimension(n_low),intent(out)           :: ktp
    real*8   ,dimension(lza),  intent(in)            :: zaa,zab
    integer*4,dimension(n_low+1),intent(in)          :: a_prefix,b_prefix
    integer*4,dimension(kt),   intent(in)            :: a_strk,b_strk
    integer*4,dimension(n_low),intent(in)            :: ndlp,ndtp
    logical  ,                 intent(in)    ,value  :: flag
    integer*4,                 intent(in)    ,value  :: kt,n_low,lza,lenb
    real*8   ,                 intent(in)    ,value  :: eps
    integer*4,dimension(:),    intent(in)            :: kstop

    integer*4 :: ip,tx,pre,dimx,il,i,bid
    integer*4 :: ndl,ndt
    real*8    :: zzz,zeps,znrm,zza
    real*8           :: dtmp
    integer*4        :: itmp
    real*8,shared    :: dshared(8)
    integer*4,shared :: ishared(8)

    bid = blockIdx%x
    ip = notConvergedBlocks(bid)
    tx = threadIdx%x
    dimx = blockDim%x

!    if(isnt_finished(ip)==0) return

    ndl   =ndlp(ip)
    pre   =a_prefix(ip)+a_strk(kt)-1

    zzz=0.0d0
    do il=tx,ndl,dimx
       zza = zaa(pre+il-1)
       zzz = zzz + zza*zza
    enddo
    zzz = zzz + __shfl_xor(zzz,16)
    zzz = zzz + __shfl_xor(zzz,8)
    zzz = zzz + __shfl_xor(zzz,4)
    zzz = zzz + __shfl_xor(zzz,2)
    zzz = zzz + __shfl_xor(zzz,1)
    call syncthreads()
    if(mod(tx,32) == 1) then
       dshared(tx/32+1) = zzz
    endif
    call syncthreads()
    zzz = 0.0d0
    do i = 1, dimx/32
       zzz = zzz + dshared(i)
    enddo
    call syncthreads()
    zeps= dsqrt(zzz)

    ndt   =ndtp(ip)
    pre   =b_prefix(ip)+b_strk(kt)-1
    zzz=0.0d0
    do il=tx,ndt,dimx
       zza = abs(zab(pre+il-1))
       zzz = zzz + zza*zza
    enddo
    zzz = zzz + __shfl_xor(zzz,16)
    zzz = zzz + __shfl_xor(zzz,8)
    zzz = zzz + __shfl_xor(zzz,4)
    zzz = zzz + __shfl_xor(zzz,2)
    zzz = zzz + __shfl_xor(zzz,1)
    call syncthreads()
    if(mod(tx,32) == 1) then
       dshared(tx/32+1) = zzz
    endif
    call syncthreads()
    zzz = 0.0d0
    do i = 1, dimx/32
       zzz = zzz + dshared(i)
    enddo
    call syncthreads()
    zeps= zeps*dsqrt(zzz)

    znrm = znrms(ip)
    if(flag) znrm=zeps
    zeps=zeps/znrm
    if(zeps<eps .or. kstop(ip) == kt) then 
       if(tx == 1) then
          isnt_finished(bid,1) = 0
          isnt_finished(ip,2) = 0
          ktp(ip) = kt
       endif
    endif
    if(tx == 1) znrms(ip) = znrm

  end subroutine unrm2


  attributes(global) subroutine calc_idx(idxa,idxb,a_prefix_tmp,b_prefix_tmp,ndlp,ndtp,ktp,len)

    integer*4,dimension(:),    intent(out)           :: idxa,idxb
    integer*4,dimension(:,:),  intent(out)           :: a_prefix_tmp,b_prefix_tmp
    integer*4,dimension(:),    intent(in)            :: ndlp,ndtp
    integer*4,dimension(:),    intent(in)            :: ktp
    integer*4                                 ,value :: len

!    integer*4,dimension(:),pointer :: a_prefix,b_prefix
    integer*4 :: tid, i, rid, istat, tmp, dimx, id, sww,swr

    tid = threadIdx%x
    dimx = blockDim%x
    ! a_prefix => work%a_prefix
    ! b_prefix => work%b_prefix

    if(tid == 1) then
       a_prefix_tmp(1,1) = 1
       b_prefix_tmp(1,1) = 1
    endif
    do i = tid+1, len, dimx
       a_prefix_tmp(i,1) = ndlp(i-1)*ktp(i-1)
       b_prefix_tmp(i,1) = ndtp(i-1)*ktp(i-1)
    enddo
    call syncthreads()
    i = 1
    swr = 1; sww = 2
    do while(i < len)
       call syncthreads()
       do id = tid, len, dimx
          rid = id - i
          if(rid < 1) then
             a_prefix_tmp(id,sww) = a_prefix_tmp(id,swr)
             b_prefix_tmp(id,sww) = b_prefix_tmp(id,swr)
          else
             a_prefix_tmp(id,sww) = a_prefix_tmp(id,swr) + a_prefix_tmp(rid,swr)
             b_prefix_tmp(id,sww) = b_prefix_tmp(id,swr) + b_prefix_tmp(rid,swr)
          endif
       enddo
       call syncthreads()
       i = i * 2
       tmp = swr
       swr = sww
       sww = tmp
    end do
    do id = tid, len, dimx
       idxa(id) = a_prefix_tmp(id,swr)
       idxb(id) = b_prefix_tmp(id,swr)
    enddo
  end subroutine calc_idx


  attributes(global) subroutine create_a1_a2(a1,a2,idxp1,idxp2,zab,zaa,b_prefix,a_prefix,b_strk,a_strk,len,n_low,kmax)
!  attributes(global) subroutine create_a1_a2(a1,a2,idxp1,idxp2,zab,zaa,b_prefix,a_prefix,k)
    real*8   ,dimension(len),    intent(out)           :: a1, a2
    integer*4,dimension(n_low),  intent(in)            :: idxp1,idxp2
    real*8   ,dimension(len),    intent(in)            :: zab,zaa
    integer*4,dimension(n_low+1,kmax+1),intent(in)     :: b_prefix,a_prefix
    integer*4,dimension(kmax+1), intent(in)            :: b_strk,a_strk
    integer*4                                ,value    :: len,n_low,kmax

    integer*4 :: ip,tx,ndt,ndl,a1st,a2st,i,apre,bpre,dimx,j

    ip = blockIdx%x
    tx = threadIdx%x
    dimx = blockDim%x

    do j = 1, kmax
       bpre = b_prefix(ip,j)+b_strk(j)-1
       apre = a_prefix(ip,j)+a_strk(j)-1
       ndt = b_prefix(ip+1,j)-b_prefix(ip,j)
       ndl = a_prefix(ip+1,j)-a_prefix(ip,j)
       
       a1st = idxp1(ip) + ndt * (j-1)
       a2st = idxp2(ip) + ndl * (j-1)
       do i = tx,ndt,dimx
          a1(a1st+i-1) = zab(bpre+i-1)
!          zab(a1st+i-1) = zab(bpre+i-1)
       enddo
       do i = tx,ndl,dimx
          a2(a2st+i-1) = zaa(apre+i-1)
!          zaa(a2st+i-1) = zaa(apre+i-1)
       enddo
    enddo

  end subroutine create_a1_a2


  attributes(global) subroutine create_a1_a2_opt(a1,a2,idxp1,idxp2,zab,zaa,b_prefix,a_prefix,b_strk,a_strk,len,n_low,kmax)
!  attributes(global) subroutine create_a1_a2(a1,a2,idxp1,idxp2,zab,zaa,b_prefix,a_prefix,k)
    real*8   ,dimension(len),  intent(out)           :: a1, a2
    integer*4,dimension(n_low),intent(in)            :: idxp1,idxp2
    real*8   ,dimension(len),  intent(in)            :: zab,zaa
    integer*4,dimension(n_low+1,kmax+1),intent(in)   :: b_prefix,a_prefix
    integer*4,dimension(kmax+1),intent(in)           :: b_strk,a_strk
    integer*4                              ,value    :: len,n_low,kmax

    integer*4 :: tid,ndt,ndl,a1st,a2st,i,apre,bpre,dimx,locid
    integer*4 :: kstrt,kcenter,kend,k
    integer*4 :: ipstrt,ipcenter,ipend,ip

    tid = blockDim%x * (blockIdx%x - 1) + threadIdx%x
    if(tid > len) return
    kstrt = 1
    kend = kmax+1
    do while (kend - kstrt .ne. 1)
       kcenter = (kend + kstrt)/2
       if(tid >= a_strk(kcenter)) then
          kstrt = kcenter
       else
          kend = kcenter
       end if
    end do
    k = kstrt
    apre = a_strk(k)-1

    ipstrt = 1
    ipend = n_low+1
    do while (ipend - ipstrt .ne. 1)
       ipcenter = (ipend + ipstrt)/2
       if(tid >= apre+a_prefix(ipcenter,k)) then
          ipstrt = ipcenter
       else
          ipend = ipcenter
       end if
    end do
    ip = ipstrt
    
    ! if(blockIdx%x == 1) then
    !    print *, tid, k, kstrt, kmax, kcenter !, apre, ip, ipstrt, ipcenter, ipend
    ! end if
    ! if(tid == 8) then
    !    print *, kstrt, kcenter, kend, apre
    !    print *, ipstrt, ipcenter, ipend, apre + a_prefix(ip,k)
    ! end if

    apre = apre + a_prefix(ip,k)
    ndl = a_prefix(ip+1,k)-a_prefix(ip,k)
    a2st = idxp2(ip) + ndl * (k-1)
    locid = tid - apre + 1
    a2(a2st+locid-1) = zaa(tid)

    kstrt = 1
    kend = kmax+1
    do while (kend - kstrt .ne. 1)
       kcenter = (kend + kstrt)/2
       if(tid >= b_strk(kcenter)) then
          kstrt = kcenter
       else
          kend = kcenter
       end if
    end do
    k = kstrt
    bpre = b_strk(k)-1

    ipstrt = 1
    ipend = n_low+1
    do while (ipend - ipstrt .ne. 1)
       ipcenter = (ipend + ipstrt)/2
       if(tid >= bpre+b_prefix(ipcenter,k)) then
          ipstrt = ipcenter
       else
          ipend = ipcenter
       end if
    end do
    ip = ipstrt

    bpre = bpre + b_prefix(ip,k)
    ndt = b_prefix(ip+1,k)-b_prefix(ip,k)
    a1st = idxp1(ip) + ndl * (k-1)
    locid = tid - bpre + 1
    a1(a1st+locid-1) = zab(tid)

  end subroutine create_a1_a2_opt


#if NOTDEBUG

  attributes(global) subroutine HACApK_calc_kt_cuda_final                                         &
       (st,en,offset,zaa,zab,lcol_msk,lrow_msk,ndl_prefix,ndt_prefix,ndlp,ndtp,nstrtlp,nstrttp,ktp         &
       ,param61,param64,lod,kmax,eps,znrmmat,pACA_EPS,face2node,lp61,ao,np,warn,err)
    
    
    integer*4,                 intent(in)    ,value  :: st,en,offset
    real*8,   dimension(:),    intent(out)           :: zaa,zab
    integer*4,dimension(:),    intent(inout)         :: lrow_msk,lcol_msk
    integer*4,dimension(:),    intent(in)            :: ndl_prefix,ndt_prefix
    integer*4,dimension(:),    intent(in)            :: ndlp,ndtp,nstrtlp,nstrttp
    integer*4,dimension(:),    intent(out)           :: ktp
    real*8,                    intent(in)    ,value  :: param61,param64
    integer*4,dimension(:),    intent(in)            :: lod
    integer*4,                 intent(in)    ,value  :: kmax
    real*8,                    intent(in)    ,value  :: eps,znrmmat,pACA_EPS
    integer*4,dimension(:,:),  intent(in)            :: face2node
    real*8,   dimension(:,:),  intent(in)            :: np
    real*8,   dimension(:),    intent(in)            :: ao
    integer*4,                 intent(in)    ,value  :: lp61
    integer*4,dimension(:),    intent(inout)         :: warn,err
!    real*8,                    intent(in)    ,value  :: inv_4_PI_EPSILON_0
    
    integer*4 :: ndl,ndt,nstrtl,nstrtt,kt,ip,ns,krank,nrow_done,ncol_done,k,lstop_aca,kstop,ist,jst,istn
    integer*4 :: ii,ndk,ill,itt,it,il
    real*8 :: znrm,ACA_EPS,row_maxval,col_maxval,zdltinv,zeps
    real*8 :: zscl,zzz,zza
    
    integer*4 :: n(3),iii,i,j,jj
!    real*8    :: xs(3),ys(3),zs(3),x,y,z,r(3),u(3),v(3),w(3)
    real*8    :: xs(3),ys(3),zs(3),x,y,z
    real*8    :: xst(3),yst(3),zst(3)
    real*8    :: xi, xj, yi, dx, dy, t, l, m, d, ti, tj
    real*8    :: theta, omega, q, g, zp, zpabs, ox,oy,oz
    integer*4 :: zaa_st, zab_st, ndl_pre, ndt_pre
    integer*4 :: tx,dimx,wid,wlen
    real*8    :: dtmp
    integer*4 :: itmp, flag, imsk, txbit
    real*8    :: aoij
    real*8,shared    :: dshared(8)
    integer*4,shared    :: ishared(8)
         
    ip = st + blockIdx%x - 1
    tx = threadIdx%x
    dimx = blockDim%x
    wid = (tx-1)/32+1
    wlen = dimx/32
    txbit = ishft(1,mod(tx-1,32)) 
    !    do ip=st,en
    
    ndl   =ndlp(ip)   ; ndt   =ndtp(ip)   ; ns=ndl*ndt
    nstrtl=nstrtlp(ip); nstrtt=nstrttp(ip)
    ndl_pre=ndl_prefix(ip)-ndl_prefix(st)+1 ; ndt_pre=ndt_prefix(ip)-ndt_prefix(st)+1
    zaa_st=offset+(ndl_pre-1)*kmax+1 ; zab_st=offset+(ndt_pre-1)*kmax+1
    
    ! write(6,1000) 'nstrtl=',nstrtl,' nstrtt=',nstrtt,' ndl=',ndl,' ndt=',ndt, 'kmax=',kmax
    krank=min(ndl,ndt)
    znrm=znrmmat*sqrt(real(ndl)*real(ndt))
    if(param61==1) ACA_EPS=pACA_EPS
    if(param61==2 .or. param61==3) ACA_EPS=pACA_EPS*znrm
    !lrow_msk(ndl_pre:ndl_pre+ndl-1)=0; lcol_msk(ndt_pre:ndt_pre+ndt-1)=0;
    do il = ndl_pre+tx-1, ndl_pre+(ndl-1)/32+1, dimx
       lrow_msk(il)=0
    enddo
    do it = ndt_pre+tx-1, ndt_pre+(ndt-1)/32+1, dimx
       lcol_msk(it)=0
    enddo
    nrow_done=0; ncol_done=0
    kt=0; k=1; lstop_aca=0
    kstop=min(kmax,krank)
    if(nstrtl>nstrtt)then; ist=1
    else; ist=ndl
    endif
    !      allocate(pcol(ndl),prow(ndt))
    !      do
    do 

       ill=ist+nstrtl-1
       i = lod(ill)
       n(1:3)  = face2node(1:3, i) + 1
       xs(1:3) = np(1, n(1:3) )
       ys(1:3) = np(2, n(1:3) )
       zs(1:3) = np(3, n(1:3) )
       x = (xs(1) + xs(2) + xs(3)) / 3d0
       y = (ys(1) + ys(2) + ys(3)) / 3d0
       z = (zs(1) + zs(2) + zs(3)) / 3d0
       if(lp61==3) aoij = ao(i)
       
       !====================================================================================================
       !         call HACApK_calc_vec(zab, zaa, ndt, k-1, ist, prow, nstrtl, nstrtt,lod, st_bemv, lcol_msk,0) 
       imsk = ndt_pre+wid-1
       do ii=tx,ndt,dimx
          ! if(lcol_msk(ii)==0) then
          if(iand(lcol_msk(imsk),txbit)==0) then
             itt=ii+nstrtt-1
             !---------------------------------------------------------------------------------------------------
             !prow(ii)=HACApK_entry_ij(lod(ill),lod(itt),st_bemv)
             j = lod(itt)
             
             n(1:3) = face2node(1:3, j) + 1
             xs(1:3) = np(1, n(1:3) )
             ys(1:3) = np(2, n(1:3) )
             zs(1:3) = np(3, n(1:3) )
             
             
             dtmp = face_integral_cuda(xs, ys, zs, x, y, z)
             if(lp61==3) dtmp=dtmp*aoij*ao(j)
             zab(zab_st+ndt*(k-1)+ii-1) = dtmp

             !---------------------------------------------------------------------------------------------------
          endif
          imsk = imsk + wlen
       enddo
       if(k.ne.1) then
          do il=1,k-1
             do it=tx,ndt,dimx
                zab(zab_st+ndt*(k-1)+it-1)=zab(zab_st+ndt*(k-1)+it-1)-zab(zab_st+ndt*(il-1)+it-1)*zaa(zaa_st+ndl*(il-1)+ist-1)
             enddo
          enddo
          imsk = ndt_pre+wid-1
          do iii=tx,ndt,dimx
             if(iand(lcol_msk(imsk),txbit).ne.0) then
                zab(zab_st+ndt*(k-1)+iii-1)=0.0d0
             endif
             imsk = imsk + wlen
          enddo
       endif
       !====================================================================================================
       !         call HACApK_maxabsvallocm_d(prow,row_maxval,jst,ndt,lcol_msk)
       
       jst = 0; row_maxval = 0.0d0
       
       imsk = ndt_pre+wid-1
       do it=tx,ndt,dimx
          if(iand(lcol_msk(imsk),txbit)==0) then
             dtmp = dabs(zab(zab_st+ndt*(k-1)+it-1))
             if(dtmp > row_maxval)then
                jst = it;
                row_maxval = dtmp
             endif
          endif
          imsk = imsk + wlen
       enddo
       dtmp = __shfl_xor(row_maxval,16)
       itmp = __shfl_xor(jst,16)
       if(dtmp > row_maxval) then
          row_maxval = dtmp
          jst        = itmp
       endif
       dtmp = __shfl_xor(row_maxval,8)
       itmp = __shfl_xor(jst,8)
       if(dtmp > row_maxval) then
          row_maxval = dtmp
          jst        = itmp
       endif
       dtmp = __shfl_xor(row_maxval,4)
       itmp = __shfl_xor(jst,4)
       if(dtmp > row_maxval) then
          row_maxval = dtmp
          jst        = itmp
       endif
       dtmp = __shfl_xor(row_maxval,2)
       itmp = __shfl_xor(jst,2)
       if(dtmp > row_maxval) then
          row_maxval = dtmp
          jst        = itmp
       endif
       dtmp = __shfl_xor(row_maxval,1)
       itmp = __shfl_xor(jst,1)
       if(dtmp > row_maxval) then
          row_maxval = dtmp
          jst        = itmp
       endif
       call syncthreads()
       if(mod(tx,32) == 1) then
          dshared(wid) = row_maxval
          ishared(wid) = jst
       endif
       call syncthreads()
       do i = 1, wlen
          if(dshared(i) > row_maxval) then
             row_maxval = dshared(i)
             jst        = ishared(i)
          endif
       enddo
       call syncthreads()
       
       !====================================================================================================
       !   print*,'jst=',jst,' row_maxval=',row_maxval
       ! write(6,1000) 'ist=',ist,'  jst=',jst
       
       !         zdltinv=1.0d0/prow(jst); prow(:)=prow(:)*zdltinv
       zdltinv=1.0d0/zab(zab_st+ndt*(k-1)+jst-1)
       !       zab(zab_st+ndt*(k-1):zab_st+ndt*k-1)=zab(zab_st+ndt*(k-1):zab_st+ndt*k-1)*zdltinv
       do ii=zab_st+ndt*(k-1)+tx-1,zab_st+ndt*k-1,dimx
          zab(ii)=zab(ii)*zdltinv
       enddo
       
       !         call HACApK_calc_vec(zaa, zab, ndl, k-1, jst, pcol, nstrtl, nstrtt,lod, st_bemv, lrow_msk,1)

       itt=jst+nstrtt-1
       j = lod(itt)
       n(1:3) = face2node(1:3, j) + 1
       xs(1:3) = np(1, n(1:3) )
       ys(1:3) = np(2, n(1:3) )
       zs(1:3) = np(3, n(1:3) )
       if(lp61==3) aoij    = ao(j)
       
       imsk = ndl_pre+wid-1
       do ii=tx,ndl,dimx
          !            if(lrow_msk(ii)==0) then
          if(iand(lrow_msk(imsk),txbit)==0) then
             !             ill=ii+nstrtl-1; itt=jst+nstrtt-1
             ill=ii+nstrtl-1
             !---------------------------------------------------------------------------------------------------
             !pcol(ii)=HACApK_entry_ij(lod(ill),lod(itt),st_bemv)
             
             ! i = lod(ill) ; j = lod(itt)
             i = lod(ill) 
             !          n(1:3)  = st_bemv%face2node(1:3, i) + 1
             n(1:3)  = face2node(1:3, i) + 1
             ! xs(1:3) = st_bemv%np( n(1:3) )%x
             ! ys(1:3) = st_bemv%np( n(1:3) )%y
             ! zs(1:3) = st_bemv%np( n(1:3) )%z
             xst(1:3) = np(1, n(1:3) )
             yst(1:3) = np(2, n(1:3) )
             zst(1:3) = np(3, n(1:3) )
             
             ! x = sum( xs(1:3) ) / 3d0
             ! y = sum( ys(1:3) ) / 3d0
             ! z = sum( zs(1:3) ) / 3d0
             x = (xst(1) + xst(2) + xst(3)) / 3d0
             y = (yst(1) + yst(2) + yst(3)) / 3d0
             z = (zst(1) + zst(2) + zst(3)) / 3d0
             
             dtmp = face_integral_cuda(xs, ys, zs, x, y, z)
             if(lp61==3) dtmp=dtmp*ao(i)*aoij
             zaa(zaa_st+ndl*(k-1)+ii-1) = dtmp

             !---------------------------------------------------------------------------------------------------
          endif
          imsk = imsk + wlen
       enddo
       if(k.ne.1) then
          do it=1,k-1
             do il=tx,ndl,dimx
                zaa(zaa_st+ndl*(k-1)+il-1)=zaa(zaa_st+ndl*(k-1)+il-1)-zaa(zaa_st+ndl*(it-1)+il-1)*zab(zab_st+ndt*(it-1)+jst-1)
             enddo
          enddo
          imsk = ndl_pre+wid-1
          do iii=tx,ndl,dimx
             if(iand(lrow_msk(imsk),txbit).ne.0) then
                zaa(zaa_st+ndl*(k-1)+iii-1)=0.0d0
             endif
             imsk = imsk + wlen
          enddo
       endif
       !====================================================================================================
       call syncthreads()
       if(tx == mod(ist-1,32)+1) lrow_msk(ndl_pre+(ist-1)/32)=ior(lrow_msk(ndl_pre+(ist-1)/32),txbit)
       call syncthreads()
       !         call HACApK_maxabsvallocm_d(pcol,col_maxval,istn,ndl,lrow_msk)
       istn = 0; col_maxval = 0.0d0
       imsk = ndl_pre+wid-1
       do it=tx,ndl,dimx
          if(iand(lrow_msk(imsk),txbit)==0) then
             dtmp = dabs(zaa(zaa_st+ndl*(k-1)+it-1))
             if(dtmp > col_maxval)then
                istn = it;
                col_maxval = dtmp
             endif
          endif
          imsk = imsk + wlen
       enddo

       dtmp = __shfl_xor(col_maxval,16)
       itmp = __shfl_xor(istn,16)
       if(dtmp > col_maxval) then
          col_maxval = dtmp
          istn       = itmp
       endif
       dtmp = __shfl_xor(col_maxval,8)
       itmp = __shfl_xor(istn,8)
       if(dtmp > col_maxval) then
          col_maxval = dtmp
          istn       = itmp
       endif
       dtmp = __shfl_xor(col_maxval,4)
       itmp = __shfl_xor(istn,4)
       if(dtmp > col_maxval) then
          col_maxval = dtmp
          istn       = itmp
       endif
       dtmp = __shfl_xor(col_maxval,2)
       itmp = __shfl_xor(istn,2)
       if(dtmp > col_maxval) then
          col_maxval = dtmp
          istn       = itmp
       endif
       dtmp = __shfl_xor(col_maxval,1)
       itmp = __shfl_xor(istn,1)
       if(dtmp > col_maxval) then
          col_maxval = dtmp
          istn       = itmp
       endif
       call syncthreads()
       if(mod(tx,32) == 1) then
          dshared(wid) = col_maxval
          ishared(wid) = istn
       endif
       call syncthreads()
       do i = 1, wlen
          if(dshared(i) > col_maxval) then
             col_maxval = dshared(i)
             istn       = ishared(i)
          endif
       enddo
       call syncthreads()

       !====================================================================================================
       !   print*, 'pcol=',pcol
       !   print *,'zeps=',zeps
       !   print*,'istn=',istn,' col_maxval=',col_maxval
!       if(tx==1) lcol_msk(ndt_pre-1+jst)=1
       call syncthreads()
       if(tx == mod(jst-1,32)+1) lcol_msk(ndt_pre+(jst-1)/32)=ior(lcol_msk(ndt_pre+(jst-1)/32),txbit)
       call syncthreads()
       ist=istn; nrow_done=nrow_done+1; ncol_done=ncol_done+1
       if(abs(row_maxval)<ACA_EPS .and. abs(col_maxval)<ACA_EPS .and. k>=param64) then
          !             !$omp critical
          !             print *, 'ACA_EPS=',ACA_EPS
          !             print *, 'abs(row_maxval)=',abs(row_maxval)
          !             print *, 'abs(col_maxval)=',abs(col_maxval)
          !             print *, 'stop HACApK_aca 3';
          ! !!!     stop
          !             !$omp end critical
          if(tx==1) warn(ip) = 1
          goto 9999
       endif
       !====================================================================================================
       !zeps=HACApK_unrm_d(ndl,pcol)*HACApK_unrm_d(ndt,prow)
       zzz=0.0d0
       do il=tx,ndl,dimx
          zza = abs(zaa(zaa_st+ndl*(k-1)+il-1))
          zzz = zzz + zza*zza
       enddo
       zzz = zzz + __shfl_xor(zzz,16)
       zzz = zzz + __shfl_xor(zzz,8)
       zzz = zzz + __shfl_xor(zzz,4)
       zzz = zzz + __shfl_xor(zzz,2)
       zzz = zzz + __shfl_xor(zzz,1)
       call syncthreads()
       if(mod(tx,32) == 1) then
          dshared(wid) = zzz
       endif
       call syncthreads()
       zzz = 0.0d0
       do i = 1, dimx/32
          zzz = zzz + dshared(i)
       enddo
       call syncthreads()
       zeps= dsqrt(zzz)

       zzz=0.0d0
       do il=tx,ndt,dimx
          zza = abs(zab(zab_st+ndt*(k-1)+il-1))
          zzz = zzz + zza*zza
       enddo
       zzz = zzz + __shfl_xor(zzz,16)
       zzz = zzz + __shfl_xor(zzz,8)
       zzz = zzz + __shfl_xor(zzz,4)
       zzz = zzz + __shfl_xor(zzz,2)
       zzz = zzz + __shfl_xor(zzz,1)
       call syncthreads()
       if(mod(tx,32) == 1) then
          dshared(wid) = zzz
       endif
       call syncthreads()
       zzz = 0.0d0
       do i = 1, dimx/32
          zzz = zzz + dshared(i)
       enddo
       call syncthreads()
       zeps= zeps*dsqrt(zzz)

       !====================================================================================================
       !   zcolm=HACApK_unrm_d(ndl,pcol); zrowm=HACApK_unrm_d(ndt,prow)
       if(k==1 .and. param61==1) znrm=zeps
       zeps=zeps/znrm
       if(zeps<eps .or. k==kstop) lstop_aca = 1
       if(lstop_aca==1 .and. k>=param64) then
          exit
       endif
       !         zaa(zaa_st+ndl*(k-1):zaa_st+ndl*k-1) = pcol(1:ndl); zab(zab_st+ndt*(k-1):zab_st+ndt*k-1) = prow(1:ndt)
       k=k+1
    enddo
    !      zaa(zaa_st+ndl*(k-1):zaa_st+ndl*k-1) = pcol(1:ndl); zab(zab_st+ndt*(k-1):zab_st+ndt*k-1) = prow(1:ndt)
    !      deallocate(pcol,prow)
    
9999 continue
    !      deallocate(lrow_msk,lcol_msk)
    kt=k
    if(zeps>eps .and. k<krank)then
       ! !$omp critical
       ! print *,'k=',k
       ! print *,'zeps=',zeps
       ! print *,'eps=',eps
       ! write(6,1000) 'nstrtl=',nstrtl,' nstrtt=',nstrtt,' ndl=',ndl,' ndt=',ndt
       ! print*,'znrm=',znrm
       ! stop
       ! !$omp end critical
       if(tx==1) err(ip) = 1
    endif
    ! stop
    
    !      deallocate(zab,zaa)
    if(tx==1) ktp(ip)=kt
    !    enddo
  end subroutine HACApK_calc_kt_cuda_final


  attributes(global) subroutine HACApK_calc_kt_cuda_kernel4                                         &
       (st,en,offset,zaa,zab,lcol_msk,lrow_msk,ndl_prefix,ndt_prefix,ndlp,ndtp,nstrtlp,nstrttp,ktp         &
       ,param61,param64,lod,kmax,eps,znrmmat,pACA_EPS,st_bemv,warn,err)
    use m_HACApK_calc_entry_ij    
    integer*4,                 intent(in)    ,value  :: st,en,offset
    real*8,   dimension(:),    intent(out)           :: zaa,zab
    integer*4,dimension(:),    intent(inout)         :: lrow_msk,lcol_msk
    integer*4,dimension(:),    intent(in)            :: ndl_prefix,ndt_prefix
    integer*4,dimension(:),    intent(in)            :: ndlp,ndtp,nstrtlp,nstrttp
    integer*4,dimension(:),    intent(out)           :: ktp
    real*8,                    intent(in)    ,value  :: param61,param64
    integer*4,dimension(:),    intent(in)            :: lod
    integer*4,                 intent(in)    ,value  :: kmax
    real*8,                    intent(in)    ,value  :: eps,znrmmat,pACA_EPS
    ! type :: coordinate
    !    real(8) :: x ,y ,z
    ! end type coordinate
    ! type :: st_HACApK_calc_entry
    !    real*8,pointer :: ao(:)
    !    integer :: nd,lp61
    !    integer :: nond,nofc,number_element_dof,nond_on_face,nint_para_fc,ndble_para_fc
    !    integer,pointer :: int_para_fc(:,:), face2node(:,:)
    !    real*8,pointer  :: dble_para_fc(:,:)
    !    type(coordinate),pointer :: np(:)
       
    !    real*8,pointer :: zx(:),zy(:),zz(:)
    ! end type st_HACApK_calc_entry
    type(st_HACApK_calc_entry),intent(in)            :: st_bemv
    integer*4,dimension(:),    intent(inout)         :: warn,err
    !    real*8,                    intent(in)    ,value  :: inv_4_PI_EPSILON_0
    
    integer*4 :: ndl,ndt,nstrtl,nstrtt,kt,ip,ns,krank,nrow_done,ncol_done,k,lstop_aca,kstop,ist,jst,istn
    integer*4 :: ii,ndk,ill,itt,it,il
    real*8 :: znrm,ACA_EPS,row_maxval,col_maxval,zdltinv,zeps
    real*8 :: zscl,zzz,zza
    
    integer*4 :: n(3),iii,i,j,jj
!    real*8    :: xs(3),ys(3),zs(3),x,y,z,r(3),u(3),v(3),w(3)
    real*8    :: xs(3),ys(3),zs(3),x,y,z
    real*8    :: xst(3),yst(3),zst(3)
    real*8    :: xi, xj, yi, dx, dy, t, l, m, d, ti, tj
    real*8    :: theta, omega, q, g, zp, zpabs, ox,oy,oz
    integer*4 :: zaa_st, zab_st, ndl_pre, ndt_pre
    integer*4 :: tx,dimx,wid,wlen
    real*8    :: dtmp
    integer*4 :: itmp, flag, imsk, txbit
    real*8    :: aoij
    real*8,shared    :: dshared(8)
    integer*4,shared    :: ishared(8)
    ! integer*4,dimension(:,:),  pointer            :: face2node
    ! type(coordinate),dimension(:), pointer         :: np
    ! real*8,   dimension(:),    pointer            :: ao
    integer*4 :: lp61

    !face2node => st_bemv%face2node
    ! np => st_bemv%np
    ! ao => st_bemv%ao
    !lp61 = st_bemv%lp61
         
    ip = st + blockIdx%x - 1
    tx = threadIdx%x
    dimx = blockDim%x
    wid = (tx-1)/32+1
    wlen = dimx/32
    txbit = ishft(1,mod(tx-1,32)) 
    !    do ip=st,en
    !if(tx == 1) print *, lp61

    ndl   =ndlp(ip)   ; ndt   =ndtp(ip)   ; ns=ndl*ndt
    nstrtl=nstrtlp(ip); nstrtt=nstrttp(ip)
    ndl_pre=ndl_prefix(ip)-ndl_prefix(st)+1 ; ndt_pre=ndt_prefix(ip)-ndt_prefix(st)+1
    zaa_st=offset+(ndl_pre-1)*kmax+1 ; zab_st=offset+(ndt_pre-1)*kmax+1
    
    ! write(6,1000) 'nstrtl=',nstrtl,' nstrtt=',nstrtt,' ndl=',ndl,' ndt=',ndt, 'kmax=',kmax
    krank=min(ndl,ndt)
    znrm=znrmmat*sqrt(real(ndl)*real(ndt))
    if(param61==1) ACA_EPS=pACA_EPS
    if(param61==2 .or. param61==3) ACA_EPS=pACA_EPS*znrm
    !lrow_msk(ndl_pre:ndl_pre+ndl-1)=0; lcol_msk(ndt_pre:ndt_pre+ndt-1)=0;
    do il = ndl_pre+tx-1, ndl_pre+(ndl-1)/32+1, dimx
       lrow_msk(il)=0
    enddo
    do it = ndt_pre+tx-1, ndt_pre+(ndt-1)/32+1, dimx
       lcol_msk(it)=0
    enddo
    nrow_done=0; ncol_done=0
    kt=0; k=1; lstop_aca=0
    kstop=min(kmax,krank)
    if(nstrtl>nstrtt)then; ist=1
    else; ist=ndl
    endif
    !      allocate(pcol(ndl),prow(ndt))
    !      do
    do 

       ill=ist+nstrtl-1
       i = lod(ill)
       n(1:3)  = st_bemv%face2node(1:3, i) + 1
       xs(1:3) = st_bemv%np(n(1:3) )%x
       ys(1:3) = st_bemv%np(n(1:3) )%y
       zs(1:3) = st_bemv%np(n(1:3) )%z
       x = (xs(1) + xs(2) + xs(3)) / 3d0
       y = (ys(1) + ys(2) + ys(3)) / 3d0
       z = (zs(1) + zs(2) + zs(3)) / 3d0
       if(st_bemv%lp61==3) aoij = st_bemv%ao(i)
       
       !====================================================================================================
       !         call HACApK_calc_vec(zab, zaa, ndt, k-1, ist, prow, nstrtl, nstrtt,lod, st_bemv, lcol_msk,0) 
       imsk = ndt_pre+wid-1
       do ii=tx,ndt,dimx
          ! if(lcol_msk(ii)==0) then
          if(iand(lcol_msk(imsk),txbit)==0) then
             itt=ii+nstrtt-1
             !---------------------------------------------------------------------------------------------------
             !prow(ii)=HACApK_entry_ij(lod(ill),lod(itt),st_bemv)
             j = lod(itt)
             
             n(1:3) = st_bemv%face2node(1:3, j) + 1
             xs(1:3) = st_bemv%np( n(1:3) )%x
             ys(1:3) = st_bemv%np( n(1:3) )%y
             zs(1:3) = st_bemv%np( n(1:3) )%z
             
             
             dtmp = face_integral_cuda(xs, ys, zs, x, y, z)
             if(st_bemv%lp61==3) dtmp=dtmp*aoij*st_bemv%ao(j)
             zab(zab_st+ndt*(k-1)+ii-1) = dtmp

             !---------------------------------------------------------------------------------------------------
          endif
          imsk = imsk + wlen
       enddo
       if(k.ne.1) then
          do il=1,k-1
             do it=tx,ndt,dimx
                zab(zab_st+ndt*(k-1)+it-1)=zab(zab_st+ndt*(k-1)+it-1)-zab(zab_st+ndt*(il-1)+it-1)*zaa(zaa_st+ndl*(il-1)+ist-1)
             enddo
          enddo
          imsk = ndt_pre+wid-1
          do iii=tx,ndt,dimx
             if(iand(lcol_msk(imsk),txbit).ne.0) then
                zab(zab_st+ndt*(k-1)+iii-1)=0.0d0
             endif
             imsk = imsk + wlen
          enddo
       endif
       !====================================================================================================
       !         call HACApK_maxabsvallocm_d(prow,row_maxval,jst,ndt,lcol_msk)
       
       jst = 0; row_maxval = 0.0d0
       
       imsk = ndt_pre+wid-1
       do it=tx,ndt,dimx
          if(iand(lcol_msk(imsk),txbit)==0) then
             dtmp = dabs(zab(zab_st+ndt*(k-1)+it-1))
             if(dtmp > row_maxval)then
                jst = it;
                row_maxval = dtmp
             endif
          endif
          imsk = imsk + wlen
       enddo
       dtmp = __shfl_xor(row_maxval,16)
       itmp = __shfl_xor(jst,16)
       if(dtmp > row_maxval) then
          row_maxval = dtmp
          jst        = itmp
       endif
       dtmp = __shfl_xor(row_maxval,8)
       itmp = __shfl_xor(jst,8)
       if(dtmp > row_maxval) then
          row_maxval = dtmp
          jst        = itmp
       endif
       dtmp = __shfl_xor(row_maxval,4)
       itmp = __shfl_xor(jst,4)
       if(dtmp > row_maxval) then
          row_maxval = dtmp
          jst        = itmp
       endif
       dtmp = __shfl_xor(row_maxval,2)
       itmp = __shfl_xor(jst,2)
       if(dtmp > row_maxval) then
          row_maxval = dtmp
          jst        = itmp
       endif
       dtmp = __shfl_xor(row_maxval,1)
       itmp = __shfl_xor(jst,1)
       if(dtmp > row_maxval) then
          row_maxval = dtmp
          jst        = itmp
       endif
       call syncthreads()
       if(mod(tx,32) == 1) then
          dshared(wid) = row_maxval
          ishared(wid) = jst
       endif
       call syncthreads()
       do i = 1, wlen
          if(dshared(i) > row_maxval) then
             row_maxval = dshared(i)
             jst        = ishared(i)
          endif
       enddo
       call syncthreads()
       
       !====================================================================================================
       !   print*,'jst=',jst,' row_maxval=',row_maxval
       ! write(6,1000) 'ist=',ist,'  jst=',jst
       
       !         zdltinv=1.0d0/prow(jst); prow(:)=prow(:)*zdltinv
       zdltinv=1.0d0/zab(zab_st+ndt*(k-1)+jst-1)
       !       zab(zab_st+ndt*(k-1):zab_st+ndt*k-1)=zab(zab_st+ndt*(k-1):zab_st+ndt*k-1)*zdltinv
       do ii=zab_st+ndt*(k-1)+tx-1,zab_st+ndt*k-1,dimx
          zab(ii)=zab(ii)*zdltinv
       enddo
       
       !         call HACApK_calc_vec(zaa, zab, ndl, k-1, jst, pcol, nstrtl, nstrtt,lod, st_bemv, lrow_msk,1)

       itt=jst+nstrtt-1
       j = lod(itt)
       n(1:3) = st_bemv%face2node(1:3, j) + 1
       xs(1:3) = st_bemv%np( n(1:3) )%x
       ys(1:3) = st_bemv%np( n(1:3) )%y
       zs(1:3) = st_bemv%np( n(1:3) )%z
       if(st_bemv%lp61==3) aoij    = st_bemv%ao(j)
       
       imsk = ndl_pre+wid-1
       do ii=tx,ndl,dimx
          !            if(lrow_msk(ii)==0) then
          if(iand(lrow_msk(imsk),txbit)==0) then
             !             ill=ii+nstrtl-1; itt=jst+nstrtt-1
             ill=ii+nstrtl-1
             !---------------------------------------------------------------------------------------------------
             !pcol(ii)=HACApK_entry_ij(lod(ill),lod(itt),st_bemv)
             
             ! i = lod(ill) ; j = lod(itt)
             i = lod(ill) 
             !          n(1:3)  = st_bemv%face2node(1:3, i) + 1
             n(1:3)  = st_bemv%face2node(1:3, i) + 1
             ! xs(1:3) = st_bemv%np( n(1:3) )%x
             ! ys(1:3) = st_bemv%np( n(1:3) )%y
             ! zs(1:3) = st_bemv%np( n(1:3) )%z
             xst(1:3) = st_bemv%np( n(1:3) )%x
             yst(1:3) = st_bemv%np( n(1:3) )%y
             zst(1:3) = st_bemv%np( n(1:3) )%z
             
             ! x = sum( xs(1:3) ) / 3d0
             ! y = sum( ys(1:3) ) / 3d0
             ! z = sum( zs(1:3) ) / 3d0
             x = (xst(1) + xst(2) + xst(3)) / 3d0
             y = (yst(1) + yst(2) + yst(3)) / 3d0
             z = (zst(1) + zst(2) + zst(3)) / 3d0
             
             dtmp = face_integral_cuda(xs, ys, zs, x, y, z)
             if(st_bemv%lp61==3) dtmp=dtmp*st_bemv%ao(i)*aoij
             zaa(zaa_st+ndl*(k-1)+ii-1) = dtmp

             !---------------------------------------------------------------------------------------------------
          endif
          imsk = imsk + wlen
       enddo
       if(k.ne.1) then
          do it=1,k-1
             do il=tx,ndl,dimx
                zaa(zaa_st+ndl*(k-1)+il-1)=zaa(zaa_st+ndl*(k-1)+il-1)-zaa(zaa_st+ndl*(it-1)+il-1)*zab(zab_st+ndt*(it-1)+jst-1)
             enddo
          enddo
          imsk = ndl_pre+wid-1
          do iii=tx,ndl,dimx
             if(iand(lrow_msk(imsk),txbit).ne.0) then
                zaa(zaa_st+ndl*(k-1)+iii-1)=0.0d0
             endif
             imsk = imsk + wlen
          enddo
       endif
       !====================================================================================================
       call syncthreads()
       if(tx == mod(ist-1,32)+1) lrow_msk(ndl_pre+(ist-1)/32)=ior(lrow_msk(ndl_pre+(ist-1)/32),txbit)
       call syncthreads()
       !         call HACApK_maxabsvallocm_d(pcol,col_maxval,istn,ndl,lrow_msk)
       istn = 0; col_maxval = 0.0d0
       imsk = ndl_pre+wid-1
       do it=tx,ndl,dimx
          if(iand(lrow_msk(imsk),txbit)==0) then
             dtmp = dabs(zaa(zaa_st+ndl*(k-1)+it-1))
             if(dtmp > col_maxval)then
                istn = it;
                col_maxval = dtmp
             endif
          endif
          imsk = imsk + wlen
       enddo

       dtmp = __shfl_xor(col_maxval,16)
       itmp = __shfl_xor(istn,16)
       if(dtmp > col_maxval) then
          col_maxval = dtmp
          istn       = itmp
       endif
       dtmp = __shfl_xor(col_maxval,8)
       itmp = __shfl_xor(istn,8)
       if(dtmp > col_maxval) then
          col_maxval = dtmp
          istn       = itmp
       endif
       dtmp = __shfl_xor(col_maxval,4)
       itmp = __shfl_xor(istn,4)
       if(dtmp > col_maxval) then
          col_maxval = dtmp
          istn       = itmp
       endif
       dtmp = __shfl_xor(col_maxval,2)
       itmp = __shfl_xor(istn,2)
       if(dtmp > col_maxval) then
          col_maxval = dtmp
          istn       = itmp
       endif
       dtmp = __shfl_xor(col_maxval,1)
       itmp = __shfl_xor(istn,1)
       if(dtmp > col_maxval) then
          col_maxval = dtmp
          istn       = itmp
       endif
       call syncthreads()
       if(mod(tx,32) == 1) then
          dshared(wid) = col_maxval
          ishared(wid) = istn
       endif
       call syncthreads()
       do i = 1, wlen
          if(dshared(i) > col_maxval) then
             col_maxval = dshared(i)
             istn       = ishared(i)
          endif
       enddo
       call syncthreads()

       !====================================================================================================
       !   print*, 'pcol=',pcol
       !   print *,'zeps=',zeps
       !   print*,'istn=',istn,' col_maxval=',col_maxval
!       if(tx==1) lcol_msk(ndt_pre-1+jst)=1
       call syncthreads()
       if(tx == mod(jst-1,32)+1) lcol_msk(ndt_pre+(jst-1)/32)=ior(lcol_msk(ndt_pre+(jst-1)/32),txbit)
       call syncthreads()
       ist=istn; nrow_done=nrow_done+1; ncol_done=ncol_done+1
       if(abs(row_maxval)<ACA_EPS .and. abs(col_maxval)<ACA_EPS .and. k>=param64) then
          !             !$omp critical
          !             print *, 'ACA_EPS=',ACA_EPS
          !             print *, 'abs(row_maxval)=',abs(row_maxval)
          !             print *, 'abs(col_maxval)=',abs(col_maxval)
          !             print *, 'stop HACApK_aca 3';
          ! !!!     stop
          !             !$omp end critical
          if(tx==1) warn(ip) = 1
          goto 9999
       endif
       !====================================================================================================
       !zeps=HACApK_unrm_d(ndl,pcol)*HACApK_unrm_d(ndt,prow)
       zzz=0.0d0
       do il=tx,ndl,dimx
          zza = abs(zaa(zaa_st+ndl*(k-1)+il-1))
          zzz = zzz + zza*zza
       enddo
       zzz = zzz + __shfl_xor(zzz,16)
       zzz = zzz + __shfl_xor(zzz,8)
       zzz = zzz + __shfl_xor(zzz,4)
       zzz = zzz + __shfl_xor(zzz,2)
       zzz = zzz + __shfl_xor(zzz,1)
       call syncthreads()
       if(mod(tx,32) == 1) then
          dshared(wid) = zzz
       endif
       call syncthreads()
       zzz = 0.0d0
       do i = 1, dimx/32
          zzz = zzz + dshared(i)
       enddo
       call syncthreads()
       zeps= dsqrt(zzz)

       zzz=0.0d0
       do il=tx,ndt,dimx
          zza = abs(zab(zab_st+ndt*(k-1)+il-1))
          zzz = zzz + zza*zza
       enddo
       zzz = zzz + __shfl_xor(zzz,16)
       zzz = zzz + __shfl_xor(zzz,8)
       zzz = zzz + __shfl_xor(zzz,4)
       zzz = zzz + __shfl_xor(zzz,2)
       zzz = zzz + __shfl_xor(zzz,1)
       call syncthreads()
       if(mod(tx,32) == 1) then
          dshared(wid) = zzz
       endif
       call syncthreads()
       zzz = 0.0d0
       do i = 1, dimx/32
          zzz = zzz + dshared(i)
       enddo
       call syncthreads()
       zeps= zeps*dsqrt(zzz)

       !====================================================================================================
       !   zcolm=HACApK_unrm_d(ndl,pcol); zrowm=HACApK_unrm_d(ndt,prow)
       if(k==1 .and. param61==1) znrm=zeps
       zeps=zeps/znrm
       if(zeps<eps .or. k==kstop) lstop_aca = 1
       if(lstop_aca==1 .and. k>=param64) then
          exit
       endif
       !         zaa(zaa_st+ndl*(k-1):zaa_st+ndl*k-1) = pcol(1:ndl); zab(zab_st+ndt*(k-1):zab_st+ndt*k-1) = prow(1:ndt)
       k=k+1
    enddo
    !      zaa(zaa_st+ndl*(k-1):zaa_st+ndl*k-1) = pcol(1:ndl); zab(zab_st+ndt*(k-1):zab_st+ndt*k-1) = prow(1:ndt)
    !      deallocate(pcol,prow)
    
9999 continue
    !      deallocate(lrow_msk,lcol_msk)
    kt=k
    if(zeps>eps .and. k<krank)then
       ! !$omp critical
       ! print *,'k=',k
       ! print *,'zeps=',zeps
       ! print *,'eps=',eps
       ! write(6,1000) 'nstrtl=',nstrtl,' nstrtt=',nstrtt,' ndl=',ndl,' ndt=',ndt
       ! print*,'znrm=',znrm
       ! stop
       ! !$omp end critical
       if(tx==1) err(ip) = 1
    endif
    ! stop
    
    !      deallocate(zab,zaa)
    if(tx==1) ktp(ip)=kt
    !    enddo
  end subroutine HACApK_calc_kt_cuda_kernel4


  attributes(global) subroutine HACApK_calc_kt_cuda                                                        &
       (st,en,offset,zaa,zab,lcol_msk,lrow_msk,ndl_prefix,ndt_prefix,ndlp,ndtp,nstrtlp,nstrttp,ktp         &
       ,param61,param64,lod,kmax,eps,znrmmat,pACA_EPS,st_bemv,warn,err)
    use m_HACApK_calc_entry_ij    
    integer*4,                 intent(in)    ,value  :: st,en,offset
    real*8,   dimension(:),    intent(out)           :: zaa,zab
    integer*4,dimension(:),    intent(inout)         :: lrow_msk,lcol_msk
    integer*4,dimension(:),    intent(in)            :: ndl_prefix,ndt_prefix
    integer*4,dimension(:),    intent(in)            :: ndlp,ndtp,nstrtlp,nstrttp
    integer*4,dimension(:),    intent(out)           :: ktp
    real*8,                    intent(in)    ,value  :: param61,param64
    integer*4,dimension(:),    intent(in)            :: lod
    integer*4,                 intent(in)    ,value  :: kmax
    real*8,                    intent(in)    ,value  :: eps,znrmmat,pACA_EPS
    ! type :: coordinate
    !    real(8) :: x ,y ,z
    ! end type coordinate
    ! type :: st_HACApK_calc_entry
    !    real*8,pointer :: ao(:)
    !    integer :: nd,lp61
    !    integer :: nond,nofc,number_element_dof,nond_on_face,nint_para_fc,ndble_para_fc
    !    integer,pointer :: int_para_fc(:,:), face2node(:,:)
    !    real*8,pointer  :: dble_para_fc(:,:)
    !    type(coordinate),pointer :: np(:)
       
    !    real*8,pointer :: zx(:),zy(:),zz(:)
    ! end type st_HACApK_calc_entry
    type(st_HACApK_calc_entry),intent(in)            :: st_bemv
    integer*4,dimension(:),    intent(inout)         :: warn,err
    !    real*8,                    intent(in)    ,value  :: inv_4_PI_EPSILON_0
    
    integer*4 :: ndl,ndt,nstrtl,nstrtt,kt,ip,ns,krank,nrow_done,ncol_done,k,lstop_aca,kstop,ist,jst,istn
    integer*4 :: ii,ndk,ill,itt,it,il
    real*8 :: znrm,ACA_EPS,row_maxval,col_maxval,zdltinv,zeps
    real*8 :: zscl,zzz,zza
    
    integer*4 :: n(3),iii,i,j,jj
!    real*8    :: xs(3),ys(3),zs(3),x,y,z,r(3),u(3),v(3),w(3)
    real*8    :: xs(3),ys(3),zs(3),x,y,z
    real*8    :: xst(3),yst(3),zst(3)
    real*8    :: xi, xj, yi, dx, dy, t, l, m, d, ti, tj
    real*8    :: theta, omega, q, g, zp, zpabs, ox,oy,oz
    integer*4 :: zaa_st, zab_st, ndl_pre, ndt_pre
    integer*4 :: tx,dimx,wid,wlen
    real*8    :: dtmp
    integer*4 :: itmp, flag, imsk, txbit
    real*8    :: aoij
    real*8,shared    :: dshared(8)
    integer*4,shared    :: ishared(8)
    ! integer*4,dimension(:,:),  pointer            :: face2node
    ! type(coordinate),dimension(:), pointer         :: np
    ! real*8,   dimension(:),    pointer            :: ao
    integer*4 :: lp61

    !face2node => st_bemv%face2node
    ! np => st_bemv%np
    ! ao => st_bemv%ao
    !lp61 = st_bemv%lp61
         
    ip = st + blockIdx%x - 1
    tx = threadIdx%x
    dimx = blockDim%x
    wid = (tx-1)/32+1
    wlen = dimx/32
    txbit = ishft(1,mod(tx-1,32)) 
    !    do ip=st,en
    !if(tx == 1) print *, lp61

    ndl   =ndlp(ip)   ; ndt   =ndtp(ip)   ; ns=ndl*ndt
    nstrtl=nstrtlp(ip); nstrtt=nstrttp(ip)
    ndl_pre=ndl_prefix(ip)-ndl_prefix(st)+1 ; ndt_pre=ndt_prefix(ip)-ndt_prefix(st)+1
    zaa_st=offset+(ndl_pre-1)*kmax+1 ; zab_st=offset+(ndt_pre-1)*kmax+1
    
    ! write(6,1000) 'nstrtl=',nstrtl,' nstrtt=',nstrtt,' ndl=',ndl,' ndt=',ndt, 'kmax=',kmax
    krank=min(ndl,ndt)
    znrm=znrmmat*sqrt(real(ndl)*real(ndt))
    if(param61==1) ACA_EPS=pACA_EPS
    if(param61==2 .or. param61==3) ACA_EPS=pACA_EPS*znrm
    !lrow_msk(ndl_pre:ndl_pre+ndl-1)=0; lcol_msk(ndt_pre:ndt_pre+ndt-1)=0;
    do il = ndl_pre+tx-1, ndl_pre+(ndl-1)/32+1, dimx
       lrow_msk(il)=0
    enddo
    do it = ndt_pre+tx-1, ndt_pre+(ndt-1)/32+1, dimx
       lcol_msk(it)=0
    enddo
    nrow_done=0; ncol_done=0
    kt=0; k=1; lstop_aca=0
    kstop=min(kmax,krank)
    if(nstrtl>nstrtt)then; ist=1
    else; ist=ndl
    endif
    !      allocate(pcol(ndl),prow(ndt))
    !      do
    do 

       !====================================================================================================
       !         call HACApK_calc_vec(zab, zaa, ndt, k-1, ist, prow, nstrtl, nstrtt,lod, st_bemv, lcol_msk,0) 
       imsk = ndt_pre+wid-1
       do ii=tx,ndt,dimx
          ! if(lcol_msk(ii)==0) then
          if(iand(lcol_msk(imsk),txbit)==0) then
             itt=ii+nstrtt-1; ill=ist+nstrtl-1
             !---------------------------------------------------------------------------------------------------
             zab(zab_st+ndt*(k-1)+ii-1)=HACApK_entry_ij_cuda(lod(ill),lod(itt),st_bemv)

             !---------------------------------------------------------------------------------------------------
          endif
          imsk = imsk + wlen
       enddo
       if(k.ne.1) then
          do il=1,k-1
             do it=tx,ndt,dimx
                zab(zab_st+ndt*(k-1)+it-1)=zab(zab_st+ndt*(k-1)+it-1)-zab(zab_st+ndt*(il-1)+it-1)*zaa(zaa_st+ndl*(il-1)+ist-1)
             enddo
          enddo
          imsk = ndt_pre+wid-1
          do iii=tx,ndt,dimx
             if(iand(lcol_msk(imsk),txbit).ne.0) then
                zab(zab_st+ndt*(k-1)+iii-1)=0.0d0
             endif
             imsk = imsk + wlen
          enddo
       endif
       !====================================================================================================
       !         call HACApK_maxabsvallocm_d(prow,row_maxval,jst,ndt,lcol_msk)
       
       jst = 0; row_maxval = 0.0d0
       
       imsk = ndt_pre+wid-1
       do it=tx,ndt,dimx
          if(iand(lcol_msk(imsk),txbit)==0) then
             dtmp = dabs(zab(zab_st+ndt*(k-1)+it-1))
             if(dtmp > row_maxval)then
                jst = it;
                row_maxval = dtmp
             endif
          endif
          imsk = imsk + wlen
       enddo
       dtmp = __shfl_xor(row_maxval,16)
       itmp = __shfl_xor(jst,16)
       if(dtmp > row_maxval) then
          row_maxval = dtmp
          jst        = itmp
       endif
       dtmp = __shfl_xor(row_maxval,8)
       itmp = __shfl_xor(jst,8)
       if(dtmp > row_maxval) then
          row_maxval = dtmp
          jst        = itmp
       endif
       dtmp = __shfl_xor(row_maxval,4)
       itmp = __shfl_xor(jst,4)
       if(dtmp > row_maxval) then
          row_maxval = dtmp
          jst        = itmp
       endif
       dtmp = __shfl_xor(row_maxval,2)
       itmp = __shfl_xor(jst,2)
       if(dtmp > row_maxval) then
          row_maxval = dtmp
          jst        = itmp
       endif
       dtmp = __shfl_xor(row_maxval,1)
       itmp = __shfl_xor(jst,1)
       if(dtmp > row_maxval) then
          row_maxval = dtmp
          jst        = itmp
       endif
       call syncthreads()
       if(mod(tx,32) == 1) then
          dshared(wid) = row_maxval
          ishared(wid) = jst
       endif
       call syncthreads()
       do i = 1, wlen
          if(dshared(i) > row_maxval) then
             row_maxval = dshared(i)
             jst        = ishared(i)
          endif
       enddo
       call syncthreads()
       
       !====================================================================================================
       !   print*,'jst=',jst,' row_maxval=',row_maxval
       ! write(6,1000) 'ist=',ist,'  jst=',jst
       
       !         zdltinv=1.0d0/prow(jst); prow(:)=prow(:)*zdltinv
       zdltinv=1.0d0/zab(zab_st+ndt*(k-1)+jst-1)
       !       zab(zab_st+ndt*(k-1):zab_st+ndt*k-1)=zab(zab_st+ndt*(k-1):zab_st+ndt*k-1)*zdltinv
       do ii=zab_st+ndt*(k-1)+tx-1,zab_st+ndt*k-1,dimx
          zab(ii)=zab(ii)*zdltinv
       enddo
       
       !         call HACApK_calc_vec(zaa, zab, ndl, k-1, jst, pcol, nstrtl, nstrtt,lod, st_bemv, lrow_msk,1)

       imsk = ndl_pre+wid-1
       do ii=tx,ndl,dimx
          !            if(lrow_msk(ii)==0) then
          if(iand(lrow_msk(imsk),txbit)==0) then
             ill=ii+nstrtl-1; itt=jst+nstrtt-1
             !---------------------------------------------------------------------------------------------------
             zaa(zaa_st+ndl*(k-1)+ii-1)=HACApK_entry_ij_cuda(lod(ill),lod(itt),st_bemv)

             !---------------------------------------------------------------------------------------------------
          endif
          imsk = imsk + wlen
       enddo
       if(k.ne.1) then
          do it=1,k-1
             do il=tx,ndl,dimx
                zaa(zaa_st+ndl*(k-1)+il-1)=zaa(zaa_st+ndl*(k-1)+il-1)-zaa(zaa_st+ndl*(it-1)+il-1)*zab(zab_st+ndt*(it-1)+jst-1)
             enddo
          enddo
          imsk = ndl_pre+wid-1
          do iii=tx,ndl,dimx
             if(iand(lrow_msk(imsk),txbit).ne.0) then
                zaa(zaa_st+ndl*(k-1)+iii-1)=0.0d0
             endif
             imsk = imsk + wlen
          enddo
       endif
       !====================================================================================================
       call syncthreads()
       if(tx == mod(ist-1,32)+1) lrow_msk(ndl_pre+(ist-1)/32)=ior(lrow_msk(ndl_pre+(ist-1)/32),txbit)
       call syncthreads()
       !         call HACApK_maxabsvallocm_d(pcol,col_maxval,istn,ndl,lrow_msk)
       istn = 0; col_maxval = 0.0d0
       imsk = ndl_pre+wid-1
       do it=tx,ndl,dimx
          if(iand(lrow_msk(imsk),txbit)==0) then
             dtmp = dabs(zaa(zaa_st+ndl*(k-1)+it-1))
             if(dtmp > col_maxval)then
                istn = it;
                col_maxval = dtmp
             endif
          endif
          imsk = imsk + wlen
       enddo

       dtmp = __shfl_xor(col_maxval,16)
       itmp = __shfl_xor(istn,16)
       if(dtmp > col_maxval) then
          col_maxval = dtmp
          istn       = itmp
       endif
       dtmp = __shfl_xor(col_maxval,8)
       itmp = __shfl_xor(istn,8)
       if(dtmp > col_maxval) then
          col_maxval = dtmp
          istn       = itmp
       endif
       dtmp = __shfl_xor(col_maxval,4)
       itmp = __shfl_xor(istn,4)
       if(dtmp > col_maxval) then
          col_maxval = dtmp
          istn       = itmp
       endif
       dtmp = __shfl_xor(col_maxval,2)
       itmp = __shfl_xor(istn,2)
       if(dtmp > col_maxval) then
          col_maxval = dtmp
          istn       = itmp
       endif
       dtmp = __shfl_xor(col_maxval,1)
       itmp = __shfl_xor(istn,1)
       if(dtmp > col_maxval) then
          col_maxval = dtmp
          istn       = itmp
       endif
       call syncthreads()
       if(mod(tx,32) == 1) then
          dshared(wid) = col_maxval
          ishared(wid) = istn
       endif
       call syncthreads()
       do i = 1, wlen
          if(dshared(i) > col_maxval) then
             col_maxval = dshared(i)
             istn       = ishared(i)
          endif
       enddo
       call syncthreads()

       !====================================================================================================
       !   print*, 'pcol=',pcol
       !   print *,'zeps=',zeps
       !   print*,'istn=',istn,' col_maxval=',col_maxval
!       if(tx==1) lcol_msk(ndt_pre-1+jst)=1
       call syncthreads()
       if(tx == mod(jst-1,32)+1) lcol_msk(ndt_pre+(jst-1)/32)=ior(lcol_msk(ndt_pre+(jst-1)/32),txbit)
       call syncthreads()
       ist=istn; nrow_done=nrow_done+1; ncol_done=ncol_done+1
       if(abs(row_maxval)<ACA_EPS .and. abs(col_maxval)<ACA_EPS .and. k>=param64) then
          !             !$omp critical
          !             print *, 'ACA_EPS=',ACA_EPS
          !             print *, 'abs(row_maxval)=',abs(row_maxval)
          !             print *, 'abs(col_maxval)=',abs(col_maxval)
          !             print *, 'stop HACApK_aca 3';
          ! !!!     stop
          !             !$omp end critical
          if(tx==1) warn(ip) = 1
          goto 9999
       endif
       !====================================================================================================
       !zeps=HACApK_unrm_d(ndl,pcol)*HACApK_unrm_d(ndt,prow)
       zscl=0.0d0; zzz=1.0d0
       do il=1,ndl
          !            zza=abs(pcol(il))                                                                                                                             
          zza=abs(zaa(zaa_st+ndl*(k-1)+il-1))
          if(zza<1.0d-30) cycle
          if(zscl<zza)then
             zzz=1.0d0+zzz*(zscl/zza)*(zscl/zza)
             zscl=zza
          else
             zzz=zzz+(zza/zscl)*(zza/zscl)
          endif
       enddo
       zeps=zscl*dsqrt(zzz)
       
       zscl=0.0d0; zzz=1.0d0
       do il=1,ndt
          !            zza=abs(prow(il))                                                                                                                             
          zza=abs(zab(zab_st+ndt*(k-1)+il-1))
          if(zza<1.0d-30) cycle
          if(zscl<zza)then
             zzz=1.0d0+zzz*(zscl/zza)*(zscl/zza)
             zscl=zza
          else
             zzz=zzz+(zza/zscl)*(zza/zscl)
          endif
       enddo
       zeps=zeps*zscl*dsqrt(zzz)
       
       !====================================================================================================
       !   zcolm=HACApK_unrm_d(ndl,pcol); zrowm=HACApK_unrm_d(ndt,prow)
       if(k==1 .and. param61==1) znrm=zeps
       zeps=zeps/znrm
       if(zeps<eps .or. k==kstop) lstop_aca = 1
       if(lstop_aca==1 .and. k>=param64) then
          exit
       endif
       !         zaa(zaa_st+ndl*(k-1):zaa_st+ndl*k-1) = pcol(1:ndl); zab(zab_st+ndt*(k-1):zab_st+ndt*k-1) = prow(1:ndt)
       k=k+1
    enddo
    !      zaa(zaa_st+ndl*(k-1):zaa_st+ndl*k-1) = pcol(1:ndl); zab(zab_st+ndt*(k-1):zab_st+ndt*k-1) = prow(1:ndt)
    !      deallocate(pcol,prow)
    
9999 continue
    !      deallocate(lrow_msk,lcol_msk)
    kt=k
    if(zeps>eps .and. k<krank)then
       ! !$omp critical
       ! print *,'k=',k
       ! print *,'zeps=',zeps
       ! print *,'eps=',eps
       ! write(6,1000) 'nstrtl=',nstrtl,' nstrtt=',nstrtt,' ndl=',ndl,' ndt=',ndt
       ! print*,'znrm=',znrm
       ! stop
       ! !$omp end critical
       if(tx==1) err(ip) = 1
    endif
    ! stop
    
    !      deallocate(zab,zaa)
    if(tx==1) ktp(ip)=kt
    !    enddo
  end subroutine HACApK_calc_kt_cuda

  attributes(global) subroutine HACApK_calc_kt_cuda_ufunc                                         &
       (st,en,offset,zaa,zab,lcol_msk,lrow_msk,ndl_prefix,ndt_prefix,ndlp,ndtp,nstrtlp,nstrttp,ktp         &
       ,param61,param64,lod,kmax,eps,znrmmat,pACA_EPS,st_bemv,warn,err)
    use m_HACApK_calc_entry_ij    
    integer*4,                 intent(in)    ,value  :: st,en,offset
    real*8,   dimension(:),    intent(out)           :: zaa,zab
    integer*4,dimension(:),    intent(inout)         :: lrow_msk,lcol_msk
    integer*4,dimension(:),    intent(in)            :: ndl_prefix,ndt_prefix
    integer*4,dimension(:),    intent(in)            :: ndlp,ndtp,nstrtlp,nstrttp
    integer*4,dimension(:),    intent(out)           :: ktp
    real*8,                    intent(in)    ,value  :: param61,param64
    integer*4,dimension(:),    intent(in)            :: lod
    integer*4,                 intent(in)    ,value  :: kmax
    real*8,                    intent(in)    ,value  :: eps,znrmmat,pACA_EPS
    ! type :: coordinate
    !    real(8) :: x ,y ,z
    ! end type coordinate
    ! type :: st_HACApK_calc_entry
    !    real*8,pointer :: ao(:)
    !    integer :: nd,lp61
    !    integer :: nond,nofc,number_element_dof,nond_on_face,nint_para_fc,ndble_para_fc
    !    integer,pointer :: int_para_fc(:,:), face2node(:,:)
    !    real*8,pointer  :: dble_para_fc(:,:)
    !    type(coordinate),pointer :: np(:)
       
    !    real*8,pointer :: zx(:),zy(:),zz(:)
    ! end type st_HACApK_calc_entry
    type(st_HACApK_calc_entry),intent(in)            :: st_bemv
    integer*4,dimension(:),    intent(inout)         :: warn,err
    !    real*8,                    intent(in)    ,value  :: inv_4_PI_EPSILON_0
    
    integer*4 :: ndl,ndt,nstrtl,nstrtt,kt,ip,ns,krank,nrow_done,ncol_done,k,lstop_aca,kstop,ist,jst,istn
    integer*4 :: ii,ndk,ill,itt,it,il
    real*8 :: znrm,ACA_EPS,row_maxval,col_maxval,zdltinv,zeps
    real*8 :: zscl,zzz,zza
    
    integer*4 :: n(3),iii,i,j,jj
!    real*8    :: xs(3),ys(3),zs(3),x,y,z,r(3),u(3),v(3),w(3)
    real*8    :: xs(3),ys(3),zs(3),x,y,z
    real*8    :: xst(3),yst(3),zst(3)
    real*8    :: xi, xj, yi, dx, dy, t, l, m, d, ti, tj
    real*8    :: theta, omega, q, g, zp, zpabs, ox,oy,oz
    integer*4 :: zaa_st, zab_st, ndl_pre, ndt_pre
    integer*4 :: tx,dimx,wid,wlen
    real*8    :: dtmp
    integer*4 :: itmp, flag, imsk, txbit
    real*8    :: aoij
    real*8,shared    :: dshared(8)
    integer*4,shared    :: ishared(8)
    ! integer*4,dimension(:,:),  pointer            :: face2node
    ! type(coordinate),dimension(:), pointer         :: np
    ! real*8,   dimension(:),    pointer            :: ao
    integer*4 :: lp61

    !face2node => st_bemv%face2node
    ! np => st_bemv%np
    ! ao => st_bemv%ao
    !lp61 = st_bemv%lp61
         
    ip = st + blockIdx%x - 1
    tx = threadIdx%x
    dimx = blockDim%x
    wid = (tx-1)/32+1
    wlen = dimx/32
    txbit = ishft(1,mod(tx-1,32)) 
    !    do ip=st,en
    !if(tx == 1) print *, lp61

    ndl   =ndlp(ip)   ; ndt   =ndtp(ip)   ; ns=ndl*ndt
    nstrtl=nstrtlp(ip); nstrtt=nstrttp(ip)
    ndl_pre=ndl_prefix(ip)-ndl_prefix(st)+1 ; ndt_pre=ndt_prefix(ip)-ndt_prefix(st)+1
    zaa_st=offset+(ndl_pre-1)*kmax+1 ; zab_st=offset+(ndt_pre-1)*kmax+1
    
    ! write(6,1000) 'nstrtl=',nstrtl,' nstrtt=',nstrtt,' ndl=',ndl,' ndt=',ndt, 'kmax=',kmax
    krank=min(ndl,ndt)
    znrm=znrmmat*sqrt(real(ndl)*real(ndt))
    if(param61==1) ACA_EPS=pACA_EPS
    if(param61==2 .or. param61==3) ACA_EPS=pACA_EPS*znrm
    !lrow_msk(ndl_pre:ndl_pre+ndl-1)=0; lcol_msk(ndt_pre:ndt_pre+ndt-1)=0;
    do il = ndl_pre+tx-1, ndl_pre+(ndl-1)/32+1, dimx
       lrow_msk(il)=0
    enddo
    do it = ndt_pre+tx-1, ndt_pre+(ndt-1)/32+1, dimx
       lcol_msk(it)=0
    enddo
    nrow_done=0; ncol_done=0
    kt=0; k=1; lstop_aca=0
    kstop=min(kmax,krank)
    if(nstrtl>nstrtt)then; ist=1
    else; ist=ndl
    endif
    !      allocate(pcol(ndl),prow(ndt))
    !      do
    do 

       !====================================================================================================
       !         call HACApK_calc_vec(zab, zaa, ndt, k-1, ist, prow, nstrtl, nstrtt,lod, st_bemv, lcol_msk,0) 
       imsk = ndt_pre+wid-1
       do ii=tx,ndt,dimx
          ! if(lcol_msk(ii)==0) then
          if(iand(lcol_msk(imsk),txbit)==0) then
             itt=ii+nstrtt-1; ill=ist+nstrtl-1
             !---------------------------------------------------------------------------------------------------
             zab(zab_st+ndt*(k-1)+ii-1)=HACApK_entry_ij_cuda(lod(ill),lod(itt),st_bemv)

             !---------------------------------------------------------------------------------------------------
          endif
          imsk = imsk + wlen
       enddo
       if(k.ne.1) then
          do il=1,k-1
             do it=tx,ndt,dimx
                zab(zab_st+ndt*(k-1)+it-1)=zab(zab_st+ndt*(k-1)+it-1)-zab(zab_st+ndt*(il-1)+it-1)*zaa(zaa_st+ndl*(il-1)+ist-1)
             enddo
          enddo
          imsk = ndt_pre+wid-1
          do iii=tx,ndt,dimx
             if(iand(lcol_msk(imsk),txbit).ne.0) then
                zab(zab_st+ndt*(k-1)+iii-1)=0.0d0
             endif
             imsk = imsk + wlen
          enddo
       endif
       !====================================================================================================
       !         call HACApK_maxabsvallocm_d(prow,row_maxval,jst,ndt,lcol_msk)
       
       jst = 0; row_maxval = 0.0d0
       
       imsk = ndt_pre+wid-1
       do it=tx,ndt,dimx
          if(iand(lcol_msk(imsk),txbit)==0) then
             dtmp = dabs(zab(zab_st+ndt*(k-1)+it-1))
             if(dtmp > row_maxval)then
                jst = it;
                row_maxval = dtmp
             endif
          endif
          imsk = imsk + wlen
       enddo
       dtmp = __shfl_xor(row_maxval,16)
       itmp = __shfl_xor(jst,16)
       if(dtmp > row_maxval) then
          row_maxval = dtmp
          jst        = itmp
       endif
       dtmp = __shfl_xor(row_maxval,8)
       itmp = __shfl_xor(jst,8)
       if(dtmp > row_maxval) then
          row_maxval = dtmp
          jst        = itmp
       endif
       dtmp = __shfl_xor(row_maxval,4)
       itmp = __shfl_xor(jst,4)
       if(dtmp > row_maxval) then
          row_maxval = dtmp
          jst        = itmp
       endif
       dtmp = __shfl_xor(row_maxval,2)
       itmp = __shfl_xor(jst,2)
       if(dtmp > row_maxval) then
          row_maxval = dtmp
          jst        = itmp
       endif
       dtmp = __shfl_xor(row_maxval,1)
       itmp = __shfl_xor(jst,1)
       if(dtmp > row_maxval) then
          row_maxval = dtmp
          jst        = itmp
       endif
       call syncthreads()
       if(mod(tx,32) == 1) then
          dshared(wid) = row_maxval
          ishared(wid) = jst
       endif
       call syncthreads()
       do i = 1, wlen
          if(dshared(i) > row_maxval) then
             row_maxval = dshared(i)
             jst        = ishared(i)
          endif
       enddo
       call syncthreads()
       
       !====================================================================================================
       !   print*,'jst=',jst,' row_maxval=',row_maxval
       ! write(6,1000) 'ist=',ist,'  jst=',jst
       
       !         zdltinv=1.0d0/prow(jst); prow(:)=prow(:)*zdltinv
       zdltinv=1.0d0/zab(zab_st+ndt*(k-1)+jst-1)
       !       zab(zab_st+ndt*(k-1):zab_st+ndt*k-1)=zab(zab_st+ndt*(k-1):zab_st+ndt*k-1)*zdltinv
       do ii=zab_st+ndt*(k-1)+tx-1,zab_st+ndt*k-1,dimx
          zab(ii)=zab(ii)*zdltinv
       enddo
       
       !         call HACApK_calc_vec(zaa, zab, ndl, k-1, jst, pcol, nstrtl, nstrtt,lod, st_bemv, lrow_msk,1)

       imsk = ndl_pre+wid-1
       do ii=tx,ndl,dimx
          !            if(lrow_msk(ii)==0) then
          if(iand(lrow_msk(imsk),txbit)==0) then
             ill=ii+nstrtl-1; itt=jst+nstrtt-1
             !---------------------------------------------------------------------------------------------------
             zaa(zaa_st+ndl*(k-1)+ii-1)=HACApK_entry_ij_cuda(lod(ill),lod(itt),st_bemv)

             !---------------------------------------------------------------------------------------------------
          endif
          imsk = imsk + wlen
       enddo
       if(k.ne.1) then
          do it=1,k-1
             do il=tx,ndl,dimx
                zaa(zaa_st+ndl*(k-1)+il-1)=zaa(zaa_st+ndl*(k-1)+il-1)-zaa(zaa_st+ndl*(it-1)+il-1)*zab(zab_st+ndt*(it-1)+jst-1)
             enddo
          enddo
          imsk = ndl_pre+wid-1
          do iii=tx,ndl,dimx
             if(iand(lrow_msk(imsk),txbit).ne.0) then
                zaa(zaa_st+ndl*(k-1)+iii-1)=0.0d0
             endif
             imsk = imsk + wlen
          enddo
       endif
       !====================================================================================================
       call syncthreads()
       if(tx == mod(ist-1,32)+1) lrow_msk(ndl_pre+(ist-1)/32)=ior(lrow_msk(ndl_pre+(ist-1)/32),txbit)
       call syncthreads()
       !         call HACApK_maxabsvallocm_d(pcol,col_maxval,istn,ndl,lrow_msk)
       istn = 0; col_maxval = 0.0d0
       imsk = ndl_pre+wid-1
       do it=tx,ndl,dimx
          if(iand(lrow_msk(imsk),txbit)==0) then
             dtmp = dabs(zaa(zaa_st+ndl*(k-1)+it-1))
             if(dtmp > col_maxval)then
                istn = it;
                col_maxval = dtmp
             endif
          endif
          imsk = imsk + wlen
       enddo

       dtmp = __shfl_xor(col_maxval,16)
       itmp = __shfl_xor(istn,16)
       if(dtmp > col_maxval) then
          col_maxval = dtmp
          istn       = itmp
       endif
       dtmp = __shfl_xor(col_maxval,8)
       itmp = __shfl_xor(istn,8)
       if(dtmp > col_maxval) then
          col_maxval = dtmp
          istn       = itmp
       endif
       dtmp = __shfl_xor(col_maxval,4)
       itmp = __shfl_xor(istn,4)
       if(dtmp > col_maxval) then
          col_maxval = dtmp
          istn       = itmp
       endif
       dtmp = __shfl_xor(col_maxval,2)
       itmp = __shfl_xor(istn,2)
       if(dtmp > col_maxval) then
          col_maxval = dtmp
          istn       = itmp
       endif
       dtmp = __shfl_xor(col_maxval,1)
       itmp = __shfl_xor(istn,1)
       if(dtmp > col_maxval) then
          col_maxval = dtmp
          istn       = itmp
       endif
       call syncthreads()
       if(mod(tx,32) == 1) then
          dshared(wid) = col_maxval
          ishared(wid) = istn
       endif
       call syncthreads()
       do i = 1, wlen
          if(dshared(i) > col_maxval) then
             col_maxval = dshared(i)
             istn       = ishared(i)
          endif
       enddo
       call syncthreads()

       !====================================================================================================
       !   print*, 'pcol=',pcol
       !   print *,'zeps=',zeps
       !   print*,'istn=',istn,' col_maxval=',col_maxval
!       if(tx==1) lcol_msk(ndt_pre-1+jst)=1
       call syncthreads()
       if(tx == mod(jst-1,32)+1) lcol_msk(ndt_pre+(jst-1)/32)=ior(lcol_msk(ndt_pre+(jst-1)/32),txbit)
       call syncthreads()
       ist=istn; nrow_done=nrow_done+1; ncol_done=ncol_done+1
       if(abs(row_maxval)<ACA_EPS .and. abs(col_maxval)<ACA_EPS .and. k>=param64) then
          !             !$omp critical
          !             print *, 'ACA_EPS=',ACA_EPS
          !             print *, 'abs(row_maxval)=',abs(row_maxval)
          !             print *, 'abs(col_maxval)=',abs(col_maxval)
          !             print *, 'stop HACApK_aca 3';
          ! !!!     stop
          !             !$omp end critical
          if(tx==1) warn(ip) = 1
          goto 9999
       endif
       !====================================================================================================
       !zeps=HACApK_unrm_d(ndl,pcol)*HACApK_unrm_d(ndt,prow)
       zzz=0.0d0
       do il=tx,ndl,dimx
          zza = abs(zaa(zaa_st+ndl*(k-1)+il-1))
          zzz = zzz + zza*zza
       enddo
       zzz = zzz + __shfl_xor(zzz,16)
       zzz = zzz + __shfl_xor(zzz,8)
       zzz = zzz + __shfl_xor(zzz,4)
       zzz = zzz + __shfl_xor(zzz,2)
       zzz = zzz + __shfl_xor(zzz,1)
       call syncthreads()
       if(mod(tx,32) == 1) then
          dshared(wid) = zzz
       endif
       call syncthreads()
       zzz = 0.0d0
       do i = 1, dimx/32
          zzz = zzz + dshared(i)
       enddo
       call syncthreads()
       zeps= dsqrt(zzz)

       zzz=0.0d0
       do il=tx,ndt,dimx
          zza = abs(zab(zab_st+ndt*(k-1)+il-1))
          zzz = zzz + zza*zza
       enddo
       zzz = zzz + __shfl_xor(zzz,16)
       zzz = zzz + __shfl_xor(zzz,8)
       zzz = zzz + __shfl_xor(zzz,4)
       zzz = zzz + __shfl_xor(zzz,2)
       zzz = zzz + __shfl_xor(zzz,1)
       call syncthreads()
       if(mod(tx,32) == 1) then
          dshared(wid) = zzz
       endif
       call syncthreads()
       zzz = 0.0d0
       do i = 1, dimx/32
          zzz = zzz + dshared(i)
       enddo
       call syncthreads()
       zeps= zeps*dsqrt(zzz)

       !====================================================================================================
       !   zcolm=HACApK_unrm_d(ndl,pcol); zrowm=HACApK_unrm_d(ndt,prow)
       if(k==1 .and. param61==1) znrm=zeps
       zeps=zeps/znrm
       if(zeps<eps .or. k==kstop) lstop_aca = 1
       if(lstop_aca==1 .and. k>=param64) then
          exit
       endif
       !         zaa(zaa_st+ndl*(k-1):zaa_st+ndl*k-1) = pcol(1:ndl); zab(zab_st+ndt*(k-1):zab_st+ndt*k-1) = prow(1:ndt)
       k=k+1
    enddo
    !      zaa(zaa_st+ndl*(k-1):zaa_st+ndl*k-1) = pcol(1:ndl); zab(zab_st+ndt*(k-1):zab_st+ndt*k-1) = prow(1:ndt)
    !      deallocate(pcol,prow)
    
9999 continue
    !      deallocate(lrow_msk,lcol_msk)
    kt=k
    if(zeps>eps .and. k<krank)then
       ! !$omp critical
       ! print *,'k=',k
       ! print *,'zeps=',zeps
       ! print *,'eps=',eps
       ! write(6,1000) 'nstrtl=',nstrtl,' nstrtt=',nstrtt,' ndl=',ndl,' ndt=',ndt
       ! print*,'znrm=',znrm
       ! stop
       ! !$omp end critical
       if(tx==1) err(ip) = 1
    endif
    ! stop
    
    !      deallocate(zab,zaa)
    if(tx==1) ktp(ip)=kt
    !    enddo
  end subroutine HACApK_calc_kt_cuda_ufunc


  attributes(global) subroutine HACApK_calc_kt_cuda_ufunc2                                                 &
       (st,en,offset,zaa,zab,lcol_msk,lrow_msk,ndl_prefix,ndt_prefix,ndlp,ndtp,nstrtlp,nstrttp,ktp         &
       ,param61,param64,lod,kmax,eps,znrmmat,pACA_EPS,st_bemv,warn,err)
    use m_HACApK_calc_entry_ij    
    integer*4,                 intent(in)    ,value  :: st,en,offset
    real*8,   dimension(:),    intent(out)           :: zaa,zab
    integer*4,dimension(:),    intent(inout)         :: lrow_msk,lcol_msk
    integer*4,dimension(:),    intent(in)            :: ndl_prefix,ndt_prefix
    integer*4,dimension(:),    intent(in)            :: ndlp,ndtp,nstrtlp,nstrttp
    integer*4,dimension(:),    intent(out)           :: ktp
    real*8,                    intent(in)    ,value  :: param61,param64
    integer*4,dimension(:),    intent(in)            :: lod
    integer*4,                 intent(in)    ,value  :: kmax
    real*8,                    intent(in)    ,value  :: eps,znrmmat,pACA_EPS
    type(st_HACApK_calc_entry),intent(in)            :: st_bemv
    integer*4,dimension(:),    intent(inout)         :: warn,err
    !    real*8,                    intent(in)    ,value  :: inv_4_PI_EPSILON_0
    
    integer*4 :: ndl,ndt,nstrtl,nstrtt,kt,ip,ns,krank,nrow_done,ncol_done,k,lstop_aca,kstop,ist,jst,istn
    integer*4 :: ii,ndk,ill,itt,it,il
    real*8 :: znrm,ACA_EPS,row_maxval,col_maxval,zdltinv,zeps
    real*8 :: zscl,zzz,zza
    
    integer*4 :: n(3),iii,i,j,jj
!    real*8    :: xs(3),ys(3),zs(3),x,y,z,r(3),u(3),v(3),w(3)
    real*8    :: xs(3),ys(3),zs(3),x,y,z
    real*8    :: xst(3),yst(3),zst(3)
    real*8    :: xi, xj, yi, dx, dy, t, l, m, d, ti, tj
    real*8    :: theta, omega, q, g, zp, zpabs, ox,oy,oz
    integer*4 :: zaa_st, zab_st, ndl_pre, ndt_pre
    integer*4 :: tx,dimx,wid,wlen
    real*8    :: dtmp
    integer*4 :: itmp, flag, imsk, txbit
    real*8    :: aoij
    real*8,shared    :: dshared(8)
    integer*4,shared    :: ishared(8)

    !face2node => st_bemv%face2node
    ! np => st_bemv%np
    ! ao => st_bemv%ao
    !lp61 = st_bemv%lp61
         
    ip = st + blockIdx%x - 1
    tx = threadIdx%x
    dimx = blockDim%x
    wid = (tx-1)/32+1
    wlen = dimx/32
    txbit = ishft(1,mod(tx-1,32)) 
    !    do ip=st,en
    !if(tx == 1) print *, lp61

    ndl   =ndlp(ip)   ; ndt   =ndtp(ip)   ; ns=ndl*ndt
    nstrtl=nstrtlp(ip); nstrtt=nstrttp(ip)
    ndl_pre=ndl_prefix(ip)-ndl_prefix(st)+1 ; ndt_pre=ndt_prefix(ip)-ndt_prefix(st)+1
    zaa_st=offset+(ndl_pre-1)*kmax+1 ; zab_st=offset+(ndt_pre-1)*kmax+1
    
    ! write(6,1000) 'nstrtl=',nstrtl,' nstrtt=',nstrtt,' ndl=',ndl,' ndt=',ndt, 'kmax=',kmax
    krank=min(ndl,ndt)
    znrm=znrmmat*sqrt(real(ndl)*real(ndt))
    if(param61==1) ACA_EPS=pACA_EPS
    if(param61==2 .or. param61==3) ACA_EPS=pACA_EPS*znrm
    !lrow_msk(ndl_pre:ndl_pre+ndl-1)=0; lcol_msk(ndt_pre:ndt_pre+ndt-1)=0;
    do il = ndl_pre+tx-1, ndl_pre+(ndl-1)/32+1, dimx
       lrow_msk(il)=0
    enddo
    do it = ndt_pre+tx-1, ndt_pre+(ndt-1)/32+1, dimx
       lcol_msk(it)=0
    enddo
    nrow_done=0; ncol_done=0
    kt=0; k=1; lstop_aca=0
    kstop=min(kmax,krank)
    if(nstrtl>nstrtt)then; ist=1
    else; ist=ndl
    endif
    !      allocate(pcol(ndl),prow(ndt))
    !      do
    do 

       !====================================================================================================
       !         call HACApK_calc_vec(zab, zaa, ndt, k-1, ist, prow, nstrtl, nstrtt,lod, st_bemv, lcol_msk,0) 
       imsk = ndt_pre+wid-1
       do ii=tx,ndt,dimx
          ! if(lcol_msk(ii)==0) then
          if(iand(lcol_msk(imsk),txbit)==0) then
             itt=ii+nstrtt-1; ill=ist+nstrtl-1
             !---------------------------------------------------------------------------------------------------
             zab(zab_st+ndt*(k-1)+ii-1)=HACApK_entry_ij_cuda2(lod(ill),lod(itt),st_bemv)

             !---------------------------------------------------------------------------------------------------
          endif
          imsk = imsk + wlen
       enddo
       if(k.ne.1) then
          do il=1,k-1
             do it=tx,ndt,dimx
                zab(zab_st+ndt*(k-1)+it-1)=zab(zab_st+ndt*(k-1)+it-1)-zab(zab_st+ndt*(il-1)+it-1)*zaa(zaa_st+ndl*(il-1)+ist-1)
             enddo
          enddo
          imsk = ndt_pre+wid-1
          do iii=tx,ndt,dimx
             if(iand(lcol_msk(imsk),txbit).ne.0) then
                zab(zab_st+ndt*(k-1)+iii-1)=0.0d0
             endif
             imsk = imsk + wlen
          enddo
       endif
       !====================================================================================================
       !         call HACApK_maxabsvallocm_d(prow,row_maxval,jst,ndt,lcol_msk)
       
       jst = 0; row_maxval = 0.0d0
       
       imsk = ndt_pre+wid-1
       do it=tx,ndt,dimx
          if(iand(lcol_msk(imsk),txbit)==0) then
             dtmp = dabs(zab(zab_st+ndt*(k-1)+it-1))
             if(dtmp > row_maxval)then
                jst = it;
                row_maxval = dtmp
             endif
          endif
          imsk = imsk + wlen
       enddo
       dtmp = __shfl_xor(row_maxval,16)
       itmp = __shfl_xor(jst,16)
       if(dtmp > row_maxval) then
          row_maxval = dtmp
          jst        = itmp
       endif
       dtmp = __shfl_xor(row_maxval,8)
       itmp = __shfl_xor(jst,8)
       if(dtmp > row_maxval) then
          row_maxval = dtmp
          jst        = itmp
       endif
       dtmp = __shfl_xor(row_maxval,4)
       itmp = __shfl_xor(jst,4)
       if(dtmp > row_maxval) then
          row_maxval = dtmp
          jst        = itmp
       endif
       dtmp = __shfl_xor(row_maxval,2)
       itmp = __shfl_xor(jst,2)
       if(dtmp > row_maxval) then
          row_maxval = dtmp
          jst        = itmp
       endif
       dtmp = __shfl_xor(row_maxval,1)
       itmp = __shfl_xor(jst,1)
       if(dtmp > row_maxval) then
          row_maxval = dtmp
          jst        = itmp
       endif
       call syncthreads()
       if(mod(tx,32) == 1) then
          dshared(wid) = row_maxval
          ishared(wid) = jst
       endif
       call syncthreads()
       do i = 1, wlen
          if(dshared(i) > row_maxval) then
             row_maxval = dshared(i)
             jst        = ishared(i)
          endif
       enddo
       call syncthreads()
       
       !====================================================================================================
       !   print*,'jst=',jst,' row_maxval=',row_maxval
       ! write(6,1000) 'ist=',ist,'  jst=',jst
       
       !         zdltinv=1.0d0/prow(jst); prow(:)=prow(:)*zdltinv
       zdltinv=1.0d0/zab(zab_st+ndt*(k-1)+jst-1)
       !       zab(zab_st+ndt*(k-1):zab_st+ndt*k-1)=zab(zab_st+ndt*(k-1):zab_st+ndt*k-1)*zdltinv
       do ii=zab_st+ndt*(k-1)+tx-1,zab_st+ndt*k-1,dimx
          zab(ii)=zab(ii)*zdltinv
       enddo
       
       !         call HACApK_calc_vec(zaa, zab, ndl, k-1, jst, pcol, nstrtl, nstrtt,lod, st_bemv, lrow_msk,1)

       imsk = ndl_pre+wid-1
       do ii=tx,ndl,dimx
          !            if(lrow_msk(ii)==0) then
          if(iand(lrow_msk(imsk),txbit)==0) then
             ill=ii+nstrtl-1; itt=jst+nstrtt-1
             !---------------------------------------------------------------------------------------------------
             zaa(zaa_st+ndl*(k-1)+ii-1)=HACApK_entry_ij_cuda2(lod(ill),lod(itt),st_bemv)

             !---------------------------------------------------------------------------------------------------
          endif
          imsk = imsk + wlen
       enddo
       if(k.ne.1) then
          do it=1,k-1
             do il=tx,ndl,dimx
                zaa(zaa_st+ndl*(k-1)+il-1)=zaa(zaa_st+ndl*(k-1)+il-1)-zaa(zaa_st+ndl*(it-1)+il-1)*zab(zab_st+ndt*(it-1)+jst-1)
             enddo
          enddo
          imsk = ndl_pre+wid-1
          do iii=tx,ndl,dimx
             if(iand(lrow_msk(imsk),txbit).ne.0) then
                zaa(zaa_st+ndl*(k-1)+iii-1)=0.0d0
             endif
             imsk = imsk + wlen
          enddo
       endif
       !====================================================================================================
       call syncthreads()
       if(tx == mod(ist-1,32)+1) lrow_msk(ndl_pre+(ist-1)/32)=ior(lrow_msk(ndl_pre+(ist-1)/32),txbit)
       call syncthreads()
       !         call HACApK_maxabsvallocm_d(pcol,col_maxval,istn,ndl,lrow_msk)
       istn = 0; col_maxval = 0.0d0
       imsk = ndl_pre+wid-1
       do it=tx,ndl,dimx
          if(iand(lrow_msk(imsk),txbit)==0) then
             dtmp = dabs(zaa(zaa_st+ndl*(k-1)+it-1))
             if(dtmp > col_maxval)then
                istn = it;
                col_maxval = dtmp
             endif
          endif
          imsk = imsk + wlen
       enddo

       dtmp = __shfl_xor(col_maxval,16)
       itmp = __shfl_xor(istn,16)
       if(dtmp > col_maxval) then
          col_maxval = dtmp
          istn       = itmp
       endif
       dtmp = __shfl_xor(col_maxval,8)
       itmp = __shfl_xor(istn,8)
       if(dtmp > col_maxval) then
          col_maxval = dtmp
          istn       = itmp
       endif
       dtmp = __shfl_xor(col_maxval,4)
       itmp = __shfl_xor(istn,4)
       if(dtmp > col_maxval) then
          col_maxval = dtmp
          istn       = itmp
       endif
       dtmp = __shfl_xor(col_maxval,2)
       itmp = __shfl_xor(istn,2)
       if(dtmp > col_maxval) then
          col_maxval = dtmp
          istn       = itmp
       endif
       dtmp = __shfl_xor(col_maxval,1)
       itmp = __shfl_xor(istn,1)
       if(dtmp > col_maxval) then
          col_maxval = dtmp
          istn       = itmp
       endif
       call syncthreads()
       if(mod(tx,32) == 1) then
          dshared(wid) = col_maxval
          ishared(wid) = istn
       endif
       call syncthreads()
       do i = 1, wlen
          if(dshared(i) > col_maxval) then
             col_maxval = dshared(i)
             istn       = ishared(i)
          endif
       enddo
       call syncthreads()

       !====================================================================================================
       !   print*, 'pcol=',pcol
       !   print *,'zeps=',zeps
       !   print*,'istn=',istn,' col_maxval=',col_maxval
!       if(tx==1) lcol_msk(ndt_pre-1+jst)=1
       call syncthreads()
       if(tx == mod(jst-1,32)+1) lcol_msk(ndt_pre+(jst-1)/32)=ior(lcol_msk(ndt_pre+(jst-1)/32),txbit)
       call syncthreads()
       ist=istn; nrow_done=nrow_done+1; ncol_done=ncol_done+1
       if(abs(row_maxval)<ACA_EPS .and. abs(col_maxval)<ACA_EPS .and. k>=param64) then
          !             !$omp critical
          !             print *, 'ACA_EPS=',ACA_EPS
          !             print *, 'abs(row_maxval)=',abs(row_maxval)
          !             print *, 'abs(col_maxval)=',abs(col_maxval)
          !             print *, 'stop HACApK_aca 3';
          ! !!!     stop
          !             !$omp end critical
          if(tx==1) warn(ip) = 1
          goto 9999
       endif
       !====================================================================================================
       !zeps=HACApK_unrm_d(ndl,pcol)*HACApK_unrm_d(ndt,prow)
       zzz=0.0d0
       do il=tx,ndl,dimx
          zza = abs(zaa(zaa_st+ndl*(k-1)+il-1))
          zzz = zzz + zza*zza
       enddo
       zzz = zzz + __shfl_xor(zzz,16)
       zzz = zzz + __shfl_xor(zzz,8)
       zzz = zzz + __shfl_xor(zzz,4)
       zzz = zzz + __shfl_xor(zzz,2)
       zzz = zzz + __shfl_xor(zzz,1)
       call syncthreads()
       if(mod(tx,32) == 1) then
          dshared(wid) = zzz
       endif
       call syncthreads()
       zzz = 0.0d0
       do i = 1, dimx/32
          zzz = zzz + dshared(i)
       enddo
       call syncthreads()
       zeps= dsqrt(zzz)

       zzz=0.0d0
       do il=tx,ndt,dimx
          zza = abs(zab(zab_st+ndt*(k-1)+il-1))
          zzz = zzz + zza*zza
       enddo
       zzz = zzz + __shfl_xor(zzz,16)
       zzz = zzz + __shfl_xor(zzz,8)
       zzz = zzz + __shfl_xor(zzz,4)
       zzz = zzz + __shfl_xor(zzz,2)
       zzz = zzz + __shfl_xor(zzz,1)
       call syncthreads()
       if(mod(tx,32) == 1) then
          dshared(wid) = zzz
       endif
       call syncthreads()
       zzz = 0.0d0
       do i = 1, dimx/32
          zzz = zzz + dshared(i)
       enddo
       call syncthreads()
       zeps= zeps*dsqrt(zzz)

       !====================================================================================================
       !   zcolm=HACApK_unrm_d(ndl,pcol); zrowm=HACApK_unrm_d(ndt,prow)
       if(k==1 .and. param61==1) znrm=zeps
       zeps=zeps/znrm
       if(zeps<eps .or. k==kstop) lstop_aca = 1
       if(lstop_aca==1 .and. k>=param64) then
          exit
       endif
       !         zaa(zaa_st+ndl*(k-1):zaa_st+ndl*k-1) = pcol(1:ndl); zab(zab_st+ndt*(k-1):zab_st+ndt*k-1) = prow(1:ndt)
       k=k+1
    enddo
    !      zaa(zaa_st+ndl*(k-1):zaa_st+ndl*k-1) = pcol(1:ndl); zab(zab_st+ndt*(k-1):zab_st+ndt*k-1) = prow(1:ndt)
    !      deallocate(pcol,prow)
    
9999 continue
    !      deallocate(lrow_msk,lcol_msk)
    kt=k
    if(zeps>eps .and. k<krank)then
       ! !$omp critical
       ! print *,'k=',k
       ! print *,'zeps=',zeps
       ! print *,'eps=',eps
       ! write(6,1000) 'nstrtl=',nstrtl,' nstrtt=',nstrtt,' ndl=',ndl,' ndt=',ndt
       ! print*,'znrm=',znrm
       ! stop
       ! !$omp end critical
       if(tx==1) err(ip) = 1
    endif
    ! stop
    
    !      deallocate(zab,zaa)
    if(tx==1) ktp(ip)=kt
    !    enddo
  end subroutine HACApK_calc_kt_cuda_ufunc2



  attributes(global) subroutine a1_a2_copy2                                                          &
       (st,en,offset,zaa,zab,ndl_prefix,ndt_prefix,ndlp,ndtp,nstrtlp,nstrttp,ktp,idxp1,idxp2,kmax,a1,a2)  

    integer*4,                 intent(in)    ,value  :: st,en,kmax,offset
    real*8,   dimension(:),    intent(out)           :: zaa,zab
    integer*4,dimension(:),    intent(in)            :: ndl_prefix,ndt_prefix
    integer*4,dimension(:),    intent(in)            :: ndlp,ndtp,nstrtlp,nstrttp
    integer*4,dimension(:),    intent(out)           :: ktp,idxp1,idxp2
    real*8   ,dimension(:),    intent(inout)         :: a1,a2
    integer*4                                        :: a1_st,a2_st,ndl,ndt,kt
    integer*4                                        :: zaa_st,zab_st
    integer*4                                        :: ii,tx,dimx,i,j
    ii = st + blockIdx%x - 1
    tx = threadIdx%x
    dimx = blockDim%x

    a1_st = idxp1(ii)
    a2_st = idxp2(ii)
    ndl   =ndlp(ii)   ; ndt   =ndtp(ii)
    kt    =ktp(ii)
    zaa_st=(ndl_prefix(ii)-ndl_prefix(st))*kmax+1 ; zab_st=(ndt_prefix(ii)-ndt_prefix(st))*kmax+1
    
    do j = 1, kt
       do i = tx, ndt, dimx
          a1(a1_st-1+i+(j-1)*ndt) = zab(offset + zab_st + i-1 + (j-1)*ndt)
       enddo
       do i = tx, ndl, dimx
          a2(a2_st-1+i+(j-1)*ndl) = zaa(offset + zaa_st + i-1 + (j-1)*ndl)
       enddo
    enddo
  end subroutine a1_a2_copy2


  attributes(global) subroutine a1_a2_copy                                                          &
       (st,en,zaa,zab,ndl_prefix,ndt_prefix,ndlp,ndtp,nstrtlp,nstrttp,ktp,idxp1,idxp2,kmax,a1,a2)  

    integer*4,                 intent(in)    ,value  :: st,en,kmax
    real*8,   dimension(:),    intent(out)           :: zaa,zab
    integer*4,dimension(:),    intent(in)            :: ndl_prefix,ndt_prefix
    integer*4,dimension(:),    intent(in)            :: ndlp,ndtp,nstrtlp,nstrttp
    integer*4,dimension(:),    intent(out)           :: ktp,idxp1,idxp2
    real*8   ,dimension(:),    intent(inout)         :: a1,a2
    integer*4                                        :: a1_st,a2_st,ndl,ndt,kt
    integer*4                                        :: zaa_st,zab_st
    integer*4                                        :: ii,tx,dimx,i,j
    ii = st + blockIdx%x - 1
    tx = threadIdx%x
    dimx = blockDim%x

    a1_st = idxp1(ii)
    a2_st = idxp2(ii)
    ndl   =ndlp(ii)   ; ndt   =ndtp(ii)
    kt    =ktp(ii)
    zaa_st=(ndl_prefix(ii)-ndl_prefix(st))*kmax+1 ; zab_st=(ndt_prefix(ii)-ndt_prefix(st))*kmax+1
    
    do j = 1, kt
       do i = tx, ndt, dimx
          a1(a1_st-1+i+(j-1)*ndt) = zab(zab_st + i-1 + (j-1)*ndt)
       enddo
       do i = tx, ndl, dimx
          a2(a2_st-1+i+(j-1)*ndl) = zaa(zaa_st + i-1 + (j-1)*ndl)
       enddo
    enddo
  end subroutine a1_a2_copy
#endif


  subroutine HACApK_aca_cuda_opt8                                                                        &
       (zab,zaa,a3,ndl_prefix,ndt_prefix,ndlp,ndtp,nstrtlp,nstrttp,ktp,b_prefix,a_prefix,b_strk,a_strk,idxp3      &
       ,param,lod,kmax,eps,znrmmat,pACA_EPS,face2node,lp61,ao,np,warn,err,n_low,n_dense,kernel_time,mpinr,numOfDev,ndt_max_dense)
       include 'mpif.h'
    real*8,   dimension(:),    intent(out),   device :: a3,zaa,zab
    integer*4,dimension(:),    intent(in),    device :: ndl_prefix,ndt_prefix
    integer*4,dimension(:),    intent(in),    device :: ndlp,ndtp,nstrtlp,nstrttp
    integer*4,dimension(:),    intent(out),   device :: ktp
    integer*4,dimension(:,:),  intent(out),   device :: a_prefix,b_prefix !idxp1,idxp2
    integer*4,dimension(:),    intent(out),   device :: a_strk,b_strk
    integer*4,dimension(:),    intent(out),   device :: idxp3
    real*8,                    intent(in)            :: param(:)
    integer*4,                 intent(in),    device :: lod(:)
    integer*4,                 intent(inout)         :: kmax
    real*8,                    intent(in)            :: eps,znrmmat,pACA_EPS
    integer*4,dimension(:,:),  intent(in),    device :: face2node
    real*8,   dimension(:,:),  intent(in),    device :: np
    real*8,   dimension(:),    intent(in),    device :: ao
    integer*4,                 intent(in)            :: lp61
    integer*4,dimension(:),    intent(inout), device :: warn,err
    integer*4,                 intent(in)            :: n_low,n_dense
    real*8,                    intent(out)           :: kernel_time
    integer*4,                 intent(in)            :: mpinr,numOfDev,ndt_max_dense

    type(dim3)                                       :: dimGrid, dimBlock, dimGrid_nlow, dimBlock128
    type(dim3)                                       :: dimGrid_prefix1, dimBlock_prefix1
    type(dim3)                                       :: dimGrid_prefix2, dimBlock_prefix2
    type(dim3)                                       :: dimGrid_prefix3, dimBlock_prefix3
    real*8                                           :: param61, param64
    integer*8                                        :: mem_ab,mem_aa
    integer*4                                        :: st,en,i,ip,pi,ts,ne
    real*8                                           :: st_measure_time, en_measure_time
    integer*4, dimension(:),allocatable              :: ktp_cpu,ndtp_cpu,ndlp_cpu
    integer*4                                        :: idx1,idx2,ii,ndl,ndt,kt,istat,offset,sw
    integer(kind=cuda_stream_kind)                   :: stream1, stream2
    real*8                                           :: flop1,flop2,flop3,dbyte,ibyte

    real*8,   dimension(:),allocatable               :: zaa_cpu,zab_cpu
!    integer*4,dimension(:,:),allocatable     ,device :: a_prefix,b_prefix
!    integer*4,dimension(:),allocatable       ,device :: a_strk,b_strk

    integer*4, dimension(:,:),allocatable      ,device :: isnt_finished
    integer*4, dimension(:,:),allocatable      ,device :: notConvergedBlocks
    integer*4, dimension(:),allocatable      ,device :: blockIdIdx
    integer*4, dimension(:),allocatable      ,device :: kstop
    integer*4, dimension(:),allocatable              :: kstop_cpu
    integer*4, dimension(:),allocatable      ,device :: leafist,leafjst
    integer*4, dimension(:),allocatable              :: leafpib_cpu
    integer*4, dimension(:),allocatable      ,device :: subidl,subidt,subidd
    integer*4, dimension(:),allocatable              :: subidl_cpu,subidt_cpu
    integer*4, dimension(:),allocatable              :: isnt_finished_cpu
    integer*4, dimension(:),allocatable              :: a_prefix_cpu, b_prefix_cpu
    integer*4, dimension(:),allocatable      ,device :: lrow_msk,lcol_msk
    integer*4, dimension(:),allocatable              :: lrow_msk_cpu,lcol_msk_cpu
    real*8   , dimension(:,:),allocatable    ,device :: xsyszs
    real*8   , dimension(:,:),allocatable    ,device :: xyz
    real*8   , dimension(:),allocatable      ,device :: ao2
    real*8   , dimension(:),allocatable      ,device :: row_maxval,col_maxval
    real*8   , dimension(:),allocatable      ,device :: znrms
    integer*4, dimension(:,:),allocatable    ,device :: a_prefix_tmp,b_prefix_tmp
    integer*4, dimension(:),allocatable              :: idxp1_cpu,idxp2_cpu
    real*8   , dimension(:),allocatable              :: a1_cpu
    integer*4                                ,device :: lenl,lent,lend,lenb
    integer*4, dimension(:),allocatable      ,device :: itmp1D_gpu1,itmp1D_gpu2
    integer*4, dimension(:),allocatable              :: itmp1D_cpu1,itmp1D_cpu2
    integer*4                                        :: nd,lenl_cpu,lent_cpu,lend_cpu,preloclen,preloclen2
    integer*4, dimension(:),allocatable              :: nstrtlp_cpu,nstrttp_cpu
    integer*4, dimension(:),allocatable      ,device :: idx3_tmp
    integer*4 :: a_sum, b_sum, numNotConverged, sw1,sw2
    real*8    :: dtmp


    allocate(isnt_finished(n_low,2))
    allocate(blockIdIdx(n_low+1))
    !    allocate(isnt_finished_cpu(n_low))
    allocate(kstop(n_low))
    ! allocate(kstop_cpu(n_low))

    ! allocate(ktp_cpu(size(ktp)))
    ! allocate(ndtp_cpu(size(ndtp)))
    ! allocate(ndlp_cpu(size(ndlp)))
    ! allocate(idxp1_cpu(size(idxp1)))
    ! allocate(idxp2_cpu(size(idxp2)))

    nd = size(lod)
!    print *, "nd", nd
    allocate(xsyszs(nd,9))
    allocate(xyz(nd,3))
    allocate(ao2(nd))
    allocate(leafist(n_low))
    allocate(leafjst(n_low))
    allocate(leafpib_cpu(n_low))
    allocate(row_maxval(n_low))
    allocate(col_maxval(n_low))
    allocate(znrms(n_low))
    allocate(notConvergedBlocks(n_low,2))

    ! allocate(a_strk(kmax+1))
    ! allocate(b_strk(kmax+1))
    a_strk(1) = 1; b_strk(1) = 1
    ! allocate(a_prefix(n_low+1,kmax+1))
    ! allocate(b_prefix(n_low+1,kmax+1))
    istat = cudaStreamCreate(stream1)
    istat = cudaStreamCreate(stream2)

    param61 = param(61)
    param64 = param(64)

    ! isnt_finished_cpu(:) = 1
    ! isnt_finished(:) = isnt_finished_cpu(:)
    kernel_time = 0.0d0

    numNotConverged = n_low
    sw1 = 1
    sw2 = 2

    dimGrid_nlow  = dim3(n_low,1,1)
    dimBlock128   = dim3(128,1,1)

    dimGrid  = dim3((nd-1)/128+1,1,1)
    dimBlock = dim3(128,1,1)
    call pre_calc_vec2<<<dimGrid,dimBlock>>>(xyz,xsyszs,ao2,ao,lod,face2node,np,nd,lp61,size(face2node,2),size(np,2))

    dimGrid  = dim3((n_low-1)/128+1,1,1)
    dimBlock = dim3(128,1,1)
!    call init_leafval2 <<<dimGrid,dimBlock>>>(znrms,leafist,isnt_finished,kstop,znrmmat,ndlp,ndtp,nstrtlp,nstrttp,n_low,kmax)
    call init_leafval3 <<<dimGrid,dimBlock>>>(znrms,leafist,isnt_finished,kstop,znrmmat,ndlp,ndtp,nstrtlp,nstrttp,n_low,kmax,notConvergedBlocks)
    allocate(itmp1D_gpu1((n_low-1)/128+1))
    allocate(itmp1D_gpu2((n_low-1)/128+1))
    call calc_length_pre <<<dimGrid,dimBlock>>>(itmp1D_gpu1,itmp1D_gpu2,ndlp,ndtp,n_low,(n_low-1)/128+1)
    dimGrid  = dim3(1,1,1)
    dimBlock = dim3(512,1,1)
    call calc_length_post<<<dimGrid,dimBlock>>>(lenl,lent,itmp1D_gpu1,itmp1D_gpu2,(n_low-1)/128+1)
    deallocate(itmp1D_gpu1)
    deallocate(itmp1D_gpu2)
    lenl_cpu = lenl
    lent_cpu = lent
    allocate(lrow_msk(lenl_cpu))
    allocate(lcol_msk(lent_cpu))
    dimGrid  = dim3((lent_cpu-1)/128+1,1,1)
    dimBlock = dim3(128,1,1)
    call init_msk <<<dimGrid,dimBlock>>>(lcol_msk,lent_cpu)
    dimGrid  = dim3((lenl_cpu-1)/128+1,1,1)
    dimBlock = dim3(128,1,1)
    call init_msk <<<dimGrid,dimBlock>>>(lrow_msk,lenl_cpu)

    allocate(a_prefix_tmp(1:n_low+1,2))
    allocate(b_prefix_tmp(1:n_low+1,2))
    allocate(subidl(lenl_cpu))
    allocate(subidt(lent_cpu))

    preloclen = ((n_low-1)/512+1-1)/32+1
    dimGrid_prefix1  = dim3(512,1,1)
    dimBlock_prefix1 = dim3(32,1,1)
    dimGrid_prefix2  = dim3(1,1,1)
    dimBlock_prefix2 = dim3(512,1,1)
    
!    print *, "preloclen", preloclen
    allocate(itmp1D_gpu1(512))
    do kt = 1, kmax

       preloclen2 = ((numNotConverged-1)/512+1-1)/32+1
       call create_blockid_pre <<<dimGrid_prefix1,dimBlock_prefix1>>>(blockIdIdx,itmp1D_gpu1,isnt_finished(:,1),numNotConverged+1,512,preloclen2)
       call create_blockid_mid <<<dimGrid_prefix2,dimBlock_prefix2>>>(itmp1D_gpu1,512)
       call create_blockid_post<<<dimGrid_prefix1,dimBlock_prefix1>>>(blockIdIdx,lenb,itmp1D_gpu1,numNotConverged+1,512,preloclen2)


       ! allocate(isnt_finished_cpu(n_low))
       ! allocate(itmp1D_cpu1(n_low))
       ! isnt_finished_cpu(1:n_low) = isnt_finished(1:n_low,1)
       ! itmp1D_cpu1(1:n_low)       = blockIdIdx(1:n_low)
       ! do i = 1, numNotConverged
       !    print *, i, itmp1D_cpu1(i),isnt_finished_cpu(i)
       ! end do
       ! deallocate(itmp1D_cpu1)
       ! deallocate(isnt_finished_cpu)

       dimGrid  = dim3((numNotConverged-1)/128+1,1,1)
       dimBlock = dim3(128,1,1)
       call create_blockid<<<dimGrid,dimBlock>>>(notConvergedBlocks(:,sw2),notConvergedBlocks(:,sw1),isnt_finished(:,1),blockIdIdx,numNotConverged,n_low)

       ! call opt_prefix_sum_pre<<<dimGrid_prefix1,dimBlock_prefix1>>>(a_prefix(:,kt),b_prefix(:,kt),a_prefix_tmp(:,2),b_prefix_tmp(:,2),ndlp,ndtp,isnt_finished,n_low+1,n_low/32+1,preloclen)
       ! call opt_prefix_sum_mid<<<dimGrid_prefix2,dimBlock_prefix2>>>(a_prefix_tmp(:,2),b_prefix_tmp(:,2),n_low/(32*preloclen)+1)
       ! call opt_prefix_sum_post<<<dimGrid_prefix1,dimBlock_prefix1>>>(a_prefix(:,kt),b_prefix(:,kt),lenl,lent,a_strk,b_strk,a_prefix_tmp(:,2),b_prefix_tmp(:,2),n_low+1,n_low/32+1,kt,preloclen)
       call opt_prefix_sum_pre<<<dimGrid_prefix1,dimBlock_prefix1>>>(a_prefix(:,kt),b_prefix(:,kt),a_prefix_tmp(:,2),b_prefix_tmp(:,2),ndlp,ndtp,isnt_finished(:,2),n_low+1,n_low/32+1,preloclen)
       call opt_prefix_sum_mid<<<dimGrid_prefix2,dimBlock_prefix2>>>(a_prefix_tmp(:,2),b_prefix_tmp(:,2),n_low/(32*preloclen)+1)
       call opt_prefix_sum_post<<<dimGrid_prefix1,dimBlock_prefix1>>>(a_prefix(:,kt),b_prefix(:,kt),lenl,lent,a_strk,b_strk,a_prefix_tmp(:,2),b_prefix_tmp(:,2),n_low+1,n_low/32+1,kt,preloclen)

       lenl_cpu = lenl-1
       lent_cpu = lent-1
       numNotConverged = lenb-1
#define DEBUG 0
#if DEBUG==1
       print *, "length gpu", lenl_cpu, lent_cpu, kt, numNotConverged, "test"
#endif

       ! allocate(itmp1D_cpu1(n_low))
       ! itmp1D_cpu1(1:n_low)       = notConvergedBlocks(1:n_low,sw2)
       ! do i = 1, numNotConverged
       !    print *, "gblockId",i, itmp1D_cpu1(i)
       ! end do
       ! deallocate(itmp1D_cpu1)

       if(lenl_cpu == 0) exit
!       st_measure_time=MPI_Wtime()

       dimGrid  = dim3((numNotConverged-1)/128+1,1,1)
       dimBlock = dim3(128,1,1)
       call update_flags<<<dimGrid,dimBlock>>>(isnt_finished(:,1),numNotConverged,n_low)

       !call create_subid<<<dimGrid_nlow,dimBlock128>>>(subidl,subidt,a_prefix(:,kt),b_prefix(:,kt),lenl_cpu,lent_cpu,n_low)
       dimGrid  = dim3(numNotConverged,1,1)
       dimBlock = dim3(128,1,1)
       call create_subid2<<<dimGrid,dimBlock>>>(subidl,subidt,a_prefix(:,kt),b_prefix(:,kt),lenl_cpu,lent_cpu,n_low,notConvergedBlocks(:,sw2),numNotConverged)

       dimGrid  = dim3((lent_cpu-1)/128+1,1,1)
       dimBlock = dim3(128,1,1)
       call calc_vec2<<<dimGrid,dimBlock>>>                                  &
            (zaa,zab,a_prefix,b_prefix,a_strk,b_strk,subidt,leafist,lcol_msk,ndtp,nstrtlp,nstrttp,ndl_prefix,ndt_prefix,xsyszs,xyz,ao2,lp61,lent_cpu,kt,0,size(zaa),n_low,size(lcol_msk),nd)

       ! call maxabsval<<<dimGrid_nlow,dimBlock128>>>(zab,b_prefix(:,kt),b_strk,row_maxval,leafist,leafjst,isnt_finished(:,2),ndt_prefix,ndl_prefix,lcol_msk,lrow_msk,ndtp,0,kt,size(zaa),n_low,size(lcol_msk),size(lrow_msk))
       dimGrid  = dim3(numNotConverged,1,1)
       dimBlock = dim3(128,1,1)
       call maxabsval2<<<dimGrid,dimBlock>>>(zab,b_prefix(:,kt),b_strk,row_maxval,leafist,leafjst,notConvergedBlocks(:,sw2),ndt_prefix,ndl_prefix,lcol_msk,lrow_msk,ndtp,0,kt,size(zaa),n_low,size(lcol_msk),size(lrow_msk),numNotConverged)

       ! allocate(zab_cpu(lent_cpu))
       ! zab_cpu(1:lent_cpu) = zab(1:lent_cpu)
       ! do i = 1, lent_cpu
       !    print *, zab_cpu(i)
       ! end do
       ! stop

       dimGrid  = dim3((lenl_cpu-1)/128+1,1,1)
       dimBlock = dim3(128,1,1)
       call calc_vec2<<<dimGrid,dimBlock>>>                                  &
            (zaa,zab,a_prefix,b_prefix,a_strk,b_strk,subidl,leafjst,lrow_msk,ndlp,nstrtlp,nstrttp,ndl_prefix,ndt_prefix,xsyszs,xyz,ao2,lp61,lenl_cpu,kt,1,size(zaa),n_low,size(lrow_msk),nd)

       ! call maxabsval<<<dimGrid_nlow,dimBlock>>>(zaa,a_prefix(:,kt),a_strk,col_maxval,leafist,leafjst,isnt_finished(:,2),ndt_prefix,ndl_prefix,lcol_msk,lrow_msk,ndlp,1,kt,size(zaa),n_low,size(lcol_msk),size(lrow_msk))
       dimGrid  = dim3(numNotConverged,1,1)
       dimBlock = dim3(128,1,1)
       call maxabsval2<<<dimGrid,dimBlock>>>(zaa,a_prefix(:,kt),a_strk,col_maxval,leafist,leafjst,notConvergedBlocks(:,sw2),ndt_prefix,ndl_prefix,lcol_msk,lrow_msk,ndlp,1,kt,size(zaa),n_low,size(lcol_msk),size(lrow_msk),numNotConverged)
       ! call unrm<<<dimGrid_nlow,dimBlock>>>(znrms,isnt_finished(:,2),ktp,zaa,zab,a_prefix(:,kt),b_prefix(:,kt),a_strk,b_strk,ndlp,ndtp,kt==1.and.param61==1,kt,eps,kstop,size(zaa),n_low)
       call unrm2<<<dimGrid,dimBlock>>>(znrms,isnt_finished,notConvergedBlocks(:,sw2),ktp,zaa,zab,a_prefix(:,kt),b_prefix(:,kt),a_strk,b_strk,ndlp,ndtp,kt==1.and.param61==1,kt,eps,kstop,size(zaa),n_low,numNotConverged)

       ! dimGrid  = dim3((numNotConverged-1)/64+1,1,1)
       ! dimBlock = dim3(64,1,1)
       ! call update_flags<<<dimGrid,dimBlock>>>(notConvergedBlocks(:,sw2),isnt_finished,blockIdIdx,numNotConverged,n_low)

!       en_measure_time=MPI_Wtime()
!       kernel_time = kernel_time + en_measure_time-st_measure_time
       
!       istat = cudaDeviceSynchronize()
       sw1 = mod(sw1,2)+1
       sw2 = mod(sw2,2)+1
    enddo
    kmax = kt-1
    deallocate(subidl)
    deallocate(subidt)
    istat = cudaDeviceSynchronize()
    ! call opt_prefix_sum_pre<<<dimGrid_prefix1,dimBlock_prefix1,0,stream1>>>(idxp2,idxp1,a_prefix_tmp(:,2),b_prefix_tmp(:,2),ndlp,ndtp,ktp,n_low+1,n_low/(32*preloclen)+1,preloclen)
    ! call opt_prefix_sum_mid<<<dimGrid_prefix2,dimBlock_prefix2,0,stream1>>>(a_prefix_tmp(:,2),b_prefix_tmp(:,2),n_low/(32*preloclen)+1)
    ! call opt_prefix_sum_post<<<dimGrid_prefix1,dimBlock_prefix1,0,stream1>>>(idxp2,idxp1,lenl,lent,a_strk,b_strk,a_prefix_tmp(:,2),b_prefix_tmp(:,2),n_low+1,n_low/(32*preloclen)+1,kt,preloclen)

    ! ! dimGrid  = dim3(1,1,1)
    ! ! dimBlock = dim3(256,1,1)
    ! ! call calc_idx<<<dimGrid,dimBlock,0,stream1>>>(idxp2,idxp1,a_prefix_tmp,b_prefix_tmp,ndlp,ndtp,ktp,n_low)
    
    ! call create_a1_a2<<<dimGrid_nlow,dimBlock128,0,stream1>>>(a1,a2,idxp1,idxp2,zab,zaa,b_prefix,a_prefix,b_strk,a_strk,max(lenl_cpu,lent_cpu),n_low,kt-1)


    preloclen = ((n_dense-1)/512+1-1)/32+1
    dimGrid_prefix1  = dim3(512,1,1)
    dimBlock_prefix1 = dim3(32,1,1)
    dimGrid_prefix2  = dim3(1,1,1)
    dimBlock_prefix2 = dim3(512,1,1)

    allocate(idx3_tmp(n_low+n_dense+1))
!    allocate(itmp1D_gpu1(512))
    call opt_prefix_sum_pre_idx3<<<dimGrid_prefix1,dimBlock_prefix1,0,stream2>>>(idx3_tmp,itmp1D_gpu1,ndlp,ndtp,n_low,n_dense,512,preloclen)
    call opt_prefix_sum_mid_idx3<<<dimGrid_prefix2,dimBlock_prefix2,0,stream2>>>(itmp1D_gpu1,512)
    call opt_prefix_sum_post_idx3<<<dimGrid_prefix1,dimBlock_prefix1,0,stream2>>>(idx3_tmp,lend,itmp1D_gpu1,n_low,n_dense,512,preloclen)
    lend_cpu = lend
!    print *, __LINE__, lend_cpu

    preloclen = ((n_dense*ndt_max_dense)/512+1-1)/32+1
    dimGrid_prefix1  = dim3(512,1,1)
    dimBlock_prefix1 = dim3(32,1,1)
    dimGrid_prefix2  = dim3(1,1,1)
    dimBlock_prefix2 = dim3(512,1,1)

    call opt_prefix_sum_pre_idx3_2D<<<dimGrid_prefix1,dimBlock_prefix1,0,stream2>>>(idxp3,itmp1D_gpu1,ndlp,ndtp,n_low,n_dense,512,preloclen,ndt_max_dense)
    call opt_prefix_sum_mid_idx3_2D<<<dimGrid_prefix2,dimBlock_prefix2,0,stream2>>>(itmp1D_gpu1,512,ndt_max_dense)
    call opt_prefix_sum_post_idx3_2D<<<dimGrid_prefix1,dimBlock_prefix1,0,stream2>>>(idxp3,lend,itmp1D_gpu1,n_low,n_dense,512,preloclen,ndt_max_dense)
    lend_cpu = lend
!    print *, __LINE__, lend_cpu

    istat = cudaDeviceSynchronize()
    ! allocate(itmp1D_cpu1(512))
    ! itmp1D_cpu1(1:512) = idxp3(1:512)
    ! !    itmp1D_cpu1(1:512) = itmp1D_gpu1(1:512)
    ! do i = 1, 512
    !    print *, i, itmp1D_cpu1(i)
    ! end do
    ! itmp1D_cpu1(1:512) = ndlp(n_low+1:n_low+512)
    ! do i = 1, 512
    !    print *, i, itmp1D_cpu1(i)
    ! end do
    ! stop
    ! lend_cpu = lend
    ! print *, lend_cpu, size(a3)
    ! stop

!    print *, __LINE__

    lend_cpu = size(a3)
    allocate(subidd(lend_cpu))
    dimGrid  = dim3(n_dense,1,1)
    dimBlock = dim3(64,1,1)
    call create_subid_dense<<<dimGrid,dimBlock,0,stream2>>>(subidd,idx3_tmp,ndlp,ndtp,n_low,n_dense,lend_cpu)


    ! dimGrid  = dim3(n_dense*ndt_max_dense,1,1)
    ! dimBlock = dim3(64,1,1)
    ! call create_subid_dense_2D<<<dimGrid,dimBlock,0,stream2>>>(subidd,idxp3,n_low,n_dense,lend_cpu,ndt_max_dense)

    istat = cudaDeviceSynchronize()
!    print *, __LINE__

    ! istat = cudaDeviceSynchronize()
    ! allocate(itmp1D_cpu1(512))
    ! itmp1D_cpu1(1:512) = subidd(1:512)
    ! do i = 1, 512
    !    print *, i, itmp1D_cpu1(i)
    ! end do
    ! stop

    ! print *, "n_dense*ndt_max_dense", n_dense*ndt_max_dense
    ! print *, "size(subidd)", size(subidd,1)
    ! print *, "lend_cpu", lend_cpu
    ! allocate(itmp1D_cpu1(size(subidd)))
    ! itmp1D_cpu1(1:size(subidd)) = subidd(:)
    ! print *, "maxval(ip)", maxval(mod(itmp1D_cpu1(:)-1,n_dense)+1+n_low)
    ! print *, "maxinval(ip)", minval(mod(itmp1D_cpu1(:)-1,n_dense)+1+n_low)
    ! print *, "size(nstrtl)", size(nstrtlp,1)
    ! print *, "maxval(lid)", maxval(itmp1D_cpu1)
    ! print *, "minval(lid)", minval(itmp1D_cpu1)
    ! print *, "size(idx3)", size(idxp3,1)
    ! ! do i = n_dense*80-100,n_dense*80
    ! !    print *, i, itmp1D_cpu1(i)
    ! ! end do
    ! itmp1D_cpu1(1:size(idxp3,1)) = idxp3(:)
    ! print *, "maxval(idx3)", maxval(idxp3)
    ! print *, "minval(idx3)", minval(idxp3)
    ! print *, "idx3(n_dense*ndt_max_dense+1)", itmp1D_cpu1(n_dense*ndt_max_dense),itmp1D_cpu1(n_dense*ndt_max_dense+1)
 
    ! loci =tid-idx3(lid)+1
    ! ill  =loci+strl-1
    ! itt  =(lid-1)/n_dense+1+strt-1

!    print *, "len a3", lend_cpu
    ! dimGrid  = dim3((lend_cpu-1)/128+1,1,1)
    ! dimBlock = dim3(128,1,1)
    ! ! call calc_vec_dense<<<dimGrid,dimBlock,0,stream2>>>                                  &
    ! !      (a3,subidd,idxp3,ndlp,ndtp,nstrtlp,nstrttp,ndl_prefix,ndt_prefix,xsyszs,xyz,ao2,lp61,lend_cpu,n_low,n_dense,nd)

    ! call calc_vec_dense_2D<<<dimGrid,dimBlock,0,stream2>>>                                  &
    !      (a3,subidd,idxp3,ndlp,ndtp,nstrtlp,nstrttp,ndl_prefix,ndt_prefix,xsyszs,xyz,ao2,lp61,lend_cpu,n_low,n_dense,nd,ndt_max_dense)

    ! print *, __LINE__

    dimGrid  = dim3((lend_cpu-1)/128+1,1,1)
    dimBlock = dim3(128,1,1)
    call calc_mat<<<dimGrid,dimBlock,0,stream2>>>                                  &
         (a3,subidd,idx3_tmp,idxp3,ndlp,ndtp,nstrtlp,nstrttp,ndl_prefix,ndt_prefix,xsyszs,xyz,ao2,lp61,lend_cpu,n_low,n_dense,nd,ndt_max_dense)

    ! deallocate(subidd)
    istat = cudaStreamDestroy(stream1)
    istat = cudaStreamDestroy(stream2)

    istat = cudaDeviceSynchronize()
    deallocate(itmp1D_gpu1)
    ! deallocate(a_strk)
    ! deallocate(b_strk)
    ! deallocate(a_prefix)
    ! deallocate(b_prefix)
    deallocate(a_prefix_tmp)
    deallocate(b_prefix_tmp)
    deallocate(subidd)
    deallocate(idx3_tmp)
    ! deallocate(ktp_cpu)
    ! deallocate(ndtp_cpu)
    ! deallocate(ndlp_cpu)
!    print *, __LINE__

  end subroutine HACApK_aca_cuda_opt8

  subroutine HACApK_aca_cuda_opt7                                                                        &
       (zab,zaa,a3,ndl_prefix,ndt_prefix,ndlp,ndtp,nstrtlp,nstrttp,ktp,b_prefix,a_prefix,b_strk,a_strk,idxp3      &
       ,param,lod,kmax,eps,znrmmat,pACA_EPS,face2node,lp61,ao,np,warn,err,n_low,n_dense,kernel_time,mpinr,numOfDev,ndt_max_dense)
       include 'mpif.h'
    real*8,   dimension(:),    intent(out),   device :: a3,zaa,zab
    integer*4,dimension(:),    intent(in),    device :: ndl_prefix,ndt_prefix
    integer*4,dimension(:),    intent(in),    device :: ndlp,ndtp,nstrtlp,nstrttp
    integer*4,dimension(:),    intent(out),   device :: ktp
    integer*4,dimension(:,:),  intent(out),   device :: a_prefix,b_prefix !idxp1,idxp2
    integer*4,dimension(:),    intent(out),   device :: a_strk,b_strk
    integer*4,dimension(:),    intent(out),   device :: idxp3
    real*8,                    intent(in)            :: param(:)
    integer*4,                 intent(in),    device :: lod(:)
    integer*4,                 intent(inout)         :: kmax
    real*8,                    intent(in)            :: eps,znrmmat,pACA_EPS
    integer*4,dimension(:,:),  intent(in),    device :: face2node
    real*8,   dimension(:,:),  intent(in),    device :: np
    real*8,   dimension(:),    intent(in),    device :: ao
    integer*4,                 intent(in)            :: lp61
    integer*4,dimension(:),    intent(inout), device :: warn,err
    integer*4,                 intent(in)            :: n_low,n_dense
    real*8,                    intent(out)           :: kernel_time
    integer*4,                 intent(in)            :: mpinr,numOfDev,ndt_max_dense

    type(dim3)                                       :: dimGrid, dimBlock, dimGrid_nlow, dimBlock128
    type(dim3)                                       :: dimGrid_prefix1, dimBlock_prefix1
    type(dim3)                                       :: dimGrid_prefix2, dimBlock_prefix2
    type(dim3)                                       :: dimGrid_prefix3, dimBlock_prefix3
    real*8                                           :: param61, param64
    integer*8                                        :: mem_ab,mem_aa
    integer*4                                        :: st,en,i,ip,pi,ts,ne
    real*8                                           :: st_measure_time, en_measure_time
    integer*4, dimension(:),allocatable              :: ktp_cpu,ndtp_cpu,ndlp_cpu
    integer*4                                        :: idx1,idx2,ii,ndl,ndt,kt,istat,offset,sw
    integer(kind=cuda_stream_kind)                   :: stream1, stream2
    real*8                                           :: flop1,flop2,flop3,dbyte,ibyte

    real*8,   dimension(:),allocatable               :: zaa_cpu,zab_cpu
!    integer*4,dimension(:,:),allocatable     ,device :: a_prefix,b_prefix
!    integer*4,dimension(:),allocatable       ,device :: a_strk,b_strk

    integer*4, dimension(:),allocatable      ,device :: isnt_finished     
    integer*4, dimension(:),allocatable      ,device :: kstop
    integer*4, dimension(:),allocatable              :: kstop_cpu
    integer*4, dimension(:),allocatable      ,device :: leafist,leafjst
    integer*4, dimension(:),allocatable              :: leafpib_cpu
    integer*4, dimension(:),allocatable      ,device :: subidl,subidt,subidd
    integer*4, dimension(:),allocatable              :: subidl_cpu,subidt_cpu
    integer*4, dimension(:),allocatable              :: isnt_finished_cpu
    integer*4, dimension(:),allocatable              :: a_prefix_cpu, b_prefix_cpu
    integer*4, dimension(:),allocatable      ,device :: lrow_msk,lcol_msk
    integer*4, dimension(:),allocatable              :: lrow_msk_cpu,lcol_msk_cpu
    real*8   , dimension(:,:),allocatable    ,device :: xsyszs
    real*8   , dimension(:,:),allocatable    ,device :: xyz
    real*8   , dimension(:),allocatable      ,device :: ao2
    real*8   , dimension(:),allocatable      ,device :: row_maxval,col_maxval
    real*8   , dimension(:),allocatable      ,device :: znrms
    integer*4, dimension(:,:),allocatable    ,device :: a_prefix_tmp,b_prefix_tmp
    integer*4, dimension(:),allocatable              :: idxp1_cpu,idxp2_cpu
    real*8   , dimension(:),allocatable              :: a1_cpu
    integer*4                                ,device :: lenl,lent,lend
    integer*4, dimension(:),allocatable      ,device :: itmp1D_gpu1,itmp1D_gpu2
    integer*4, dimension(:),allocatable              :: itmp1D_cpu1,itmp1D_cpu2
    integer*4                                        :: nd,lenl_cpu,lent_cpu,lend_cpu,preloclen
    integer*4, dimension(:),allocatable              :: nstrtlp_cpu,nstrttp_cpu
    integer*4, dimension(:),allocatable      ,device :: idx3_tmp
    integer*4 :: a_sum, b_sum
    real*8    :: dtmp

!    print *, mpinr, kmax,eps,znrmmat,pACA_EPS,lp61,n_low,n_dense
    ! stop
    ! print *, mpinr, numOfDev
    ! istat = cudaSetDevice(mod(mpinr,numOfDev))
    ! stop

    allocate(isnt_finished(n_low))
    !    allocate(isnt_finished_cpu(n_low))
    allocate(kstop(n_low))
    ! allocate(kstop_cpu(n_low))

    ! allocate(ktp_cpu(size(ktp)))
    ! allocate(ndtp_cpu(size(ndtp)))
    ! allocate(ndlp_cpu(size(ndlp)))
    ! allocate(idxp1_cpu(size(idxp1)))
    ! allocate(idxp2_cpu(size(idxp2)))

    nd = size(lod)
!    print *, "nd", nd
    allocate(xsyszs(nd,9))
    allocate(xyz(nd,3))
    allocate(ao2(nd))
    allocate(leafist(n_low))
    allocate(leafjst(n_low))
    allocate(leafpib_cpu(n_low))
    allocate(row_maxval(n_low))
    allocate(col_maxval(n_low))
    allocate(znrms(n_low))

    ! allocate(a_strk(kmax+1))
    ! allocate(b_strk(kmax+1))
    a_strk(1) = 1; b_strk(1) = 1
    ! allocate(a_prefix(n_low+1,kmax+1))
    ! allocate(b_prefix(n_low+1,kmax+1))
    istat = cudaStreamCreate(stream1)
    istat = cudaStreamCreate(stream2)

    ! ndtp_cpu(:) = ndtp(:)
    ! ndlp_cpu(:) = ndlp(:)

    ! kstop_cpu(:) = min(kmax,min(ndtp_cpu(:),ndlp_cpu(:)))
    ! kstop(:) = kstop_cpu(:)

    ! allocate(lrow_msk_cpu(sum(ndtp_cpu(1:n_low))))
    ! allocate(lcol_msk_cpu(sum(ndlp_cpu(1:n_low))))
    ! lrow_msk_cpu(:) = 0
    ! lcol_msk_cpu(:) = 0
    ! lrow_msk(:) = lrow_msk_cpu(:)
    ! lcol_msk(:) = lcol_msk_cpu(:)
    ! lenl_cpu = sum(ndtp_cpu(1:n_low))
    ! lent_cpu = sum(ndlp_cpu(1:n_low))

    ! print *, "length cpu", sum(ndtp_cpu(1:n_low)), sum(ndlp_cpu(1:n_low))
!    print *, "param", param61, param64
    param61 = param(61)
    param64 = param(64)

    ! isnt_finished_cpu(:) = 1
    ! isnt_finished(:) = isnt_finished_cpu(:)
    kernel_time = 0.0d0

    dimGrid_nlow  = dim3(n_low,1,1)
    dimBlock128   = dim3(128,1,1)

    dimGrid  = dim3((nd-1)/128+1,1,1)
    dimBlock = dim3(128,1,1)
    call pre_calc_vec2<<<dimGrid,dimBlock>>>(xyz,xsyszs,ao2,ao,lod,face2node,np,nd,lp61,size(face2node,2),size(np,2))

    dimGrid  = dim3((n_low-1)/128+1,1,1)
    dimBlock = dim3(128,1,1)
    call init_leafval2 <<<dimGrid,dimBlock>>>(znrms,leafist,isnt_finished,kstop,znrmmat,ndlp,ndtp,nstrtlp,nstrttp,n_low,kmax)
    allocate(itmp1D_gpu1((n_low-1)/128+1))
    allocate(itmp1D_gpu2((n_low-1)/128+1))
    call calc_length_pre <<<dimGrid,dimBlock>>>(itmp1D_gpu1,itmp1D_gpu2,ndlp,ndtp,n_low,(n_low-1)/128+1)
    dimGrid  = dim3(1,1,1)
    dimBlock = dim3(512,1,1)
    call calc_length_post<<<dimGrid,dimBlock>>>(lenl,lent,itmp1D_gpu1,itmp1D_gpu2,(n_low-1)/128+1)
    deallocate(itmp1D_gpu1)
    deallocate(itmp1D_gpu2)
    lenl_cpu = lenl
    lent_cpu = lent
    allocate(lrow_msk(lenl_cpu))
    allocate(lcol_msk(lent_cpu))
    dimGrid  = dim3((lent_cpu-1)/128+1,1,1)
    dimBlock = dim3(128,1,1)
    call init_msk <<<dimGrid,dimBlock>>>(lcol_msk,lent_cpu)
    dimGrid  = dim3((lenl_cpu-1)/128+1,1,1)
    dimBlock = dim3(128,1,1)
    call init_msk <<<dimGrid,dimBlock>>>(lrow_msk,lenl_cpu)

    allocate(a_prefix_tmp(1:n_low+1,2))
    allocate(b_prefix_tmp(1:n_low+1,2))
    allocate(subidl(lenl_cpu))
    allocate(subidt(lent_cpu))

    preloclen = ((n_low-1)/512+1-1)/32+1
    dimGrid_prefix1  = dim3(512,1,1)
    dimBlock_prefix1 = dim3(32,1,1)
    dimGrid_prefix2  = dim3(1,1,1)
    dimBlock_prefix2 = dim3(512,1,1)
    
!    print *, "preloclen", preloclen
    do kt = 1, kmax
       allocate(isnt_finished_cpu(n_low))
       isnt_finished_cpu(1:n_low) = isnt_finished(1:n_low)
       ! do i = 1, n_low
       !    if(isnt_finished_cpu(i) == 1) print *, i
       ! end do
       a_sum = sum(isnt_finished_cpu)
       deallocate(isnt_finished_cpu)


       call opt_prefix_sum_pre<<<dimGrid_prefix1,dimBlock_prefix1>>>(a_prefix(:,kt),b_prefix(:,kt),a_prefix_tmp(:,2),b_prefix_tmp(:,2),ndlp,ndtp,isnt_finished,n_low+1,n_low/32+1,preloclen)
       call opt_prefix_sum_mid<<<dimGrid_prefix2,dimBlock_prefix2>>>(a_prefix_tmp(:,2),b_prefix_tmp(:,2),n_low/(32*preloclen)+1)
       call opt_prefix_sum_post<<<dimGrid_prefix1,dimBlock_prefix1>>>(a_prefix(:,kt),b_prefix(:,kt),lenl,lent,a_strk,b_strk,a_prefix_tmp(:,2),b_prefix_tmp(:,2),n_low+1,n_low/32+1,kt,preloclen)

       ! print *, "n_low", n_low
       ! allocate(itmp1D_cpu1(n_low+1))
       ! allocate(ndlp_cpu(n_low))
       ! itmp1D_cpu1(1:n_low+1)=a_prefix(1:n_low+1,1)
       ! ndlp_cpu(1:n_low)=ndlp(1:n_low)
       ! do i = 2, n_low+1
       !    if(mpinr==1) then 
       !       print *, i, itmp1D_cpu1(i), ndlp_cpu(i-1)
       !    end if
       ! end do
       ! stop
       lenl_cpu = lenl-1
       lent_cpu = lent-1
#if 1
       print *, "length gpu", lenl_cpu, lent_cpu, kt, a_sum
#endif
       if(lenl_cpu == 0) exit
       st_measure_time=MPI_Wtime()

       call create_subid<<<dimGrid_nlow,dimBlock128>>>(subidl,subidt,a_prefix(:,kt),b_prefix(:,kt),lenl_cpu,lent_cpu,n_low)

       dimGrid  = dim3((lent_cpu-1)/128+1,1,1)
       dimBlock = dim3(128,1,1)
       call calc_vec2<<<dimGrid,dimBlock>>>                                  &
            (zaa,zab,a_prefix,b_prefix,a_strk,b_strk,subidt,leafist,lcol_msk,ndtp,nstrtlp,nstrttp,ndl_prefix,ndt_prefix,xsyszs,xyz,ao2,lp61,lent_cpu,kt,0,size(zaa),n_low,size(lcol_msk),nd)

       ! allocate(zab_cpu(lent_cpu))
       ! zab_cpu(1:lent_cpu) = zab(1:lent_cpu)
       ! do i = 1, lent_cpu
       !    print *, zab_cpu(i)
       ! end do
       ! stop
       
       call maxabsval<<<dimGrid_nlow,dimBlock128>>>(zab,b_prefix(:,kt),b_strk,row_maxval,leafist,leafjst,isnt_finished,ndt_prefix,ndl_prefix,lcol_msk,lrow_msk,ndtp,0,kt,size(zaa),n_low,size(lcol_msk),size(lrow_msk))

       dimGrid  = dim3((lenl_cpu-1)/128+1,1,1)
       call calc_vec2<<<dimGrid,dimBlock>>>                                  &
            (zaa,zab,a_prefix,b_prefix,a_strk,b_strk,subidl,leafjst,lrow_msk,ndlp,nstrtlp,nstrttp,ndl_prefix,ndt_prefix,xsyszs,xyz,ao2,lp61,lenl_cpu,kt,1,size(zaa),n_low,size(lrow_msk),nd)

       call maxabsval<<<dimGrid_nlow,dimBlock>>>(zaa,a_prefix(:,kt),a_strk,col_maxval,leafist,leafjst,isnt_finished,ndt_prefix,ndl_prefix,lcol_msk,lrow_msk,ndlp,1,kt,size(zaa),n_low,size(lcol_msk),size(lrow_msk))
       call unrm<<<dimGrid_nlow,dimBlock>>>(znrms,isnt_finished,ktp,zaa,zab,a_prefix(:,kt),b_prefix(:,kt),a_strk,b_strk,ndlp,ndtp,kt==1.and.param61==1,kt,eps,kstop,size(zaa),n_low)

       en_measure_time=MPI_Wtime()
       kernel_time = kernel_time + en_measure_time-st_measure_time
       
       istat = cudaDeviceSynchronize()
    enddo
    kmax = kt-1
    deallocate(subidl)
    deallocate(subidt)
    istat = cudaDeviceSynchronize()
    ! call opt_prefix_sum_pre<<<dimGrid_prefix1,dimBlock_prefix1,0,stream1>>>(idxp2,idxp1,a_prefix_tmp(:,2),b_prefix_tmp(:,2),ndlp,ndtp,ktp,n_low+1,n_low/(32*preloclen)+1,preloclen)
    ! call opt_prefix_sum_mid<<<dimGrid_prefix2,dimBlock_prefix2,0,stream1>>>(a_prefix_tmp(:,2),b_prefix_tmp(:,2),n_low/(32*preloclen)+1)
    ! call opt_prefix_sum_post<<<dimGrid_prefix1,dimBlock_prefix1,0,stream1>>>(idxp2,idxp1,lenl,lent,a_strk,b_strk,a_prefix_tmp(:,2),b_prefix_tmp(:,2),n_low+1,n_low/(32*preloclen)+1,kt,preloclen)

    ! ! dimGrid  = dim3(1,1,1)
    ! ! dimBlock = dim3(256,1,1)
    ! ! call calc_idx<<<dimGrid,dimBlock,0,stream1>>>(idxp2,idxp1,a_prefix_tmp,b_prefix_tmp,ndlp,ndtp,ktp,n_low)
    
    ! call create_a1_a2<<<dimGrid_nlow,dimBlock128,0,stream1>>>(a1,a2,idxp1,idxp2,zab,zaa,b_prefix,a_prefix,b_strk,a_strk,max(lenl_cpu,lent_cpu),n_low,kt-1)


    preloclen = ((n_dense-1)/512+1-1)/32+1
    dimGrid_prefix1  = dim3(512,1,1)
    dimBlock_prefix1 = dim3(32,1,1)
    dimGrid_prefix2  = dim3(1,1,1)
    dimBlock_prefix2 = dim3(512,1,1)

    allocate(idx3_tmp(n_low+n_dense+1))
    allocate(itmp1D_gpu1(512))
    call opt_prefix_sum_pre_idx3<<<dimGrid_prefix1,dimBlock_prefix1,0,stream2>>>(idx3_tmp,itmp1D_gpu1,ndlp,ndtp,n_low,n_dense,512,preloclen)
    call opt_prefix_sum_mid_idx3<<<dimGrid_prefix2,dimBlock_prefix2,0,stream2>>>(itmp1D_gpu1,512)
    call opt_prefix_sum_post_idx3<<<dimGrid_prefix1,dimBlock_prefix1,0,stream2>>>(idx3_tmp,lend,itmp1D_gpu1,n_low,n_dense,512,preloclen)
    lend_cpu = lend
!    print *, __LINE__, lend_cpu

    preloclen = ((n_dense*ndt_max_dense)/512+1-1)/32+1
    dimGrid_prefix1  = dim3(512,1,1)
    dimBlock_prefix1 = dim3(32,1,1)
    dimGrid_prefix2  = dim3(1,1,1)
    dimBlock_prefix2 = dim3(512,1,1)

    call opt_prefix_sum_pre_idx3_2D<<<dimGrid_prefix1,dimBlock_prefix1,0,stream2>>>(idxp3,itmp1D_gpu1,ndlp,ndtp,n_low,n_dense,512,preloclen,ndt_max_dense)
    call opt_prefix_sum_mid_idx3_2D<<<dimGrid_prefix2,dimBlock_prefix2,0,stream2>>>(itmp1D_gpu1,512,ndt_max_dense)
    call opt_prefix_sum_post_idx3_2D<<<dimGrid_prefix1,dimBlock_prefix1,0,stream2>>>(idxp3,lend,itmp1D_gpu1,n_low,n_dense,512,preloclen,ndt_max_dense)
    lend_cpu = lend
!    print *, __LINE__, lend_cpu

    istat = cudaDeviceSynchronize()
    ! allocate(itmp1D_cpu1(512))
    ! itmp1D_cpu1(1:512) = idxp3(1:512)
    ! !    itmp1D_cpu1(1:512) = itmp1D_gpu1(1:512)
    ! do i = 1, 512
    !    print *, i, itmp1D_cpu1(i)
    ! end do
    ! itmp1D_cpu1(1:512) = ndlp(n_low+1:n_low+512)
    ! do i = 1, 512
    !    print *, i, itmp1D_cpu1(i)
    ! end do
    ! stop
    ! lend_cpu = lend
    ! print *, lend_cpu, size(a3)
    ! stop

!    print *, __LINE__

    lend_cpu = size(a3)
    allocate(subidd(lend_cpu))
    dimGrid  = dim3(n_dense,1,1)
    dimBlock = dim3(64,1,1)
    call create_subid_dense<<<dimGrid,dimBlock,0,stream2>>>(subidd,idx3_tmp,ndlp,ndtp,n_low,n_dense,lend_cpu)


    ! dimGrid  = dim3(n_dense*ndt_max_dense,1,1)
    ! dimBlock = dim3(64,1,1)
    ! call create_subid_dense_2D<<<dimGrid,dimBlock,0,stream2>>>(subidd,idxp3,n_low,n_dense,lend_cpu,ndt_max_dense)

    istat = cudaDeviceSynchronize()
!    print *, __LINE__

    ! istat = cudaDeviceSynchronize()
    ! allocate(itmp1D_cpu1(512))
    ! itmp1D_cpu1(1:512) = subidd(1:512)
    ! do i = 1, 512
    !    print *, i, itmp1D_cpu1(i)
    ! end do
    ! stop

    ! print *, "n_dense*ndt_max_dense", n_dense*ndt_max_dense
    ! print *, "size(subidd)", size(subidd,1)
    ! print *, "lend_cpu", lend_cpu
    ! allocate(itmp1D_cpu1(size(subidd)))
    ! itmp1D_cpu1(1:size(subidd)) = subidd(:)
    ! print *, "maxval(ip)", maxval(mod(itmp1D_cpu1(:)-1,n_dense)+1+n_low)
    ! print *, "maxinval(ip)", minval(mod(itmp1D_cpu1(:)-1,n_dense)+1+n_low)
    ! print *, "size(nstrtl)", size(nstrtlp,1)
    ! print *, "maxval(lid)", maxval(itmp1D_cpu1)
    ! print *, "minval(lid)", minval(itmp1D_cpu1)
    ! print *, "size(idx3)", size(idxp3,1)
    ! ! do i = n_dense*80-100,n_dense*80
    ! !    print *, i, itmp1D_cpu1(i)
    ! ! end do
    ! itmp1D_cpu1(1:size(idxp3,1)) = idxp3(:)
    ! print *, "maxval(idx3)", maxval(idxp3)
    ! print *, "minval(idx3)", minval(idxp3)
    ! print *, "idx3(n_dense*ndt_max_dense+1)", itmp1D_cpu1(n_dense*ndt_max_dense),itmp1D_cpu1(n_dense*ndt_max_dense+1)
 
    ! loci =tid-idx3(lid)+1
    ! ill  =loci+strl-1
    ! itt  =(lid-1)/n_dense+1+strt-1

!    print *, "len a3", lend_cpu
    ! dimGrid  = dim3((lend_cpu-1)/128+1,1,1)
    ! dimBlock = dim3(128,1,1)
    ! ! call calc_vec_dense<<<dimGrid,dimBlock,0,stream2>>>                                  &
    ! !      (a3,subidd,idxp3,ndlp,ndtp,nstrtlp,nstrttp,ndl_prefix,ndt_prefix,xsyszs,xyz,ao2,lp61,lend_cpu,n_low,n_dense,nd)

    ! call calc_vec_dense_2D<<<dimGrid,dimBlock,0,stream2>>>                                  &
    !      (a3,subidd,idxp3,ndlp,ndtp,nstrtlp,nstrttp,ndl_prefix,ndt_prefix,xsyszs,xyz,ao2,lp61,lend_cpu,n_low,n_dense,nd,ndt_max_dense)

    ! print *, __LINE__

    dimGrid  = dim3((lend_cpu-1)/128+1,1,1)
    dimBlock = dim3(128,1,1)
    call calc_mat<<<dimGrid,dimBlock,0,stream2>>>                                  &
         (a3,subidd,idx3_tmp,idxp3,ndlp,ndtp,nstrtlp,nstrttp,ndl_prefix,ndt_prefix,xsyszs,xyz,ao2,lp61,lend_cpu,n_low,n_dense,nd,ndt_max_dense)

    ! deallocate(subidd)
    istat = cudaStreamDestroy(stream1)
    istat = cudaStreamDestroy(stream2)

    istat = cudaDeviceSynchronize()
    deallocate(itmp1D_gpu1)
    ! deallocate(a_strk)
    ! deallocate(b_strk)
    ! deallocate(a_prefix)
    ! deallocate(b_prefix)
    deallocate(a_prefix_tmp)
    deallocate(b_prefix_tmp)
    deallocate(subidd)
    deallocate(idx3_tmp)
    ! deallocate(ktp_cpu)
    ! deallocate(ndtp_cpu)
    ! deallocate(ndlp_cpu)
!    print *, __LINE__

  end subroutine HACApK_aca_cuda_opt7


  subroutine HACApK_aca_cuda_opt6                                                                        &
       (a1,a2,a3,zab,zaa,ndl_prefix,ndt_prefix,ndlp,ndtp,nstrtlp,nstrttp,ktp,idxp1,idxp2,idxp3           &
       ,param,lod,kmax,eps,znrmmat,pACA_EPS,face2node,lp61,ao,np,warn,err,n_low,n_dense,kernel_time,mpinr,numOfDev)
       include 'mpif.h'
    real*8,   dimension(:),    intent(out),   device :: a1,a2,a3,zaa,zab
    integer*4,dimension(:),    intent(in),    device :: ndl_prefix,ndt_prefix
    integer*4,dimension(:),    intent(in),    device :: ndlp,ndtp,nstrtlp,nstrttp
    integer*4,dimension(:),    intent(out),   device :: ktp
    integer*4,dimension(:),    intent(out),   device :: idxp1,idxp2,idxp3
    real*8,                    intent(in)            :: param(:)
    integer*4,                 intent(in),    device :: lod(:)
    integer*4,                 intent(in)            :: kmax
    real*8,                    intent(in)            :: eps,znrmmat,pACA_EPS
    integer*4,dimension(:,:),  intent(in),    device :: face2node
    real*8,   dimension(:,:),  intent(in),    device :: np
    real*8,   dimension(:),    intent(in),    device :: ao
    integer*4,                 intent(in)            :: lp61
    integer*4,dimension(:),    intent(inout), device :: warn,err
    integer*4,                 intent(in)            :: n_low,n_dense
    real*8,                    intent(out)           :: kernel_time
    integer*4,                 intent(in)            :: mpinr,numOfDev

    type(dim3)                                       :: dimGrid, dimBlock, dimGrid_nlow, dimBlock128
    type(dim3)                                       :: dimGrid_prefix1, dimBlock_prefix1
    type(dim3)                                       :: dimGrid_prefix2, dimBlock_prefix2
    type(dim3)                                       :: dimGrid_prefix3, dimBlock_prefix3
    real*8                                           :: param61, param64
    integer*8                                        :: mem_ab,mem_aa
    integer*4                                        :: st,en,i,ip,pi,ts,ne
    real*8                                           :: st_measure_time, en_measure_time
    integer*4, dimension(:),allocatable              :: ktp_cpu,ndtp_cpu,ndlp_cpu
    integer*4                                        :: idx1,idx2,ii,ndl,ndt,kt,istat,offset,sw
    integer(kind=cuda_stream_kind)                   :: stream1, stream2
    real*8                                           :: flop1,flop2,flop3,dbyte,ibyte

    real*8,   dimension(:),allocatable               :: zaa_cpu,zab_cpu
    integer*4,dimension(:,:),allocatable     ,device :: a_prefix,b_prefix
    integer*4,dimension(:),allocatable       ,device :: a_strk,b_strk

    integer*4, dimension(:),allocatable      ,device :: isnt_finished     
    integer*4, dimension(:),allocatable      ,device :: kstop
    integer*4, dimension(:),allocatable              :: kstop_cpu
    integer*4, dimension(:),allocatable      ,device :: leafist,leafjst
    integer*4, dimension(:),allocatable              :: leafpib_cpu
    integer*4, dimension(:),allocatable      ,device :: subidl,subidt,subidd
    integer*4, dimension(:),allocatable              :: subidl_cpu,subidt_cpu
    integer*4, dimension(:),allocatable              :: isnt_finished_cpu
    integer*4, dimension(:),allocatable              :: a_prefix_cpu, b_prefix_cpu
    integer*4, dimension(:),allocatable      ,device :: lrow_msk,lcol_msk
    integer*4, dimension(:),allocatable              :: lrow_msk_cpu,lcol_msk_cpu
    real*8   , dimension(:,:),allocatable    ,device :: xsyszs
    real*8   , dimension(:,:),allocatable    ,device :: xyz
    real*8   , dimension(:),allocatable      ,device :: ao2
    real*8   , dimension(:),allocatable      ,device :: row_maxval,col_maxval
    real*8   , dimension(:),allocatable      ,device :: znrms
    integer*4, dimension(:,:),allocatable    ,device :: a_prefix_tmp,b_prefix_tmp
    integer*4, dimension(:),allocatable              :: idxp1_cpu,idxp2_cpu
    real*8   , dimension(:),allocatable              :: a1_cpu
    integer*4                                ,device :: lenl,lent,lend
    integer*4, dimension(:),allocatable      ,device :: itmp1D_gpu1,itmp1D_gpu2
    integer*4, dimension(:),allocatable              :: itmp1D_cpu1,itmp1D_cpu2
    integer*4                                        :: nd,lenl_cpu,lent_cpu,lend_cpu,preloclen
    integer*4, dimension(:),allocatable              :: nstrtlp_cpu,nstrttp_cpu
    integer*4 :: a_sum, b_sum
    real*8    :: dtmp

!    print *, mpinr, kmax,eps,znrmmat,pACA_EPS,lp61,n_low,n_dense
    ! stop
    ! print *, mpinr, numOfDev
    ! istat = cudaSetDevice(mod(mpinr,numOfDev))
    ! stop

    allocate(isnt_finished(n_low))
    !    allocate(isnt_finished_cpu(n_low))
    allocate(kstop(n_low))
    ! allocate(kstop_cpu(n_low))

    ! allocate(ktp_cpu(size(ktp)))
    ! allocate(ndtp_cpu(size(ndtp)))
    ! allocate(ndlp_cpu(size(ndlp)))
    ! allocate(idxp1_cpu(size(idxp1)))
    ! allocate(idxp2_cpu(size(idxp2)))

    nd = size(lod)
!    print *, "nd", nd
    allocate(xsyszs(nd,9))
    allocate(xyz(nd,3))
    allocate(ao2(nd))
    allocate(leafist(n_low))
    allocate(leafjst(n_low))
    allocate(leafpib_cpu(n_low))
    allocate(row_maxval(n_low))
    allocate(col_maxval(n_low))
    allocate(znrms(n_low))

    allocate(a_strk(kmax+1))
    allocate(b_strk(kmax+1))
    a_strk(1) = 1; b_strk(1) = 1
    allocate(a_prefix(n_low+1,kmax+1))
    allocate(b_prefix(n_low+1,kmax+1))
    istat = cudaStreamCreate(stream1)
    istat = cudaStreamCreate(stream2)

    ! ndtp_cpu(:) = ndtp(:)
    ! ndlp_cpu(:) = ndlp(:)

    ! kstop_cpu(:) = min(kmax,min(ndtp_cpu(:),ndlp_cpu(:)))
    ! kstop(:) = kstop_cpu(:)

    ! allocate(lrow_msk_cpu(sum(ndtp_cpu(1:n_low))))
    ! allocate(lcol_msk_cpu(sum(ndlp_cpu(1:n_low))))
    ! lrow_msk_cpu(:) = 0
    ! lcol_msk_cpu(:) = 0
    ! lrow_msk(:) = lrow_msk_cpu(:)
    ! lcol_msk(:) = lcol_msk_cpu(:)
    ! lenl_cpu = sum(ndtp_cpu(1:n_low))
    ! lent_cpu = sum(ndlp_cpu(1:n_low))

    ! print *, "length cpu", sum(ndtp_cpu(1:n_low)), sum(ndlp_cpu(1:n_low))
!    print *, "param", param61, param64
    param61 = param(61)
    param64 = param(64)

    ! isnt_finished_cpu(:) = 1
    ! isnt_finished(:) = isnt_finished_cpu(:)
    kernel_time = 0.0d0

    dimGrid_nlow  = dim3(n_low,1,1)
    dimBlock128   = dim3(128,1,1)

    dimGrid  = dim3((nd-1)/128+1,1,1)
    dimBlock = dim3(128,1,1)
    call pre_calc_vec2<<<dimGrid,dimBlock>>>(xyz,xsyszs,ao2,ao,lod,face2node,np,nd,lp61,size(face2node,2),size(np,2))

    dimGrid  = dim3((n_low-1)/128+1,1,1)
    dimBlock = dim3(128,1,1)
    call init_leafval2 <<<dimGrid,dimBlock>>>(znrms,leafist,isnt_finished,kstop,znrmmat,ndlp,ndtp,nstrtlp,nstrttp,n_low,kmax)
    allocate(itmp1D_gpu1((n_low-1)/128+1))
    allocate(itmp1D_gpu2((n_low-1)/128+1))
    call calc_length_pre <<<dimGrid,dimBlock>>>(itmp1D_gpu1,itmp1D_gpu2,ndlp,ndtp,n_low,(n_low-1)/128+1)
    dimGrid  = dim3(1,1,1)
    dimBlock = dim3(512,1,1)
    call calc_length_post<<<dimGrid,dimBlock>>>(lenl,lent,itmp1D_gpu1,itmp1D_gpu2,(n_low-1)/128+1)
    deallocate(itmp1D_gpu1)
    deallocate(itmp1D_gpu2)
    lenl_cpu = lenl
    lent_cpu = lent
    allocate(lrow_msk(lenl_cpu))
    allocate(lcol_msk(lent_cpu))
    dimGrid  = dim3((lent_cpu-1)/128+1,1,1)
    dimBlock = dim3(128,1,1)
    call init_msk <<<dimGrid,dimBlock>>>(lcol_msk,lent_cpu)
    dimGrid  = dim3((lenl_cpu-1)/128+1,1,1)
    dimBlock = dim3(128,1,1)
    call init_msk <<<dimGrid,dimBlock>>>(lrow_msk,lenl_cpu)

    allocate(a_prefix_tmp(1:n_low+1,2))
    allocate(b_prefix_tmp(1:n_low+1,2))
    allocate(subidl(lenl_cpu))
    allocate(subidt(lent_cpu))

    preloclen = ((n_low-1)/512+1-1)/32+1
    dimGrid_prefix1  = dim3(512,1,1)
    dimBlock_prefix1 = dim3(32,1,1)
    dimGrid_prefix2  = dim3(1,1,1)
    dimBlock_prefix2 = dim3(512,1,1)
    
!    print *, "preloclen", preloclen
    do kt = 1, kmax
       call opt_prefix_sum_pre<<<dimGrid_prefix1,dimBlock_prefix1>>>(a_prefix(:,kt),b_prefix(:,kt),a_prefix_tmp(:,2),b_prefix_tmp(:,2),ndlp,ndtp,isnt_finished,n_low+1,n_low/32+1,preloclen)
       call opt_prefix_sum_mid<<<dimGrid_prefix2,dimBlock_prefix2>>>(a_prefix_tmp(:,2),b_prefix_tmp(:,2),n_low/(32*preloclen)+1)
       call opt_prefix_sum_post<<<dimGrid_prefix1,dimBlock_prefix1>>>(a_prefix(:,kt),b_prefix(:,kt),lenl,lent,a_strk,b_strk,a_prefix_tmp(:,2),b_prefix_tmp(:,2),n_low+1,n_low/32+1,kt,preloclen)

       ! print *, "n_low", n_low
       ! allocate(itmp1D_cpu1(n_low+1))
       ! allocate(ndlp_cpu(n_low))
       ! itmp1D_cpu1(1:n_low+1)=a_prefix(1:n_low+1,1)
       ! ndlp_cpu(1:n_low)=ndlp(1:n_low)
       ! do i = 2, n_low+1
       !    if(mpinr==1) then 
       !       print *, i, itmp1D_cpu1(i), ndlp_cpu(i-1)
       !    end if
       ! end do
       ! stop
       lenl_cpu = lenl-1
       lent_cpu = lent-1
#if DEBUG==1
       print *, "length gpu", lenl_cpu, lent_cpu, kt
#endif
       if(lenl_cpu == 0) exit
       st_measure_time=MPI_Wtime()

       call create_subid<<<dimGrid_nlow,dimBlock128>>>(subidl,subidt,a_prefix(:,kt),b_prefix(:,kt),lenl_cpu,lent_cpu,n_low)

       dimGrid  = dim3((lent_cpu-1)/128+1,1,1)
       dimBlock = dim3(128,1,1)
       call calc_vec2<<<dimGrid,dimBlock>>>                                  &
            (zaa,zab,a_prefix,b_prefix,a_strk,b_strk,subidt,leafist,lcol_msk,ndtp,nstrtlp,nstrttp,ndl_prefix,ndt_prefix,xsyszs,xyz,ao2,lp61,lent_cpu,kt,0,size(zaa),n_low,size(lcol_msk),nd)
!        allocate(zab_cpu(lent_cpu))
!        zab_cpu(1:lent_cpu) = zab(1:lent_cpu)
!        print *, mpinr,lent_cpu
!        if(mpinr==0) then 
! !          open(14,file='test0.csv',status='replace')
!        ! else
!        !    open(11,file='test1.csv',status='replace')
!        end if
!        do i = 1, lent_cpu
!           if(mpinr==0) then 
!              print *, zab_cpu(i)
! !             write(14,*), zab_cpu(i)
!           ! else
!           !    write(11,*), zab_cpu(i)
!           end if
!        end do
!        stop
       
       call maxabsval<<<dimGrid_nlow,dimBlock128>>>(zab,b_prefix(:,kt),b_strk,row_maxval,leafist,leafjst,isnt_finished,ndt_prefix,ndl_prefix,lcol_msk,lrow_msk,ndtp,0,kt,size(zaa),n_low,size(lcol_msk),size(lrow_msk))

       dimGrid  = dim3((lenl_cpu-1)/128+1,1,1)
       call calc_vec2<<<dimGrid,dimBlock>>>                                  &
            (zaa,zab,a_prefix,b_prefix,a_strk,b_strk,subidl,leafjst,lrow_msk,ndlp,nstrtlp,nstrttp,ndl_prefix,ndt_prefix,xsyszs,xyz,ao2,lp61,lenl_cpu,kt,1,size(zaa),n_low,size(lrow_msk),nd)

       call maxabsval<<<dimGrid_nlow,dimBlock>>>(zaa,a_prefix(:,kt),a_strk,col_maxval,leafist,leafjst,isnt_finished,ndt_prefix,ndl_prefix,lcol_msk,lrow_msk,ndlp,1,kt,size(zaa),n_low,size(lcol_msk),size(lrow_msk))
       call unrm<<<dimGrid_nlow,dimBlock>>>(znrms,isnt_finished,ktp,zaa,zab,a_prefix(:,kt),b_prefix(:,kt),a_strk,b_strk,ndlp,ndtp,kt==1.and.param61==1,kt,eps,kstop,size(zaa),n_low)

       en_measure_time=MPI_Wtime()
       kernel_time = kernel_time + en_measure_time-st_measure_time
       
       istat = cudaDeviceSynchronize()
    enddo
    deallocate(subidl)
    deallocate(subidt)
    istat = cudaDeviceSynchronize()
    call opt_prefix_sum_pre<<<dimGrid_prefix1,dimBlock_prefix1,0,stream1>>>(idxp2,idxp1,a_prefix_tmp(:,2),b_prefix_tmp(:,2),ndlp,ndtp,ktp,n_low+1,n_low/(32*preloclen)+1,preloclen)
    call opt_prefix_sum_mid<<<dimGrid_prefix2,dimBlock_prefix2,0,stream1>>>(a_prefix_tmp(:,2),b_prefix_tmp(:,2),n_low/(32*preloclen)+1)
    call opt_prefix_sum_post<<<dimGrid_prefix1,dimBlock_prefix1,0,stream1>>>(idxp2,idxp1,lenl,lent,a_strk,b_strk,a_prefix_tmp(:,2),b_prefix_tmp(:,2),n_low+1,n_low/(32*preloclen)+1,kt,preloclen)

    ! dimGrid  = dim3(1,1,1)
    ! dimBlock = dim3(256,1,1)
    ! call calc_idx<<<dimGrid,dimBlock,0,stream1>>>(idxp2,idxp1,a_prefix_tmp,b_prefix_tmp,ndlp,ndtp,ktp,n_low)
    
    call create_a1_a2<<<dimGrid_nlow,dimBlock128,0,stream1>>>(a1,a2,idxp1,idxp2,zab,zaa,b_prefix,a_prefix,b_strk,a_strk,max(lenl_cpu,lent_cpu),n_low,kt-1)


    preloclen = ((n_dense-1)/512+1-1)/32+1
    dimGrid_prefix1  = dim3(512,1,1)
    dimBlock_prefix1 = dim3(32,1,1)
    dimGrid_prefix2  = dim3(1,1,1)
    dimBlock_prefix2 = dim3(512,1,1)
    allocate(itmp1D_gpu1(512))
    !    allocate(itmp1D_cpu1(512))
    call opt_prefix_sum_pre_idx3<<<dimGrid_prefix1,dimBlock_prefix1,0,stream2>>>(idxp3,itmp1D_gpu1,ndlp,ndtp,n_low,n_dense,512,preloclen)
    call opt_prefix_sum_mid_idx3<<<dimGrid_prefix2,dimBlock_prefix2,0,stream2>>>(itmp1D_gpu1,512)
    call opt_prefix_sum_post_idx3<<<dimGrid_prefix1,dimBlock_prefix1,0,stream2>>>(idxp3,lend,itmp1D_gpu1,n_low,n_dense,512,preloclen)
    ! istat = cudaDeviceSynchronize()
    ! itmp1D_cpu1(1:512) = idxp3(n_low+1:n_low+512)
    ! !    itmp1D_cpu1(1:512) = itmp1D_gpu1(1:512)
    ! do i = 1, 512
    !    print *, i, itmp1D_cpu1(i)
    ! end do
    ! stop
    ! lend_cpu = lend
    ! print *, lend_cpu, size(a3)
    ! stop
    lend_cpu = size(a3)
    allocate(subidd(lend_cpu))
    dimGrid  = dim3(n_dense,1,1)
    dimBlock = dim3(64,1,1)
    call create_subid_dense<<<dimGrid,dimBlock,0,stream2>>>(subidd,idxp3,ndlp,ndtp,n_low,n_dense,lend_cpu)
    ! istat = cudaDeviceSynchronize()
    ! itmp1D_cpu1(1:512) = subidd(1:512)
    ! do i = 1, 512
    !    print *, i, itmp1D_cpu1(i)
    ! end do
    ! stop
    dimGrid  = dim3((lend_cpu-1)/128+1,1,1)
    dimBlock = dim3(128,1,1)
    call calc_vec_dense<<<dimGrid,dimBlock,0,stream2>>>                                  &
         (a3,subidd,idxp3,ndlp,ndtp,nstrtlp,nstrttp,ndl_prefix,ndt_prefix,xsyszs,xyz,ao2,lp61,lend_cpu,n_low,n_dense,nd)
    ! deallocate(subidd)
    istat = cudaStreamDestroy(stream1)
    istat = cudaStreamDestroy(stream2)

    istat = cudaDeviceSynchronize()
    deallocate(itmp1D_gpu1)
    deallocate(a_strk)
    deallocate(b_strk)
    deallocate(a_prefix)
    deallocate(b_prefix)
    deallocate(a_prefix_tmp)
    deallocate(b_prefix_tmp)
    deallocate(subidd)
    ! deallocate(ktp_cpu)
    ! deallocate(ndtp_cpu)
    ! deallocate(ndlp_cpu)

  end subroutine HACApK_aca_cuda_opt6


  subroutine HACApK_aca_cuda_opt6_old                                                                        &
       (a1,a2,zab,zaa,ndl_prefix,ndt_prefix,ndlp,ndtp,nstrtlp,nstrttp,ktp,idxp1,idxp2                            &
       ,param,lod,kmax,eps,znrmmat,pACA_EPS,face2node,lp61,ao,np,warn,err,n_low,kernel_time)
       include 'mpif.h'
    real*8,   dimension(:),    intent(out),   device :: a1,a2,zaa,zab
    integer*4,dimension(:),    intent(in),    device :: ndl_prefix,ndt_prefix
    integer*4,dimension(:),    intent(in),    device :: ndlp,ndtp,nstrtlp,nstrttp
    integer*4,dimension(:),    intent(out),   device :: ktp
    integer*4,dimension(:),    intent(out),   device :: idxp1,idxp2
    real*8,                    intent(in)            :: param(:)
    integer*4,                 intent(in),    device :: lod(:)
    integer*4,                 intent(in)            :: kmax
    real*8,                    intent(in)            :: eps,znrmmat,pACA_EPS
    integer*4,dimension(:,:),  intent(in),    device :: face2node
    real*8,   dimension(:,:),  intent(in),    device :: np
    real*8,   dimension(:),    intent(in),    device :: ao
    integer*4,                 intent(in)            :: lp61
    integer*4,dimension(:),    intent(inout), device :: warn,err
    integer*4,                 intent(in)            :: n_low
    real*8,                    intent(out)           :: kernel_time
    type(dim3)                                       :: dimGrid, dimBlock, dimGrid_nlow, dimBlock128
    type(dim3)                                       :: dimGrid_prefix1, dimBlock_prefix1
    type(dim3)                                       :: dimGrid_prefix2, dimBlock_prefix2
    type(dim3)                                       :: dimGrid_prefix3, dimBlock_prefix3
    real*8                                           :: param61, param64
    integer*8                                        :: mem_ab,mem_aa
    integer*4                                        :: st,en,i,ip,pi,ts,ne
    real*8                                           :: st_measure_time, en_measure_time
    integer*4, dimension(:),allocatable              :: ktp_cpu,ndtp_cpu,ndlp_cpu
    integer*4                                        :: idx1,idx2,ii,ndl,ndt,kt,istat,offset,sw
    integer(kind=cuda_stream_kind)                   :: stream1, stream2
    real*8                                           :: flop1,flop2,flop3,dbyte,ibyte

    ! type workarray
    !    ! real*8,   dimension(:),pointer,    device :: zaa,zab
    !    ! integer*4,dimension(:),pointer,    device :: a_prefix,b_prefix
    !    real*8,   dimension(:),allocatable,    device :: zaa,zab
    !    integer*4,dimension(:),allocatable,    device :: a_prefix,b_prefix
    ! end type workarray
    real*8,   dimension(:),allocatable               :: zaa_cpu,zab_cpu
    integer*4,dimension(:,:),allocatable     ,device :: a_prefix,b_prefix
    integer*4,dimension(:),allocatable       ,device :: a_strk,b_strk

!    type(workarray), dimension(:),allocatable        :: work
!    type(workarray), dimension(:),allocatable,device :: work
    integer*4, dimension(:),allocatable      ,device :: isnt_finished     
    integer*4, dimension(:),allocatable      ,device :: kstop
    integer*4, dimension(:),allocatable              :: kstop_cpu
    integer*4, dimension(:),allocatable      ,device :: leafist,leafjst
    integer*4, dimension(:),allocatable              :: leafpib_cpu
    integer*4, dimension(:),allocatable      ,device :: subidl,subidt
    integer*4, dimension(:),allocatable              :: subidl_cpu,subidt_cpu
    integer*4, dimension(:),allocatable              :: isnt_finished_cpu
    integer*4, dimension(:),allocatable              :: a_prefix_cpu, b_prefix_cpu
!    integer*1, dimension(:),allocatable      ,device :: lrow_msk,lcol_msk
    integer*4, dimension(:),allocatable      ,device :: lrow_msk,lcol_msk
    integer*4, dimension(:),allocatable              :: lrow_msk_cpu,lcol_msk_cpu
    real*8   , dimension(:,:),allocatable    ,device :: xsyszs
    real*8   , dimension(:,:),allocatable    ,device :: xyz
    real*8   , dimension(:),allocatable      ,device :: ao2
    real*8   , dimension(:),allocatable      ,device :: row_maxval,col_maxval
    real*8   , dimension(:),allocatable      ,device :: znrms
    integer*4, dimension(:,:),allocatable    ,device :: a_prefix_tmp,b_prefix_tmp
    integer*4, dimension(:),allocatable              :: idxp1_cpu,idxp2_cpu
    real*8   , dimension(:),allocatable              :: a1_cpu
    integer*4                                ,device :: lenl,lent
    integer*4                                        :: nd,lenl_cpu,lent_cpu,preloclen
    integer*4, dimension(:),allocatable              :: nstrtlp_cpu,nstrttp_cpu
    integer*4 :: a_sum, b_sum
    real*8    :: dtmp

!    allocate(work(kmax))
    allocate(isnt_finished(n_low))
    allocate(isnt_finished_cpu(n_low))
    allocate(kstop(n_low))
    allocate(kstop_cpu(n_low))

    allocate(ktp_cpu(size(ktp)))
    allocate(ndtp_cpu(size(ndtp)))
    allocate(ndlp_cpu(size(ndlp)))
    allocate(idxp1_cpu(size(idxp1)))
    allocate(idxp2_cpu(size(idxp2)))

    nd = size(lod)
    allocate(xsyszs(nd,9))
    allocate(xyz(nd,3))
    allocate(ao2(nd))
    allocate(leafist(n_low))
    allocate(leafjst(n_low))
    allocate(leafpib_cpu(n_low))
    allocate(row_maxval(n_low))
    allocate(col_maxval(n_low))
    allocate(znrms(n_low))

    allocate(a_strk(kmax+1))
    allocate(b_strk(kmax+1))
    a_strk(1) = 1; b_strk(1) = 1
    allocate(a_prefix(n_low+1,kmax+1))
    allocate(b_prefix(n_low+1,kmax+1))
    istat = cudaStreamCreate(stream1)
    istat = cudaStreamCreate(stream2)

    print *, "ao length", size(ao)
    ! face2node_t => face2node
    ! np_t => np

    ndtp_cpu(:) = ndtp(:)
    ndlp_cpu(:) = ndlp(:)

    kstop_cpu(:) = min(kmax,min(ndtp_cpu(:),ndlp_cpu(:)))
    kstop(:) = kstop_cpu(:)

    allocate(lrow_msk(sum(ndtp_cpu(1:n_low))))
    allocate(lcol_msk(sum(ndlp_cpu(1:n_low))))
    allocate(lrow_msk_cpu(sum(ndtp_cpu(1:n_low))))
    allocate(lcol_msk_cpu(sum(ndlp_cpu(1:n_low))))
    lrow_msk_cpu(:) = 0
    lcol_msk_cpu(:) = 0
    lrow_msk(:) = lrow_msk_cpu(:)
    lcol_msk(:) = lcol_msk_cpu(:)
    lenl_cpu = sum(ndtp_cpu(1:n_low))
    lent_cpu = sum(ndlp_cpu(1:n_low))

    print *, "length cpu", sum(ndtp_cpu(1:n_low)), sum(ndlp_cpu(1:n_low))
    param61 = param(61)
    param64 = param(64)

    print *, "test", __LINE__
    flop1 = 0.d0;    flop2 = 0.d0;    flop3 = 0.d0
    ibyte = 0.d0;    dbyte = 0.d0;
    
    sw = 0
    ip = 1
    idx1 = 1;  idx2 = 1
    print *, "test", __LINE__

    isnt_finished_cpu(:) = 1
    isnt_finished(:) = isnt_finished_cpu(:)
    kernel_time = 0.0d0
    print *, "test", __LINE__

    dimGrid_nlow  = dim3(n_low,1,1)
    dimBlock128   = dim3(128,1,1)

    dimGrid  = dim3((nd-1)/128+1,1,1)
    dimBlock = dim3(128,1,1)
!    call pre_calc_vec<<<dimGrid,dimBlock, 0, stream1>>>(xsyszs,ao2,ao,lod,face2node,np,nd,lp61)
!    call pre_calc_vec<<<dimGrid,dimBlock>>>(xsyszs,ao2,ao,lod,face2node,np,nd,lp61,size(face2node,2),size(np,2))
    call pre_calc_vec2<<<dimGrid,dimBlock>>>(xyz,xsyszs,ao2,ao,lod,face2node,np,nd,lp61,size(face2node,2),size(np,2))
    print *, "test", __LINE__
    dimGrid  = dim3((n_low-1)/128+1,1,1)
    dimBlock = dim3(128,1,1)
!    call create_znrm <<<dimGrid,dimBlock, 0, stream1>>>(znrms,znrmmat,ndlp,ndtp,n_low)
    call init_leafval <<<dimGrid,dimBlock>>>(znrms,leafist,znrmmat,ndlp,ndtp,nstrtlp,nstrttp,n_low)
    print *, "test", __LINE__

    ! if(param61==1) ACA_EPS=pACA_EPS
    ! if(param61==2 .or. param61==3) ACA_EPS=pACA_EPS*znrm

    allocate(a_prefix_cpu(1:n_low+1))
    allocate(b_prefix_cpu(1:n_low+1))
    allocate(a_prefix_tmp(1:n_low+1,2))
    allocate(b_prefix_tmp(1:n_low+1,2))
    allocate(subidl(lenl_cpu))
    allocate(subidt(lent_cpu))


    preloclen = ((n_low-1)/512+1-1)/32+1
    print *, "preloclen", preloclen
    dimGrid_prefix1  = dim3(512,1,1)
    dimBlock_prefix1 = dim3(32,1,1)
    ! else if(n_low / 512 <= 64) then
    !    dimGrid_prefix1  = dim3((n_low-1)/64+1,1,1)
    !    dimBlock_prefix1 = dim3(64,1,1)
    ! else if(n_low / 512 <= 128) then
    !    dimGrid_prefix1  = dim3((n_low-1)/128+1,1,1)
    !    dimBlock_prefix1 = dim3(128,1,1)
    ! else
    !    ! dimGrid_prefix1  = dim3((n_low-1)/256+1,1,1)
    !    ! dimBlock_prefix1 = dim3(256,1,1)
    !    print *, "prefix sum is not optimized"
    ! endif
    dimGrid_prefix2  = dim3(1,1,1)
    dimBlock_prefix2 = dim3(512,1,1)
    
    do kt = 1, kmax
       ! allocate(work(kt)%a_prefix(1:n_low+1))
       ! allocate(work(kt)%b_prefix(1:n_low+1))

       ! if(n_low / 512 <= 32) then
          ! call opt_prefix_sum_pre<<<dimGridd_prefix1,dimBlock_prefix1>>>(a_prefix_tmp(:,1),b_prefix_tmp(:,1),a_prefix_tmp(:,2),b_prefix_tmp(:,2),ndlp,ndtp,isnt_finished,n_low+1,n_low/32+1)
          ! call opt_prefix_sum_mid<<<dimGrid_prefix2,dimBlock_prefix2>>>(a_prefix_tmp(:,2),b_prefix_tmp(:,2),n_low/32+1)
          ! call opt_prefix_sum_post<<<dimGrid_prefix1,dimBlock_prefix1>>>(a_prefix(:,kt),b_prefix(:,kt),lenl,lent,a_strk,b_strk,a_prefix_tmp(:,1),b_prefix_tmp(:,1),a_prefix_tmp(:,2),b_prefix_tmp(:,2),n_low+1,n_low/32+1,kt)

          call opt_prefix_sum_pre<<<dimGrid_prefix1,dimBlock_prefix1>>>(a_prefix(:,kt),b_prefix(:,kt),a_prefix_tmp(:,2),b_prefix_tmp(:,2),ndlp,ndtp,isnt_finished,n_low+1,n_low/32+1,preloclen)
          call opt_prefix_sum_mid<<<dimGrid_prefix2,dimBlock_prefix2>>>(a_prefix_tmp(:,2),b_prefix_tmp(:,2),n_low/(32*preloclen)+1)
          call opt_prefix_sum_post<<<dimGrid_prefix1,dimBlock_prefix1>>>(a_prefix(:,kt),b_prefix(:,kt),lenl,lent,a_strk,b_strk,a_prefix_tmp(:,2),b_prefix_tmp(:,2),n_low+1,n_low/32+1,kt,preloclen)

          ! a_prefix_cpu(1:1000) = a_prefix(1:1000,kt)
          ! do i = 1, 1000
          !    print *, "a_pre1", i, a_prefix_cpu(i)
          ! end do
          ! a_prefix_cpu(1:512) = a_prefix_tmp(1:512,2)
          ! do i = 1, 512
          !    print *, "a_pre2", i, a_prefix_cpu(i)
          ! end do
          ! b_prefix_cpu(1:1000) = b_prefix(1:1000,kt)
          ! do i = 1, 1000
          !    print *, "b_pre1", i, b_prefix_cpu(i)
          ! end do
          ! stop

       ! else
       !    dimGrid  = dim3(1,1,1)
       !    dimBlock = dim3(256,1,1)
       !    !       call gang1_prefix_sum<<<dimGrid,dimBlock>>>(work(kt)%a_prefix,work(kt)%b_prefix,lenl,lent,a_prefix_tmp,b_prefix_tmp,ndlp,ndtp,isnt_finished,n_low+1)
       !    call gang1_prefix_sum<<<dimGrid,dimBlock>>>(a_prefix(:,kt),b_prefix(:,kt),lenl,lent,a_strk,b_strk,a_prefix_tmp,b_prefix_tmp,ndlp,ndtp,isnt_finished,n_low+1,kt,kmax)
       ! end if


       ! lenl_cpu = work(kt)%a_prefix(n_low+1)-1
       ! lent_cpu = work(kt)%b_prefix(n_low+1)-1
       ! do i = 1, kt
       !    lenl_cpu = a_strk(i)
       !    lent_cpu = b_strk(i)
       !    print *, i,lenl_cpu, lent_cpu
       ! enddo
       lenl_cpu = lenl-1
       lent_cpu = lent-1
       print *, "length gpu", lenl_cpu, lent_cpu, kt
       if(lenl_cpu == 0) exit
       ! allocate(work(kt)%zaa(lenl_cpu))
       ! allocate(work(kt)%zab(lent_cpu))
       ! allocate(subidl(lenl_cpu))
       ! allocate(subidt(lent_cpu))

       st_measure_time=MPI_Wtime()

!       call create_subid<<<dimGrid_nlow,dimBlock128>>>(subidl,subidt,work(kt)%a_prefix,work(kt)%b_prefix)
       call create_subid<<<dimGrid_nlow,dimBlock128>>>(subidl,subidt,a_prefix(:,kt),b_prefix(:,kt),lenl_cpu,lent_cpu,n_low)
       ! allocate(subidl_cpu(size(subidl)))
       ! allocate(subidt_cpu(size(subidt)))
       ! subidl_cpu(:) = subidl(:)
       ! subidt_cpu(:) = subidt(:)
       ! do i = 1, size(subidl)
       !    print *, i, subidl_cpu(i), subidt_cpu(i)
       ! enddo
       ! stop
       ! print *, "test", __LINE__

       dimGrid  = dim3((lent_cpu-1)/128+1,1,1)
       dimBlock = dim3(128,1,1)
       ! call calc_vec<<<dimGrid,dimBlock>>>                                  &
       !      (zaa,zab,a_prefix,b_prefix,a_strk,b_strk,subidt,leafist,lcol_msk,ndtp,nstrtlp,nstrttp,ndl_prefix,ndt_prefix,xsyszs,ao2,lp61,lent_cpu,kt,0,size(zaa),n_low,size(lcol_msk),nd)
       call calc_vec2<<<dimGrid,dimBlock>>>                                  &
            (zaa,zab,a_prefix,b_prefix,a_strk,b_strk,subidt,leafist,lcol_msk,ndtp,nstrtlp,nstrttp,ndl_prefix,ndt_prefix,xsyszs,xyz,ao2,lp61,lent_cpu,kt,0,size(zaa),n_low,size(lcol_msk),nd)

!            (work(kt)%zab,work(kt)%b_prefix,subidt,leafist,lcol_msk,ndtp,nstrtlp,nstrttp,ndt_prefix,xsyszs,ao2,lp61,lent_cpu,kt,0)
!       print *, "test", __LINE__

       ! if(kt.ne.1) then
       !    do i = 1, kt-1
       !       call za_update<<<dimGrid,dimBlock>>>(work(kt)%zab,work(i)%zab,work(i)%zaa,work(kt)%b_prefix,work(i)%b_prefix,work(i)%a_prefix,subidt,leafist,lent_cpu,kt)
       !    enddo
       !    call za_msk<<<dimGrid, dimBlock>>>(work(kt)%zab,work(kt)%b_prefix,subidt,lcol_msk,ndt_prefix,lent_cpu)

       ! end if

!       call maxabsval<<<dimGrid_nlow,dimBlock128>>>(work(kt)%zab,work(kt)%b_prefix,row_maxval,leafist,leafjst,isnt_finished,ndt_prefix,ndl_prefix,lcol_msk,lrow_msk,ndtp,0)
       call maxabsval<<<dimGrid_nlow,dimBlock128>>>(zab,b_prefix(:,kt),b_strk,row_maxval,leafist,leafjst,isnt_finished,ndt_prefix,ndl_prefix,lcol_msk,lrow_msk,ndtp,0,kt,size(zaa),n_low,size(lcol_msk),size(lrow_msk))
       ! if(kt == 3) then
       !    allocate(zab_cpu(lent_cpu*3))
       !    zab_cpu(1:lent_cpu*3) = zab(1:lent_cpu*3)
       !    do i = 1, lent_cpu*3
       !       print *, "b",kt,i,zab_cpu(i)
       !    enddo
       !    stop
       ! endif
       ! print *, "test", __LINE__

       dimGrid  = dim3((lenl_cpu-1)/128+1,1,1)
       ! call calc_vec<<<dimGrid,dimBlock>>>                                  &
       !      (zaa,zab,a_prefix,b_prefix,a_strk,b_strk,subidl,leafjst,lrow_msk,ndlp,nstrtlp,nstrttp,ndl_prefix,ndt_prefix,xsyszs,ao2,lp61,lenl_cpu,kt,1,size(zaa),n_low,size(lrow_msk),nd)
       call calc_vec2<<<dimGrid,dimBlock>>>                                  &
            (zaa,zab,a_prefix,b_prefix,a_strk,b_strk,subidl,leafjst,lrow_msk,ndlp,nstrtlp,nstrttp,ndl_prefix,ndt_prefix,xsyszs,xyz,ao2,lp61,lenl_cpu,kt,1,size(zaa),n_low,size(lrow_msk),nd)
!            (work(kt)%zaa,work(kt)%a_prefix,subidl,leafjst,lrow_msk,ndlp,nstrtlp,nstrttp,ndl_prefix,xsyszs,ao2,lp61,lenl_cpu,kt,1)

       ! if(kt.ne.1) then
       !    do i = 1, kt-1
       !       call za_update<<<dimGrid,dimBlock>>>(work(kt)%zaa,work(i)%zaa,work(i)%zab,work(kt)%a_prefix,work(i)%a_prefix,work(i)%b_prefix,subidl,leafjst,lenl_cpu,kt)
       !    enddo
       !    call za_msk<<<dimGrid, dimBlock>>>(work(kt)%zaa,work(kt)%a_prefix,subidl,lrow_msk,ndl_prefix,lenl_cpu)
       ! end if

!       call maxabsval<<<dimGrid_nlow,dimBlock>>>(work(kt)%zaa,work(kt)%a_prefix,col_maxval,leafist,leafjst,isnt_finished,ndt_prefix,ndl_prefix,lcol_msk,lrow_msk,ndlp,1)
       call maxabsval<<<dimGrid_nlow,dimBlock>>>(zaa,a_prefix(:,kt),a_strk,col_maxval,leafist,leafjst,isnt_finished,ndt_prefix,ndl_prefix,lcol_msk,lrow_msk,ndlp,1,kt,size(zaa),n_low,size(lcol_msk),size(lrow_msk))
!       call unrm<<<dimGrid_nlow,dimBlock>>>(znrms,isnt_finished,ktp,work(kt)%zaa,work(kt)%zab,work(kt)%a_prefix,work(kt)%b_prefix,ndlp,ndtp,kt==1.and.param61==1,kt,eps,kstop)
       call unrm<<<dimGrid_nlow,dimBlock>>>(znrms,isnt_finished,ktp,zaa,zab,a_prefix(:,kt),b_prefix(:,kt),a_strk,b_strk,ndlp,ndtp,kt==1.and.param61==1,kt,eps,kstop,size(zaa),n_low)

       en_measure_time=MPI_Wtime()
       kernel_time = kernel_time + en_measure_time-st_measure_time
       
       istat = cudaDeviceSynchronize()
    enddo
    deallocate(subidl)
    deallocate(subidt)
    dimGrid  = dim3(1,1,1)
    dimBlock = dim3(256,1,1)
    call calc_idx<<<dimGrid,dimBlock>>>(idxp2,idxp1,a_prefix_tmp,b_prefix_tmp,ndlp,ndtp,ktp,n_low)
    
    ! do i = 1, kt-1
    !    call create_a1_a2<<<dimGrid_nlow,dimBlock128>>>(a1,a2,idxp1,idxp2,work(i)%zab,work(i)%zaa,work(i)%b_prefix,work(i)%a_prefix,i)
    ! enddo
    call create_a1_a2<<<dimGrid_nlow,dimBlock128>>>(a1,a2,idxp1,idxp2,zab,zaa,b_prefix,a_prefix,b_strk,a_strk,max(lenl_cpu,lent_cpu),n_low,kt-1)

    ! lenl_cpu = a_strk(kt)
    ! lent_cpu = a_strk(kt)
    ! dimGrid  = dim3((max(lenl_cpu,lent_cpu)-1)/128+1,1,1)
    ! dimBlock = dim3(128,1,1)
    ! call create_a1_a2_opt<<<dimGrid,dimBlock>>>(a1,a2,idxp1,idxp2,zab,zaa,b_prefix,a_prefix,b_strk,a_strk,max(lenl_cpu,lent_cpu),n_low,kt-1)
    ! allocate(zab_cpu(1000))
    ! zab_cpu(1:1000) = a1(1:1000)
    ! do i = 1, 1000
    !    print *, i, zab_cpu(i)
    ! end do
    ! stop
    istat = cudaStreamDestroy(stream1)
    istat = cudaStreamDestroy(stream2)

    ! ktp_cpu(1:n_low) = ktp(1:n_low)
    ! print *, "maxkt", maxval(ktp_cpu(1:n_low))
    ! print *, "gflop", flop1/1000000000.0d0,flop2/1000000000.0d0,flop3/1000000000.0d0,flop3*3/1000000000.0d0
    ! print *, "gbyte(i,d)", 4.0d0*ibyte/1000000000.0d0,8.0d0*dbyte/1000000000.0d0
    ! print *, "estimated gflops", (flop1+flop2+flop3*50+flop3*3*80)/1000000000.0d0/kernel_time
    ! print *, "estimated bandwidth", (ibyte*4+dbyte*8)/1000000000.0d0/kernel_time

    deallocate(a_strk)
    deallocate(b_strk)
    deallocate(a_prefix)
    deallocate(b_prefix)
    deallocate(a_prefix_tmp)
    deallocate(b_prefix_tmp)
    deallocate(ktp_cpu)
    deallocate(ndtp_cpu)
    deallocate(ndlp_cpu)

  end subroutine HACApK_aca_cuda_opt6_old


#if NOTDEBUG
  subroutine HACApK_aca_cuda_opt5                                                                        &
       (a1,a2,zaa,zab,lcol_msk,lrow_msk,ndl_prefix,ndt_prefix,ndlp,ndtp,nstrtlp,nstrttp,ktp,idxp1,idxp2  &
       ,param,lod,kmax,eps,znrmmat,pACA_EPS,face2node,lp61,ao,np,warn,err,n_low,LOCLIMITSIZE,kernel_time)
       include 'mpif.h'
    real*8,   dimension(:),    intent(out),   device :: a1,a2
    real*8,   dimension(:),    intent(out),   device :: zaa,zab
    integer*4,dimension(:),    intent(inout), device :: lrow_msk,lcol_msk
    integer*4,dimension(:),    intent(in),    device :: ndl_prefix,ndt_prefix
    integer*4,dimension(:),    intent(in),    device :: ndlp,ndtp,nstrtlp,nstrttp
    integer*4,dimension(:),    intent(out),   device :: ktp
    integer*4,dimension(:),    intent(out),   device :: idxp1,idxp2
    real*8,                    intent(in)            :: param(:)
    integer*4,                 intent(in),    device :: lod(:)
    integer*4,                 intent(in)            :: kmax
    real*8,                    intent(in)            :: eps,znrmmat,pACA_EPS
    integer*4,dimension(:,:),  intent(in),    device :: face2node
    real*8,   dimension(:,:),  intent(in),    device :: np
    real*8,   dimension(:),    intent(in),    device :: ao
    integer*4,                 intent(in)            :: lp61
    integer*4,dimension(:),    intent(inout), device :: warn,err
    integer*4,                 intent(in)            :: n_low,LOCLIMITSIZE
    real*8,                    intent(out)           :: kernel_time
    type(dim3)                                       :: dimGrid, dimBlock
    real*8                                           :: param61, param64
    integer*8                                        :: mem_ab,mem_aa
    integer*4                                        :: st,en,i,ip,pi,ts,ne
    real*8                                           :: st_measure_time, en_measure_time
    integer*4,dimension(:),allocatable               :: ktp_cpu,idxp1_cpu,idxp2_cpu,ndtp_cpu,ndlp_cpu
    integer*4                                        :: idx1,idx2,ii,ndl,ndt,kt,istat,offset,sw
    integer(kind=cuda_stream_kind)                   :: stream1, stream2
    real*8                                           :: flop1,flop2,flop3,dbyte,ibyte
    real*8,   dimension(:),    allocatable           :: a1_cpu,a2_cpu

    allocate(ktp_cpu(size(ktp)))
    allocate(ndtp_cpu(size(ndtp)))
    allocate(ndlp_cpu(size(ndlp)))
    allocate(idxp1_cpu(size(idxp1)))
    allocate(idxp2_cpu(size(idxp2)))

    allocate(a1_cpu(size(a1)), a2_cpu(size(a2)))
    istat = cudaStreamCreate(stream1)
    istat = cudaStreamCreate(stream2)
    
    ! face2node_t => face2node
    ! np_t => np

    ndtp_cpu(:) = ndtp(:)
    ndlp_cpu(:) = ndlp(:)

    param61 = param(61)
    param64 = param(64)

    flop1 = 0.d0;    flop2 = 0.d0;    flop3 = 0.d0
    ibyte = 0.d0;    dbyte = 0.d0;
    
    sw = 0
    ip = 1
    idx1 = 1;  idx2 = 1
    kernel_time = 0.0d0
    do while(ip < n_low+1)
       mem_ab = 0
       mem_aa = 0
       st = ip
       en = n_low
       do i= ip, n_low
          mem_ab = mem_ab + ndtp_cpu(i)*kmax
          mem_aa = mem_aa + ndlp_cpu(i)*kmax
          if(mem_ab > LOCLIMITSIZE .or. mem_aa > LOCLIMITSIZE) then
             en = i-1
             exit
          endif
       end do
       ip = en+1

!       offset = (LOCLIMITSIZE/2)*sw
       offset = 0
       st_measure_time=MPI_Wtime()
       dimGrid  = dim3(en-st+1,1,1)
       if(en-st+1 <= 56) then
          dimBlock = dim3(256,1,1)
       elseif(en-st+1 <= 112) then
          dimBlock = dim3(128,1,1)
       elseif(en-st+1 <= 224) then
          dimBlock = dim3(64,1,1)
       else
          dimBlock = dim3(32,1,1)
!          dimBlock = dim3(64,1,1)
       endif
       
       call HACApK_calc_kt_cuda_final<<<dimGrid, dimBlock, 0, stream1>>>                                &
            (st,en,offset,zaa,zab,lcol_msk,lrow_msk,ndl_prefix,ndt_prefix,ndlp,ndtp,                            &
            nstrtlp,nstrttp,ktp,param61,param64,lod,kmax,eps,znrmmat,pACA_EPS,                           &
            face2node,lp61,ao,np,warn,err)
       en_measure_time=MPI_Wtime()
       kernel_time = kernel_time + en_measure_time-st_measure_time
       
       istat = cudaMemcpyAsync(ktp_cpu(st),ktp(st),en-st+1,stream1)
       istat = cudaStreamSynchronize(stream1)
       !ktp_cpu(st:en) = ktp(st:en)
       
       do ii=st, en
          idxp1_cpu(ii) = idx1
          idxp2_cpu(ii) = idx2
          ndl   =ndlp_cpu(ii)   ; ndt   =ndtp_cpu(ii)
          kt    =ktp_cpu(ii)
          idx1 = idx1 + ndt * kt
          idx2 = idx2 + ndl * kt
          flop1 = flop1 + 1              !init
          flop1 = flop1 + kt*3*(ndl+ndt) !norm
          flop1 = flop1 + kt*9           !calc x,y,z
          flop1 = flop1 + kt*ndt + 1     !zab(ii)=zab(ii)*zdltinv
          flop2 = flop2 + 1              !sqrt
          ibyte = ibyte + 4 + (ndt + ndl) / 32 + 1
          ibyte = ibyte + 12 * kt
          do i = 1, kt
             ibyte = ibyte + 12 * (ndl + ndt - 2 * (i-1))
             dbyte = dbyte + (ndl + ndt - 2 * (i-1))
             flop1 = flop1 + (192 + 63 + 2) * (ndt - (i-1)) + (192 + 72 + 2) * (ndl - (i-1))
             if(lp61==3) flop1 = flop1 + 2 * (ndl + ndt - 2 * (i-1))
             if(i .ne. 1) then
                flop1 = flop1 + (i-1) * 2 * (ndl+ndt) 
                dbyte = dbyte + 2 *(ndl+ndt) + 2 * (i-1)
             endif
             dbyte = dbyte + 2 * (ndl + ndt - 2 * (i-1))
             flop1 = flop1 + 2 * (ndl + ndt - 2 * (i-1))
             flop2 = flop2 + 10 * (ndl + ndt - 2 * (i-1))
             flop3 = flop3 + 3  * (ndl + ndt - 2 * (i-1)) ! log, 1/3 atan2
          end do
          flop2 = flop2 + kt * 2
          dbyte = dbyte + kt * (ndt + 1)
          dbyte = dbyte + kt * (ndt + ndl)
       enddo
       if(idx1 > size(a1) .or. idx2 > size(a2)) print *, "memory overflow at ", __FILE__, '(',__LINE__,')'

       istat = cudaMemcpyAsync(idxp1(st),idxp1_cpu(st),en-st+1,stream1)
       istat = cudaMemcpyAsync(idxp2(st),idxp2_cpu(st),en-st+1,stream1)
       ! idxp1(st:en) = idxp1_cpu(st:en)
       ! idxp2(st:en) = idxp2_cpu(st:en)
       
       dimBlock = dim3(128,1,1)
       call a1_a2_copy2<<<dimGrid, dimBlock, 0, stream1>>>                                                &
            (st,en,offset,zaa,zab,ndl_prefix,ndt_prefix,ndlp,ndtp,nstrtlp,nstrttp,ktp,idxp1,idxp2,kmax,a1,a2)  
       sw = mod(sw+1,2)
    enddo

    ! a1_cpu(:) = a1(:)
    ! do ii = 1, n_low
    !    do i = 1, ndtp_cpu(ii)*ktp_cpu(ii)
    !       print *, i, a1_cpu(idxp1_cpu(ii)-1+i)
    !    enddo
    ! end do
    ! stop

    istat = cudaStreamDestroy(stream1)
    istat = cudaStreamDestroy(stream2)

    print *, "maxkt", maxval(ktp_cpu)
    print *, "gflop", flop1/1000000000.0d0,flop2/1000000000.0d0,flop3/1000000000.0d0,flop3*3/1000000000.0d0
    print *, "gbyte(i,d)", 4.0d0*ibyte/1000000000.0d0,8.0d0*dbyte/1000000000.0d0
    print *, "estimated gflops", (flop1+flop2+flop3*50+flop3*3*80)/1000000000.0d0/kernel_time
    print *, "estimated bandwidth", (ibyte*4+dbyte*8)/1000000000.0d0/kernel_time

    deallocate(ktp_cpu)
    deallocate(ndtp_cpu)
    deallocate(ndlp_cpu)
    deallocate(idxp1_cpu)
    deallocate(idxp2_cpu)

  end subroutine HACApK_aca_cuda_opt5


  subroutine HACApK_aca_cuda4                                                                             &
       (a1,a2,zaa,zab,lcol_msk,lrow_msk,ndl_prefix,ndt_prefix,ndlp,ndtp,nstrtlp,nstrttp,ktp,idxp1,idxp2  &
       ,param,lod,kmax,eps,znrmmat,pACA_EPS,st_bemv,warn,err,n_low,LOCLIMITSIZE,kernel_time)
       use m_HACApK_calc_entry_ij    
       include 'mpif.h'
    real*8,   dimension(:),    intent(out),   device :: a1,a2
    real*8,   dimension(:),    intent(out),   device :: zaa,zab
    integer*4,dimension(:),    intent(inout), device :: lrow_msk,lcol_msk
    integer*4,dimension(:),    intent(in),    device :: ndl_prefix,ndt_prefix
    integer*4,dimension(:),    intent(in),    device :: ndlp,ndtp,nstrtlp,nstrttp
    integer*4,dimension(:),    intent(out),   device :: ktp
    integer*4,dimension(:),    intent(out),   device :: idxp1,idxp2
    real*8,                    intent(in)            :: param(:)
    integer*4,                 intent(in),    device :: lod(:)
    integer*4,                 intent(in)            :: kmax
    real*8,                    intent(in)            :: eps,znrmmat,pACA_EPS
    type(st_HACApK_calc_entry),intent(in),    device :: st_bemv
    integer*4,dimension(:),    intent(inout), device :: warn,err
    integer*4,                 intent(in)            :: n_low,LOCLIMITSIZE
    real*8,                    intent(out)           :: kernel_time
    type(dim3)                                       :: dimGrid, dimBlock
    real*8                                           :: param61, param64
    integer*8                                        :: mem_ab,mem_aa
    integer*4                                        :: st,en,i,ip,ts,ne
    real*8                                           :: st_measure_time, en_measure_time
    integer*4,dimension(:),allocatable               :: ktp_cpu,idxp1_cpu,idxp2_cpu,ndtp_cpu,ndlp_cpu
    integer*4                                        :: idx1,idx2,ii,ndl,ndt,kt,istat,offset,sw
    integer(kind=cuda_stream_kind)                   :: stream1, stream2
    real*8                                           :: flop1,flop2,flop3,dbyte,ibyte

    allocate(ktp_cpu(size(ktp)))
    allocate(ndtp_cpu(size(ndtp)))
    allocate(ndlp_cpu(size(ndlp)))
    allocate(idxp1_cpu(size(idxp1)))
    allocate(idxp2_cpu(size(idxp2)))
    
    istat = cudaStreamCreate(stream1)
    istat = cudaStreamCreate(stream2)
    
    ! face2node_t => face2node
    ! np_t => np

    ndtp_cpu(:) = ndtp(:)
    ndlp_cpu(:) = ndlp(:)

    param61 = param(61)
    param64 = param(64)

    flop1 = 0.d0;    flop2 = 0.d0;    flop3 = 0.d0
    ibyte = 0.d0;    dbyte = 0.d0;
    
    sw = 0
    ip = 1
    idx1 = 1;  idx2 = 1
    kernel_time = 0.0d0
    do while(ip < n_low+1)
       mem_ab = 0
       mem_aa = 0
       st = ip
       en = n_low
       do i= ip, n_low
          mem_ab = mem_ab + ndtp_cpu(i)*kmax
          mem_aa = mem_aa + ndlp_cpu(i)*kmax
          if(mem_ab > LOCLIMITSIZE .or. mem_aa > LOCLIMITSIZE) then
             en = i-1
             exit
          endif
       end do
       ip = en+1

!       offset = (LOCLIMITSIZE/2)*sw
       offset = 0
       st_measure_time=MPI_Wtime()
       dimGrid  = dim3(en-st+1,1,1)
       if(en-st+1 <= 56) then
          dimBlock = dim3(256,1,1)
       elseif(en-st+1 <= 112) then
          dimBlock = dim3(128,1,1)
       elseif(en-st+1 <= 224) then
          dimBlock = dim3(64,1,1)
       else
          dimBlock = dim3(32,1,1)
!          dimBlock = dim3(64,1,1)
       endif
       
       call HACApK_calc_kt_cuda_kernel4<<<dimGrid, dimBlock, 0, stream1>>>                                &
            (st,en,offset,zaa,zab,lcol_msk,lrow_msk,ndl_prefix,ndt_prefix,ndlp,ndtp,                     &
            nstrtlp,nstrttp,ktp,param61,param64,lod,kmax,eps,znrmmat,pACA_EPS,                           &
            st_bemv,warn,err)
       en_measure_time=MPI_Wtime()
       kernel_time = kernel_time + en_measure_time-st_measure_time
       
       istat = cudaMemcpyAsync(ktp_cpu(st),ktp(st),en-st+1,stream1)
       istat = cudaStreamSynchronize(stream1)
       !ktp_cpu(st:en) = ktp(st:en)
       
       do ii=st, en
          idxp1_cpu(ii) = idx1
          idxp2_cpu(ii) = idx2
          ndl   =ndlp_cpu(ii)   ; ndt   =ndtp_cpu(ii)
          kt    =ktp_cpu(ii)
          idx1 = idx1 + ndt * kt
          idx2 = idx2 + ndl * kt
!           flop1 = flop1 + 1              !init
!           flop1 = flop1 + kt*3*(ndl+ndt) !norm
!           flop1 = flop1 + kt*9           !calc x,y,z
!           flop1 = flop1 + kt*ndt + 1     !zab(ii)=zab(ii)*zdltinv
!           flop2 = flop2 + 1              !sqrt
!           ibyte = ibyte + 4 + (ndt + ndl) / 32 + 1
!           ibyte = ibyte + 12 * kt
!           do i = 1, kt
!              ibyte = ibyte + 12 * (ndl + ndt - 2 * (i-1))
!              dbyte = dbyte + (ndl + ndt - 2 * (i-1))
!              flop1 = flop1 + (192 + 63 + 2) * (ndt - (i-1)) + (192 + 72 + 2) * (ndl - (i-1))
! !             if(lp61==3) flop1 = flop1 + 2 * (ndl + ndt - 2 * (i-1))
!              if(i .ne. 1) then
!                 flop1 = flop1 + (i-1) * 2 * (ndl+ndt) 
!                 dbyte = dbyte + 2 *(ndl+ndt) + 2 * (i-1)
!              endif
!              dbyte = dbyte + 2 * (ndl + ndt - 2 * (i-1))
!              flop1 = flop1 + 2 * (ndl + ndt - 2 * (i-1))
!              flop2 = flop2 + 10 * (ndl + ndt - 2 * (i-1))
!              flop3 = flop3 + 3  * (ndl + ndt - 2 * (i-1)) ! log, 1/3 atan2
!           end do
!           flop2 = flop2 + kt * 2
!           dbyte = dbyte + kt * (ndt + 1)
!           dbyte = dbyte + kt * (ndt + ndl)
       enddo
       if(idx1 > size(a1) .or. idx2 > size(a2)) print *, "memory overflow at ", __FILE__, '(',__LINE__,')'

       istat = cudaMemcpyAsync(idxp1(st),idxp1_cpu(st),en-st+1,stream1)
       istat = cudaMemcpyAsync(idxp2(st),idxp2_cpu(st),en-st+1,stream1)
       ! idxp1(st:en) = idxp1_cpu(st:en)
       ! idxp2(st:en) = idxp2_cpu(st:en)
       
       dimBlock = dim3(128,1,1)
       call a1_a2_copy2<<<dimGrid, dimBlock, 0, stream1>>>                                                &
            (st,en,offset,zaa,zab,ndl_prefix,ndt_prefix,ndlp,ndtp,nstrtlp,nstrttp,ktp,idxp1,idxp2,kmax,a1,a2)  
       sw = mod(sw+1,2)
    enddo

    istat = cudaStreamDestroy(stream1)
    istat = cudaStreamDestroy(stream2)

    ! print *, "maxkt", maxval(ktp_cpu)
    ! print *, "gflop", flop1/1000000000.0d0,flop2/1000000000.0d0,flop3/1000000000.0d0,flop3*3/1000000000.0d0
    ! print *, "gbyte(i,d)", 4.0d0*ibyte/1000000000.0d0,8.0d0*dbyte/1000000000.0d0
    ! print *, "estimated gflops", (flop1+flop2+flop3*50+flop3*3*80)/1000000000.0d0/kernel_time
    ! print *, "estimated bandwidth", (ibyte*4+dbyte*8)/1000000000.0d0/kernel_time

    deallocate(ktp_cpu)
    deallocate(ndtp_cpu)
    deallocate(ndlp_cpu)
    deallocate(idxp1_cpu)
    deallocate(idxp2_cpu)

  end subroutine HACApK_aca_cuda4


  subroutine HACApK_aca_cuda_opt4                                                                        &
       (a1,a2,zaa,zab,lcol_msk,lrow_msk,ndl_prefix,ndt_prefix,ndlp,ndtp,nstrtlp,nstrttp,ktp,idxp1,idxp2  &
       ,param,lod,kmax,eps,znrmmat,pACA_EPS,st_bemv,warn,err,n_low,LOCLIMITSIZE,kernel_time)
       use m_HACApK_calc_entry_ij    
       include 'mpif.h'
    real*8,   dimension(:),    intent(out),   device :: a1,a2
    real*8,   dimension(:),    intent(out),   device :: zaa,zab
    integer*4,dimension(:),    intent(inout), device :: lrow_msk,lcol_msk
    integer*4,dimension(:),    intent(in),    device :: ndl_prefix,ndt_prefix
    integer*4,dimension(:),    intent(in),    device :: ndlp,ndtp,nstrtlp,nstrttp
    integer*4,dimension(:),    intent(out),   device :: ktp
    integer*4,dimension(:),    intent(out),   device :: idxp1,idxp2
    real*8,                    intent(in)            :: param(:)
    integer*4,                 intent(in),    device :: lod(:)
    integer*4,                 intent(in)            :: kmax
    real*8,                    intent(in)            :: eps,znrmmat,pACA_EPS
    type(st_HACApK_calc_entry),intent(in),    device :: st_bemv
    integer*4,dimension(:),    intent(inout), device :: warn,err
    integer*4,                 intent(in)            :: n_low,LOCLIMITSIZE
    real*8,                    intent(out)           :: kernel_time
    type(dim3)                                       :: dimGrid, dimBlock
    real*8                                           :: param61, param64
    integer*8                                        :: mem_ab,mem_aa
    integer*4                                        :: st,en,i,ip,ts,ne
    real*8                                           :: st_measure_time, en_measure_time
    integer*4,dimension(:),allocatable               :: ktp_cpu,idxp1_cpu,idxp2_cpu,ndtp_cpu,ndlp_cpu
    integer*4                                        :: idx1,idx2,ii,ndl,ndt,kt,istat,offset,sw
    integer(kind=cuda_stream_kind)                   :: stream1, stream2
    real*8                                           :: flop1,flop2,flop3,dbyte,ibyte

    allocate(ktp_cpu(size(ktp)))
    allocate(ndtp_cpu(size(ndtp)))
    allocate(ndlp_cpu(size(ndlp)))
    allocate(idxp1_cpu(size(idxp1)))
    allocate(idxp2_cpu(size(idxp2)))
    
    istat = cudaStreamCreate(stream1)
    istat = cudaStreamCreate(stream2)
    
    ! face2node_t => face2node
    ! np_t => np

    ndtp_cpu(:) = ndtp(:)
    ndlp_cpu(:) = ndlp(:)

    param61 = param(61)
    param64 = param(64)

    flop1 = 0.d0;    flop2 = 0.d0;    flop3 = 0.d0
    ibyte = 0.d0;    dbyte = 0.d0;
    
    sw = 0
    ip = 1
    idx1 = 1;  idx2 = 1
    kernel_time = 0.0d0
    do while(ip < n_low+1)
       mem_ab = 0
       mem_aa = 0
       st = ip
       en = n_low
       do i= ip, n_low
          mem_ab = mem_ab + ndtp_cpu(i)*kmax
          mem_aa = mem_aa + ndlp_cpu(i)*kmax
          if(mem_ab > LOCLIMITSIZE .or. mem_aa > LOCLIMITSIZE) then
             en = i-1
             exit
          endif
       end do
       ip = en+1

!       offset = (LOCLIMITSIZE/2)*sw
       offset = 0
       st_measure_time=MPI_Wtime()
       dimGrid  = dim3(en-st+1,1,1)
       if(en-st+1 <= 56) then
          dimBlock = dim3(256,1,1)
       elseif(en-st+1 <= 112) then
          dimBlock = dim3(128,1,1)
       elseif(en-st+1 <= 224) then
          dimBlock = dim3(64,1,1)
       else
          dimBlock = dim3(32,1,1)
!          dimBlock = dim3(64,1,1)
       endif
       
       call HACApK_calc_kt_cuda_ufunc2<<<dimGrid, dimBlock, 0, stream1>>>                                &
            (st,en,offset,zaa,zab,lcol_msk,lrow_msk,ndl_prefix,ndt_prefix,ndlp,ndtp,                     &
            nstrtlp,nstrttp,ktp,param61,param64,lod,kmax,eps,znrmmat,pACA_EPS,                           &
            st_bemv,warn,err)
       en_measure_time=MPI_Wtime()
       kernel_time = kernel_time + en_measure_time-st_measure_time
       
       istat = cudaMemcpyAsync(ktp_cpu(st),ktp(st),en-st+1,stream1)
       istat = cudaStreamSynchronize(stream1)
       !ktp_cpu(st:en) = ktp(st:en)
       
       do ii=st, en
          idxp1_cpu(ii) = idx1
          idxp2_cpu(ii) = idx2
          ndl   =ndlp_cpu(ii)   ; ndt   =ndtp_cpu(ii)
          kt    =ktp_cpu(ii)
          idx1 = idx1 + ndt * kt
          idx2 = idx2 + ndl * kt
!           flop1 = flop1 + 1              !init
!           flop1 = flop1 + kt*3*(ndl+ndt) !norm
!           flop1 = flop1 + kt*9           !calc x,y,z
!           flop1 = flop1 + kt*ndt + 1     !zab(ii)=zab(ii)*zdltinv
!           flop2 = flop2 + 1              !sqrt
!           ibyte = ibyte + 4 + (ndt + ndl) / 32 + 1
!           ibyte = ibyte + 12 * kt
!           do i = 1, kt
!              ibyte = ibyte + 12 * (ndl + ndt - 2 * (i-1))
!              dbyte = dbyte + (ndl + ndt - 2 * (i-1))
!              flop1 = flop1 + (192 + 63 + 2) * (ndt - (i-1)) + (192 + 72 + 2) * (ndl - (i-1))
! !             if(lp61==3) flop1 = flop1 + 2 * (ndl + ndt - 2 * (i-1))
!              if(i .ne. 1) then
!                 flop1 = flop1 + (i-1) * 2 * (ndl+ndt) 
!                 dbyte = dbyte + 2 *(ndl+ndt) + 2 * (i-1)
!              endif
!              dbyte = dbyte + 2 * (ndl + ndt - 2 * (i-1))
!              flop1 = flop1 + 2 * (ndl + ndt - 2 * (i-1))
!              flop2 = flop2 + 10 * (ndl + ndt - 2 * (i-1))
!              flop3 = flop3 + 3  * (ndl + ndt - 2 * (i-1)) ! log, 1/3 atan2
!           end do
!           flop2 = flop2 + kt * 2
!           dbyte = dbyte + kt * (ndt + 1)
!           dbyte = dbyte + kt * (ndt + ndl)
       enddo
       if(idx1 > size(a1) .or. idx2 > size(a2)) print *, "memory overflow at ", __FILE__, '(',__LINE__,')'

       istat = cudaMemcpyAsync(idxp1(st),idxp1_cpu(st),en-st+1,stream1)
       istat = cudaMemcpyAsync(idxp2(st),idxp2_cpu(st),en-st+1,stream1)
       ! idxp1(st:en) = idxp1_cpu(st:en)
       ! idxp2(st:en) = idxp2_cpu(st:en)
       
       dimBlock = dim3(128,1,1)
       call a1_a2_copy2<<<dimGrid, dimBlock, 0, stream1>>>                                                &
            (st,en,offset,zaa,zab,ndl_prefix,ndt_prefix,ndlp,ndtp,nstrtlp,nstrttp,ktp,idxp1,idxp2,kmax,a1,a2)  
       sw = mod(sw+1,2)
    enddo

    istat = cudaStreamDestroy(stream1)
    istat = cudaStreamDestroy(stream2)

    ! print *, "maxkt", maxval(ktp_cpu)
    ! print *, "gflop", flop1/1000000000.0d0,flop2/1000000000.0d0,flop3/1000000000.0d0,flop3*3/1000000000.0d0
    ! print *, "gbyte(i,d)", 4.0d0*ibyte/1000000000.0d0,8.0d0*dbyte/1000000000.0d0
    ! print *, "estimated gflops", (flop1+flop2+flop3*50+flop3*3*80)/1000000000.0d0/kernel_time
    ! print *, "estimated bandwidth", (ibyte*4+dbyte*8)/1000000000.0d0/kernel_time

    deallocate(ktp_cpu)
    deallocate(ndtp_cpu)
    deallocate(ndlp_cpu)
    deallocate(idxp1_cpu)
    deallocate(idxp2_cpu)

  end subroutine HACApK_aca_cuda_opt4




  subroutine HACApK_aca_cuda_opt2                                                                        &
       (a1,a2,zaa,zab,lcol_msk,lrow_msk,ndl_prefix,ndt_prefix,ndlp,ndtp,nstrtlp,nstrttp,ktp,idxp1,idxp2  &
       ,param,lod,kmax,eps,znrmmat,pACA_EPS,st_bemv,warn,err,n_low,LOCLIMITSIZE,kernel_time)
       use m_HACApK_calc_entry_ij    
       include 'mpif.h'
    real*8,   dimension(:),    intent(out),   device :: a1,a2
    real*8,   dimension(:),    intent(out),   device :: zaa,zab
    integer*4,dimension(:),    intent(inout), device :: lrow_msk,lcol_msk
    integer*4,dimension(:),    intent(in),    device :: ndl_prefix,ndt_prefix
    integer*4,dimension(:),    intent(in),    device :: ndlp,ndtp,nstrtlp,nstrttp
    integer*4,dimension(:),    intent(out),   device :: ktp
    integer*4,dimension(:),    intent(out),   device :: idxp1,idxp2
    real*8,                    intent(in)            :: param(:)
    integer*4,                 intent(in),    device :: lod(:)
    integer*4,                 intent(in)            :: kmax
    real*8,                    intent(in)            :: eps,znrmmat,pACA_EPS
    type(st_HACApK_calc_entry),intent(in),    device :: st_bemv
    integer*4,dimension(:),    intent(inout), device :: warn,err
    integer*4,                 intent(in)            :: n_low,LOCLIMITSIZE
    real*8,                    intent(out)           :: kernel_time
    type(dim3)                                       :: dimGrid, dimBlock
    real*8                                           :: param61, param64
    integer*8                                        :: mem_ab,mem_aa
    integer*4                                        :: st,en,i,ip,ts,ne
    real*8                                           :: st_measure_time, en_measure_time
    integer*4,dimension(:),allocatable               :: ktp_cpu,idxp1_cpu,idxp2_cpu,ndtp_cpu,ndlp_cpu
    integer*4                                        :: idx1,idx2,ii,ndl,ndt,kt,istat,offset,sw
    integer(kind=cuda_stream_kind)                   :: stream1, stream2
    real*8                                           :: flop1,flop2,flop3,dbyte,ibyte

    allocate(ktp_cpu(size(ktp)))
    allocate(ndtp_cpu(size(ndtp)))
    allocate(ndlp_cpu(size(ndlp)))
    allocate(idxp1_cpu(size(idxp1)))
    allocate(idxp2_cpu(size(idxp2)))
    
    istat = cudaStreamCreate(stream1)
    istat = cudaStreamCreate(stream2)
    
    ! face2node_t => face2node
    ! np_t => np

    ndtp_cpu(:) = ndtp(:)
    ndlp_cpu(:) = ndlp(:)

    param61 = param(61)
    param64 = param(64)

    flop1 = 0.d0;    flop2 = 0.d0;    flop3 = 0.d0
    ibyte = 0.d0;    dbyte = 0.d0;
    
    sw = 0
    ip = 1
    idx1 = 1;  idx2 = 1
    kernel_time = 0.0d0
    do while(ip < n_low+1)
       mem_ab = 0
       mem_aa = 0
       st = ip
       en = n_low
       do i= ip, n_low
          mem_ab = mem_ab + ndtp_cpu(i)*kmax
          mem_aa = mem_aa + ndlp_cpu(i)*kmax
          if(mem_ab > LOCLIMITSIZE .or. mem_aa > LOCLIMITSIZE) then
             en = i-1
             exit
          endif
       end do
       ip = en+1

!       offset = (LOCLIMITSIZE/2)*sw
       offset = 0
       st_measure_time=MPI_Wtime()
       dimGrid  = dim3(en-st+1,1,1)
       if(en-st+1 <= 56) then
          dimBlock = dim3(256,1,1)
       elseif(en-st+1 <= 112) then
          dimBlock = dim3(128,1,1)
       elseif(en-st+1 <= 224) then
          dimBlock = dim3(64,1,1)
       else
          dimBlock = dim3(32,1,1)
!          dimBlock = dim3(64,1,1)
       endif
       
       call HACApK_calc_kt_cuda_ufunc<<<dimGrid, dimBlock, 0, stream1>>>                                &
            (st,en,offset,zaa,zab,lcol_msk,lrow_msk,ndl_prefix,ndt_prefix,ndlp,ndtp,                     &
            nstrtlp,nstrttp,ktp,param61,param64,lod,kmax,eps,znrmmat,pACA_EPS,                           &
            st_bemv,warn,err)
       en_measure_time=MPI_Wtime()
       kernel_time = kernel_time + en_measure_time-st_measure_time
       
       istat = cudaMemcpyAsync(ktp_cpu(st),ktp(st),en-st+1,stream1)
       istat = cudaStreamSynchronize(stream1)
       !ktp_cpu(st:en) = ktp(st:en)
       
       do ii=st, en
          idxp1_cpu(ii) = idx1
          idxp2_cpu(ii) = idx2
          ndl   =ndlp_cpu(ii)   ; ndt   =ndtp_cpu(ii)
          kt    =ktp_cpu(ii)
          idx1 = idx1 + ndt * kt
          idx2 = idx2 + ndl * kt
!           flop1 = flop1 + 1              !init
!           flop1 = flop1 + kt*3*(ndl+ndt) !norm
!           flop1 = flop1 + kt*9           !calc x,y,z
!           flop1 = flop1 + kt*ndt + 1     !zab(ii)=zab(ii)*zdltinv
!           flop2 = flop2 + 1              !sqrt
!           ibyte = ibyte + 4 + (ndt + ndl) / 32 + 1
!           ibyte = ibyte + 12 * kt
!           do i = 1, kt
!              ibyte = ibyte + 12 * (ndl + ndt - 2 * (i-1))
!              dbyte = dbyte + (ndl + ndt - 2 * (i-1))
!              flop1 = flop1 + (192 + 63 + 2) * (ndt - (i-1)) + (192 + 72 + 2) * (ndl - (i-1))
! !             if(lp61==3) flop1 = flop1 + 2 * (ndl + ndt - 2 * (i-1))
!              if(i .ne. 1) then
!                 flop1 = flop1 + (i-1) * 2 * (ndl+ndt) 
!                 dbyte = dbyte + 2 *(ndl+ndt) + 2 * (i-1)
!              endif
!              dbyte = dbyte + 2 * (ndl + ndt - 2 * (i-1))
!              flop1 = flop1 + 2 * (ndl + ndt - 2 * (i-1))
!              flop2 = flop2 + 10 * (ndl + ndt - 2 * (i-1))
!              flop3 = flop3 + 3  * (ndl + ndt - 2 * (i-1)) ! log, 1/3 atan2
!           end do
!           flop2 = flop2 + kt * 2
!           dbyte = dbyte + kt * (ndt + 1)
!           dbyte = dbyte + kt * (ndt + ndl)
       enddo
       if(idx1 > size(a1) .or. idx2 > size(a2)) print *, "memory overflow at ", __FILE__, '(',__LINE__,')'

       istat = cudaMemcpyAsync(idxp1(st),idxp1_cpu(st),en-st+1,stream1)
       istat = cudaMemcpyAsync(idxp2(st),idxp2_cpu(st),en-st+1,stream1)
       ! idxp1(st:en) = idxp1_cpu(st:en)
       ! idxp2(st:en) = idxp2_cpu(st:en)
       
       dimBlock = dim3(128,1,1)
       call a1_a2_copy2<<<dimGrid, dimBlock, 0, stream1>>>                                                &
            (st,en,offset,zaa,zab,ndl_prefix,ndt_prefix,ndlp,ndtp,nstrtlp,nstrttp,ktp,idxp1,idxp2,kmax,a1,a2)  
       sw = mod(sw+1,2)
    enddo

    istat = cudaStreamDestroy(stream1)
    istat = cudaStreamDestroy(stream2)

    ! print *, "maxkt", maxval(ktp_cpu)
    ! print *, "gflop", flop1/1000000000.0d0,flop2/1000000000.0d0,flop3/1000000000.0d0,flop3*3/1000000000.0d0
    ! print *, "gbyte(i,d)", 4.0d0*ibyte/1000000000.0d0,8.0d0*dbyte/1000000000.0d0
    ! print *, "estimated gflops", (flop1+flop2+flop3*50+flop3*3*80)/1000000000.0d0/kernel_time
    ! print *, "estimated bandwidth", (ibyte*4+dbyte*8)/1000000000.0d0/kernel_time

    deallocate(ktp_cpu)
    deallocate(ndtp_cpu)
    deallocate(ndlp_cpu)
    deallocate(idxp1_cpu)
    deallocate(idxp2_cpu)

  end subroutine HACApK_aca_cuda_opt2

  subroutine HACApK_aca_cuda_opt1                                                                        &
       (a1,a2,zaa,zab,lcol_msk,lrow_msk,ndl_prefix,ndt_prefix,ndlp,ndtp,nstrtlp,nstrttp,ktp,idxp1,idxp2  &
       ,param,lod,kmax,eps,znrmmat,pACA_EPS,st_bemv,warn,err,n_low,LOCLIMITSIZE,kernel_time)
       use m_HACApK_calc_entry_ij    
       include 'mpif.h'
    real*8,   dimension(:),    intent(out),   device :: a1,a2
    real*8,   dimension(:),    intent(out),   device :: zaa,zab
    integer*4,dimension(:),    intent(inout), device :: lrow_msk,lcol_msk
    integer*4,dimension(:),    intent(in),    device :: ndl_prefix,ndt_prefix
    integer*4,dimension(:),    intent(in),    device :: ndlp,ndtp,nstrtlp,nstrttp
    integer*4,dimension(:),    intent(out),   device :: ktp
    integer*4,dimension(:),    intent(out),   device :: idxp1,idxp2
    real*8,                    intent(in)            :: param(:)
    integer*4,                 intent(in),    device :: lod(:)
    integer*4,                 intent(in)            :: kmax
    real*8,                    intent(in)            :: eps,znrmmat,pACA_EPS
    type(st_HACApK_calc_entry),intent(in),    device :: st_bemv
    integer*4,dimension(:),    intent(inout), device :: warn,err
    integer*4,                 intent(in)            :: n_low,LOCLIMITSIZE
    real*8,                    intent(out)           :: kernel_time
    type(dim3)                                       :: dimGrid, dimBlock
    real*8                                           :: param61, param64
    integer*8                                        :: mem_ab,mem_aa
    integer*4                                        :: st,en,i,ip,ts,ne
    real*8                                           :: st_measure_time, en_measure_time
    integer*4,dimension(:),allocatable               :: ktp_cpu,idxp1_cpu,idxp2_cpu,ndtp_cpu,ndlp_cpu
    integer*4                                        :: idx1,idx2,ii,ndl,ndt,kt,istat,offset,sw
    integer(kind=cuda_stream_kind)                   :: stream1, stream2
    real*8                                           :: flop1,flop2,flop3,dbyte,ibyte

    allocate(ktp_cpu(size(ktp)))
    allocate(ndtp_cpu(size(ndtp)))
    allocate(ndlp_cpu(size(ndlp)))
    allocate(idxp1_cpu(size(idxp1)))
    allocate(idxp2_cpu(size(idxp2)))
    
    istat = cudaStreamCreate(stream1)
    istat = cudaStreamCreate(stream2)
    
    ! face2node_t => face2node
    ! np_t => np

    ndtp_cpu(:) = ndtp(:)
    ndlp_cpu(:) = ndlp(:)

    param61 = param(61)
    param64 = param(64)

    flop1 = 0.d0;    flop2 = 0.d0;    flop3 = 0.d0
    ibyte = 0.d0;    dbyte = 0.d0;
    
    sw = 0
    ip = 1
    idx1 = 1;  idx2 = 1
    kernel_time = 0.0d0
    do while(ip < n_low+1)
       mem_ab = 0
       mem_aa = 0
       st = ip
       en = n_low
       do i= ip, n_low
          mem_ab = mem_ab + ndtp_cpu(i)*kmax
          mem_aa = mem_aa + ndlp_cpu(i)*kmax
          if(mem_ab > LOCLIMITSIZE .or. mem_aa > LOCLIMITSIZE) then
             en = i-1
             exit
          endif
       end do
       ip = en+1

!       offset = (LOCLIMITSIZE/2)*sw
       offset = 0
       st_measure_time=MPI_Wtime()
       dimGrid  = dim3(en-st+1,1,1)
       if(en-st+1 <= 56) then
          dimBlock = dim3(256,1,1)
       elseif(en-st+1 <= 112) then
          dimBlock = dim3(128,1,1)
       elseif(en-st+1 <= 224) then
          dimBlock = dim3(64,1,1)
       else
          dimBlock = dim3(32,1,1)
!          dimBlock = dim3(64,1,1)
       endif
       
       call HACApK_calc_kt_cuda<<<dimGrid, dimBlock, 0, stream1>>>                                &
            (st,en,offset,zaa,zab,lcol_msk,lrow_msk,ndl_prefix,ndt_prefix,ndlp,ndtp,                     &
            nstrtlp,nstrttp,ktp,param61,param64,lod,kmax,eps,znrmmat,pACA_EPS,                           &
            st_bemv,warn,err)
       en_measure_time=MPI_Wtime()
       kernel_time = kernel_time + en_measure_time-st_measure_time
       
       istat = cudaMemcpyAsync(ktp_cpu(st),ktp(st),en-st+1,stream1)
       istat = cudaStreamSynchronize(stream1)
       !ktp_cpu(st:en) = ktp(st:en)
       
       do ii=st, en
          idxp1_cpu(ii) = idx1
          idxp2_cpu(ii) = idx2
          ndl   =ndlp_cpu(ii)   ; ndt   =ndtp_cpu(ii)
          kt    =ktp_cpu(ii)
          idx1 = idx1 + ndt * kt
          idx2 = idx2 + ndl * kt
!           flop1 = flop1 + 1              !init
!           flop1 = flop1 + kt*3*(ndl+ndt) !norm
!           flop1 = flop1 + kt*9           !calc x,y,z
!           flop1 = flop1 + kt*ndt + 1     !zab(ii)=zab(ii)*zdltinv
!           flop2 = flop2 + 1              !sqrt
!           ibyte = ibyte + 4 + (ndt + ndl) / 32 + 1
!           ibyte = ibyte + 12 * kt
!           do i = 1, kt
!              ibyte = ibyte + 12 * (ndl + ndt - 2 * (i-1))
!              dbyte = dbyte + (ndl + ndt - 2 * (i-1))
!              flop1 = flop1 + (192 + 63 + 2) * (ndt - (i-1)) + (192 + 72 + 2) * (ndl - (i-1))
! !             if(lp61==3) flop1 = flop1 + 2 * (ndl + ndt - 2 * (i-1))
!              if(i .ne. 1) then
!                 flop1 = flop1 + (i-1) * 2 * (ndl+ndt) 
!                 dbyte = dbyte + 2 *(ndl+ndt) + 2 * (i-1)
!              endif
!              dbyte = dbyte + 2 * (ndl + ndt - 2 * (i-1))
!              flop1 = flop1 + 2 * (ndl + ndt - 2 * (i-1))
!              flop2 = flop2 + 10 * (ndl + ndt - 2 * (i-1))
!              flop3 = flop3 + 3  * (ndl + ndt - 2 * (i-1)) ! log, 1/3 atan2
!           end do
!           flop2 = flop2 + kt * 2
!           dbyte = dbyte + kt * (ndt + 1)
!           dbyte = dbyte + kt * (ndt + ndl)
       enddo
       if(idx1 > size(a1) .or. idx2 > size(a2)) print *, "memory overflow at ", __FILE__, '(',__LINE__,')'

       istat = cudaMemcpyAsync(idxp1(st),idxp1_cpu(st),en-st+1,stream1)
       istat = cudaMemcpyAsync(idxp2(st),idxp2_cpu(st),en-st+1,stream1)
       ! idxp1(st:en) = idxp1_cpu(st:en)
       ! idxp2(st:en) = idxp2_cpu(st:en)
       
       dimBlock = dim3(128,1,1)
       call a1_a2_copy2<<<dimGrid, dimBlock, 0, stream1>>>                                                &
            (st,en,offset,zaa,zab,ndl_prefix,ndt_prefix,ndlp,ndtp,nstrtlp,nstrttp,ktp,idxp1,idxp2,kmax,a1,a2)  
       sw = mod(sw+1,2)
    enddo

    istat = cudaStreamDestroy(stream1)
    istat = cudaStreamDestroy(stream2)

    ! print *, "maxkt", maxval(ktp_cpu)
    ! print *, "gflop", flop1/1000000000.0d0,flop2/1000000000.0d0,flop3/1000000000.0d0,flop3*3/1000000000.0d0
    ! print *, "gbyte(i,d)", 4.0d0*ibyte/1000000000.0d0,8.0d0*dbyte/1000000000.0d0
    ! print *, "estimated gflops", (flop1+flop2+flop3*50+flop3*3*80)/1000000000.0d0/kernel_time
    ! print *, "estimated bandwidth", (ibyte*4+dbyte*8)/1000000000.0d0/kernel_time

    deallocate(ktp_cpu)
    deallocate(ndtp_cpu)
    deallocate(ndlp_cpu)
    deallocate(idxp1_cpu)
    deallocate(idxp2_cpu)

  end subroutine HACApK_aca_cuda_opt1
#endif
  ! subroutine HACApK_aca_cuda2_m1                                                                         &
  !      (a1,a2,zaa,zab,lcol_msk,lrow_msk,ndl_prefix,ndt_prefix,ndlp,ndtp,nstrtlp,nstrttp,ktp,idxp1,idxp2  &
  !      ,param,lod,kmax,eps,znrmmat,pACA_EPS,face2node,lp61,ao,np,warn,err,n_low,LOCLIMITSIZE,kernel_time)
  !      include 'mpif.h'
  !   real*8,   dimension(:),    intent(out),   device :: a1,a2
  !   real*8,   dimension(:),    intent(out),   device :: zaa,zab
  !   integer*4,dimension(:),    intent(inout), device :: lrow_msk,lcol_msk
  !   integer*4,dimension(:),    intent(in),    device :: ndl_prefix,ndt_prefix
  !   integer*4,dimension(:),    intent(in),    device :: ndlp,ndtp,nstrtlp,nstrttp
  !   integer*4,dimension(:),    intent(out),   device :: ktp
  !   integer*4,dimension(:),    intent(out),   device :: idxp1,idxp2
  !   real*8,                    intent(in)            :: param(:)
  !   integer*4,                 intent(in),    device :: lod(:)
  !   integer*4,                 intent(in)            :: kmax
  !   real*8,                    intent(in)            :: eps,znrmmat,pACA_EPS
  !   integer*4,dimension(:,:),  intent(in),    device :: face2node
  !   real*8,   dimension(:,:),  intent(in),    device :: np
  !   real*8,   dimension(:),    intent(in),    device :: ao
  !   integer*4,                 intent(in)            :: lp61
  !   integer*4,dimension(:),    intent(inout), device :: warn,err
  !   integer*4,                 intent(in)            :: n_low,LOCLIMITSIZE
  !   real*8,                    intent(out)           :: kernel_time
  !   type(dim3)                                       :: dimGrid, dimBlock
  !   real*8                                           :: param61, param64
  !   integer*8                                        :: mem_ab,mem_aa
  !   integer*4                                        :: st,en,i,ip
  !   real*8                                           :: st_measure_time, en_measure_time
  !   integer*4,dimension(:),allocatable               :: ktp_cpu,idxp1_cpu,idxp2_cpu,ndtp_cpu,ndlp_cpu
  !   integer*4                                        :: idx1,idx2,ii,ndl,ndt,kt,istat
  !   integer(kind=cuda_stream_kind)                   :: stream1, stream2

  !   allocate(ktp_cpu(size(ktp)))
  !   allocate(ndtp_cpu(size(ndtp)))
  !   allocate(ndlp_cpu(size(ndlp)))
  !   allocate(idxp1_cpu(size(idxp1)))
  !   allocate(idxp2_cpu(size(idxp2)))
    
  !   istat = cudaStreamCreate(stream1)
  !   istat = cudaStreamCreate(stream2)
    
  !   ndtp_cpu(:) = ndtp(:)
  !   ndlp_cpu(:) = ndlp(:)

  !   param61 = param(61)
  !   param64 = param(64)

  !   ip = 1
  !   idx1 = 1;  idx2 = 1
  !   kernel_time = 0.0d0
  !   do while(ip < n_low+1)
  !      mem_ab = 0
  !      mem_aa = 0
  !      st = ip
  !      en = n_low
  !      do i= ip, n_low
  !         mem_ab = mem_ab + ndtp_cpu(i)*kmax
  !         mem_aa = mem_aa + ndlp_cpu(i)*kmax
  !         if(mem_ab > LOCLIMITSIZE .or. mem_aa > LOCLIMITSIZE) then
  !            en = i-1
  !            exit
  !         endif
  !      end do
  !      ip = en+1
       
  !      st_measure_time=MPI_Wtime()
  !      dimGrid  = dim3(en-st+1,1,1)
  !      dimBlock = dim3(32,1,1)
  !      call HACApK_calc_kt_cuda_kernel<<<dimGrid, dimBlock, 0, stream1>>>                                &
  !           (st,en,zaa,zab,lcol_msk,lrow_msk,ndl_prefix,ndt_prefix,ndlp,ndtp,                            &
  !           nstrtlp,nstrttp,ktp,param61,param64,lod,kmax,eps,znrmmat,pACA_EPS,                           &
  !           face2node,lp61,ao,np,warn,err)
  !      en_measure_time=MPI_Wtime()
  !      kernel_time = kernel_time + en_measure_time-st_measure_time
       
  !      istat = cudaMemcpyAsync(ktp_cpu(st),ktp(st),en-st+1,stream1)
  !      istat = cudaStreamSynchronize(stream1)
  !      !ktp_cpu(st:en) = ktp(st:en)
       
  !      do ii=st, en
  !         idxp1_cpu(ii) = idx1
  !         idxp2_cpu(ii) = idx2
  !         ndl   =ndlp_cpu(ii)   ; ndt   =ndtp_cpu(ii)
  !         kt    =ktp_cpu(ii)
  !         idx1 = idx1 + ndt * kt
  !         idx2 = idx2 + ndl * kt
  !      enddo
  !      if(idx1 > size(a1) .or. idx2 > size(a2)) print *, "memory overflow at ", __FILE__, '(',__LINE__,')'

  !      istat = cudaMemcpyAsync(idxp1(st),idxp1_cpu(st),en-st+1,stream1)
  !      istat = cudaMemcpyAsync(idxp2(st),idxp2_cpu(st),en-st+1,stream1)
  !      ! idxp1(st:en) = idxp1_cpu(st:en)
  !      ! idxp2(st:en) = idxp2_cpu(st:en)
       
  !      dimBlock = dim3(128,1,1)
  !      call a1_a2_copy<<<dimGrid, dimBlock, 0, stream1>>>                                                &
  !           (st,en,zaa,zab,ndl_prefix,ndt_prefix,ndlp,ndtp,nstrtlp,nstrttp,ktp,idxp1,idxp2,kmax,a1,a2)  
  !      ! do ii=st, en
  !      !    a1_st = idxp1(ii)
  !      !    a2_st = idxp2(ii)
  !      !    ndl   =ndlp(ii)   ; ndt   =ndtp(ii)
  !      !    kt    =ktp(ii)
  !      !    zaa_st=(ndl_prefix(ii)-ndl_prefix(st))*kparam+1 ; zab_st=(ndt_prefix(ii)-ndt_prefix(st))*kparam+1
          
  !      !    do j = 1, kt
  !      !       do i = 1, ndt
  !      !          a1(a1_st-1+i+(j-1)*ndt) = zab1(zab_st + i-1 + (j-1)*ndt)
  !      !       enddo
  !      !       do i = 1, ndl
  !      !          a2(a2_st-1+i+(j-1)*ndl) = zaa1(zaa_st + i-1 + (j-1)*ndl)
  !      !       enddo
  !      !    enddo
  !      ! enddo
       
  !   enddo

  !   istat = cudaStreamDestroy(stream1)
  !   istat = cudaStreamDestroy(stream2)

  !   deallocate(ktp_cpu)
  !   deallocate(ndtp_cpu)
  !   deallocate(ndlp_cpu)
  !   deallocate(idxp1_cpu)
  !   deallocate(idxp2_cpu)

  ! end subroutine HACApK_aca_cuda2_m1

  ! subroutine HACApK_aca_cuda                                                                             &
  !      (a1,a2,zaa,zab,lcol_msk,lrow_msk,ndl_prefix,ndt_prefix,ndlp,ndtp,nstrtlp,nstrttp,ktp,idxp1,idxp2  &
  !      ,param,lod,kmax,eps,znrmmat,pACA_EPS,face2node,lp61,ao,np,warn,err,n_low,LOCLIMITSIZE,kernel_time)
  !      include 'mpif.h'
  !   real*8,   dimension(:),    intent(out),   device :: a1,a2
  !   real*8,   dimension(:),    intent(out),   device :: zaa,zab
  !   integer*4,dimension(:),    intent(inout), device :: lrow_msk,lcol_msk
  !   integer*4,dimension(:),    intent(in),    device :: ndl_prefix,ndt_prefix
  !   integer*4,dimension(:),    intent(in),    device :: ndlp,ndtp,nstrtlp,nstrttp
  !   integer*4,dimension(:),    intent(out),   device :: ktp
  !   integer*4,dimension(:),    intent(out),   device :: idxp1,idxp2
  !   real*8,                    intent(in)            :: param(:)
  !   integer*4,                 intent(in),    device :: lod(:)
  !   integer*4,                 intent(in)            :: kmax
  !   real*8,                    intent(in)            :: eps,znrmmat,pACA_EPS
  !   integer*4,dimension(:,:),  intent(in),    device :: face2node
  !   real*8,   dimension(:,:),  intent(in),    device :: np
  !   real*8,   dimension(:),    intent(in),    device :: ao
  !   integer*4,                 intent(in)            :: lp61
  !   integer*4,dimension(:),    intent(inout), device :: warn,err
  !   integer*4,                 intent(in)            :: n_low,LOCLIMITSIZE
  !   real*8,                    intent(out)           :: kernel_time
  !   type(dim3)                                       :: dimGrid, dimBlock
  !   real*8                                           :: param61, param64
  !   integer*8                                        :: mem_ab,mem_aa
  !   integer*4                                        :: st,en,i,ip
  !   real*8                                           :: st_measure_time, en_measure_time
  !   integer*4,dimension(:),allocatable               :: ktp_cpu,idxp1_cpu,idxp2_cpu,ndtp_cpu,ndlp_cpu
  !   integer*4                                        :: idx1,idx2,ii,ndl,ndt,kt

  !   allocate(ktp_cpu(size(ktp)))
  !   allocate(ndtp_cpu(size(ndtp)))
  !   allocate(ndlp_cpu(size(ndlp)))
  !   allocate(idxp1_cpu(size(idxp1)))
  !   allocate(idxp2_cpu(size(idxp2)))

  !   ndtp_cpu(:) = ndtp(:)
  !   ndlp_cpu(:) = ndlp(:)

  !   param61 = param(61)
  !   param64 = param(64)

  !   ip = 1
  !   idx1 = 1;  idx2 = 1
  !   kernel_time = 0.0d0
  !   do while(ip < n_low+1)
  !      mem_ab = 0
  !      mem_aa = 0
  !      st = ip
  !      en = n_low
  !      do i= ip, n_low
  !         mem_ab = mem_ab + ndtp_cpu(i)*kmax
  !         mem_aa = mem_aa + ndlp_cpu(i)*kmax
  !         if(mem_ab > LOCLIMITSIZE .or. mem_aa > LOCLIMITSIZE) then
  !            en = i-1
  !            exit
  !         endif
  !      end do
  !      ip = en+1
       
  !      st_measure_time=MPI_Wtime()
  !      dimGrid  = dim3(en-st+1,1,1)
  !      dimBlock = dim3(32,1,1)
  !      call HACApK_calc_kt_cuda_kernel<<<dimGrid, dimBlock>>>                                            &
  !           (st,en,zaa,zab,lcol_msk,lrow_msk,ndl_prefix,ndt_prefix,ndlp,ndtp,                            &
  !           nstrtlp,nstrttp,ktp,param61,param64,lod,kmax,eps,znrmmat,pACA_EPS,                           &
  !           face2node,lp61,ao,np,warn,err)
  !      en_measure_time=MPI_Wtime()
  !      kernel_time = kernel_time + en_measure_time-st_measure_time

  !      ktp_cpu(st:en) = ktp(st:en)
       
  !      do ii=st, en
  !         idxp1_cpu(ii) = idx1
  !         idxp2_cpu(ii) = idx2
  !         ndl   =ndlp_cpu(ii)   ; ndt   =ndtp_cpu(ii)
  !         kt    =ktp_cpu(ii)
  !         idx1 = idx1 + ndt * kt
  !         idx2 = idx2 + ndl * kt
  !      enddo
  !      if(idx1 > size(a1) .or. idx2 > size(a2)) print *, "memory overflow at ", __FILE__, '(',__LINE__,')'

  !      idxp1(st:en) = idxp1_cpu(st:en)
  !      idxp2(st:en) = idxp2_cpu(st:en)
       
  !      dimBlock = dim3(128,1,1)
  !      call a1_a2_copy<<<dimGrid, dimBlock>>>                                                           &
  !           (st,en,zaa,zab,ndl_prefix,ndt_prefix,ndlp,ndtp,nstrtlp,nstrttp,ktp,idxp1,idxp2,kmax,a1,a2)  
  !      ! do ii=st, en
  !      !    a1_st = idxp1(ii)
  !      !    a2_st = idxp2(ii)
  !      !    ndl   =ndlp(ii)   ; ndt   =ndtp(ii)
  !      !    kt    =ktp(ii)
  !      !    zaa_st=(ndl_prefix(ii)-ndl_prefix(st))*kparam+1 ; zab_st=(ndt_prefix(ii)-ndt_prefix(st))*kparam+1
          
  !      !    do j = 1, kt
  !      !       do i = 1, ndt
  !      !          a1(a1_st-1+i+(j-1)*ndt) = zab1(zab_st + i-1 + (j-1)*ndt)
  !      !       enddo
  !      !       do i = 1, ndl
  !      !          a2(a2_st-1+i+(j-1)*ndl) = zaa1(zaa_st + i-1 + (j-1)*ndl)
  !      !       enddo
  !      !    enddo
  !      ! enddo
       
  !   enddo

  !   deallocate(ktp_cpu)
  !   deallocate(ndtp_cpu)
  !   deallocate(ndlp_cpu)
  !   deallocate(idxp1_cpu)
  !   deallocate(idxp2_cpu)

  ! end subroutine HACApK_aca_cuda

  attributes(global) subroutine prefix_sum_pre(prefix,prefix_reduce,src,len,lenr,loclen)
    integer*4,dimension(len),   intent(out)           :: prefix
    integer*4,dimension(lenr),  intent(out)           :: prefix_reduce
    integer*4,dimension(len-1), intent(in)            :: src
    integer*4,                  intent(in)    ,value  :: len,lenr,loclen
    integer*4 :: tid, bid, i, j, wid, tmp1, dimx, rid, atmp, amax

    tid = blockDim%x * (blockIdx%x -1) * loclen + threadIdx%x
    bid = blockIdx%x
    wid = mod(threadIdx%x-1,32) + 1
    atmp = 0
    amax = 0

    do j = tid, min(bid*32*loclen,len), 32
       if(j == 1) then
          atmp = 1
       else
          atmp = src(j-1)
       endif

       i = 1
       do while(i < 32)
          tmp1 = __shfl_up(atmp,i)
          if(wid > i) then
             atmp = atmp + tmp1
          endif
          i = i * 2
          call syncthreads()
       enddo
       atmp = atmp + amax
       if(wid == 32) then 
          amax = atmp
       end if
       prefix(j) = atmp
       amax = __shfl(amax,32)
       call syncthreads()
       if(j == bid*32*loclen) then
          prefix_reduce(bid) = amax
       end if
    end do
  end subroutine prefix_sum_pre


  attributes(global) subroutine prefix_sum_mid(prefix_reduce,len)
    integer*4,dimension(len), intent(out)           :: prefix_reduce
    integer*4,                intent(in)    ,value  :: len
    integer*4 :: tid, dimx, i, j, wid, tmp1, rid, atmp
    integer*4,shared,dimension(16) :: prefix_shared

    tid = threadIdx%x
    wid = mod(threadIdx%x-1,32) + 1
    rid = (tid-1)/32 + 1
    dimx = blockDim%x
    if(tid > len) return
    atmp = prefix_reduce(tid)
    if(tid <= 16) then
       prefix_shared(tid) = 0
    end if

    i = 1
    do while(i < 32)
       tmp1 = __shfl_up(atmp,i)
       if(wid > i) then
          atmp = atmp + tmp1
       endif
       i = i * 2
       call syncthreads()
    enddo
    prefix_reduce(tid) = atmp
    if(wid == 32) then
       prefix_shared(rid) = atmp
    end if
    call syncthreads()
    if(tid == 1) then
       do i = 2, 16
          prefix_shared(i) = prefix_shared(i) + prefix_shared(i-1)
       end do
    endif
    call syncthreads()
    if(rid-1 > 0) then
       prefix_reduce(tid) = prefix_reduce(tid) + prefix_shared(rid-1)
    end if
    
  end subroutine prefix_sum_mid

  attributes(global) subroutine prefix_sum_post(prefix,prefix_reduce,len,lenr,loclen)
    integer*4,dimension(len),   intent(out)           :: prefix
    integer*4,dimension(lenr),  intent(in)            :: prefix_reduce
    integer*4,                  intent(in)    ,value  :: len,lenr,loclen
    integer*4 :: tid, bid, rid, atmp, btmp, i, dimx, amax, bmax

    tid = blockDim%x * (blockIdx%x -1) * loclen + threadIdx%x
    bid = blockIdx%x
    dimx = blockDim%x
    rid = (tid-1)/(32*loclen) + 1

    if(tid > len) return
    if(rid-1 > 0) then
       amax = prefix_reduce(rid-1)
       do i = tid, min(bid*dimx*loclen,len),dimx
          atmp = prefix(i) + amax
          prefix(i) = atmp
       end do
    end if

  end subroutine prefix_sum_post

  subroutine prefix_sum_cuda(dis,src,length)
    integer*4, dimension(1:length+1),device :: dis
    integer*4, dimension(1:length)  ,device :: src
    integer*4 :: length
    integer*4, dimension(:),allocatable,device :: tmp
    integer*4 :: preloclen,istat
    type(dim3) :: dimGrid_prefix1,dimBlock_prefix1
    type(dim3) :: dimGrid_prefix2,dimBlock_prefix2

    allocate(tmp(512))
    preloclen = ((length-1)/512+1-1)/32+1
    dimGrid_prefix1  = dim3(512,1,1)
    dimBlock_prefix1 = dim3(32,1,1)
    dimGrid_prefix2  = dim3(1,1,1)
    dimBlock_prefix2 = dim3(512,1,1)
    call prefix_sum_pre <<<dimGrid_prefix1,dimBlock_prefix1>>>(dis,tmp,src,length,512,preloclen)
    call prefix_sum_mid <<<dimGrid_prefix2,dimBlock_prefix2>>>(tmp,512)
    call prefix_sum_post<<<dimGrid_prefix1,dimBlock_prefix1>>>(dis,tmp,length,512,preloclen)
    istat = cudaDeviceSynchronize()
    deallocate(tmp)

  end subroutine prefix_sum_cuda













 

!   attributes(global) subroutine HACApK_fill_leafmtx_cuda0_kernel(st_lf)
!     use m_HACApK_base,only:st_HACApK_leafmtx
!     ! type(st_HACApK_leafmtxp) ::  st_leafmtxp
!     type(st_HACApK_leafmtx) :: st_lf(:)
!     ! type(st_HACApK_calc_entry) :: st_bemv
!     ! real*8 ::param(:)
!     ! integer*4 :: lodl(nd),lodt(nd),lpmd(:),lnmtx(:),lthr(0:)
!     real*8, allocatable :: zab(:,:),zaa(:,:)
!     integer :: ndt,ndl,kparam,ip,kt
! ! 1000 format(5(a,i12)/)
! !     eps=param(71); ACA_EPS=param(72)*eps; kparam=param(63)
    
! !     ith = omp_get_thread_num()
! !     nthr = omp_get_num_threads()
! !     if(nthr == 0) write(* ,*) nthr ,ith
! !     ith1 = ith+1
! !     nths=lthr(ith); nthe=lthr(ith1)-1
! !     ierr=0
! !     do ip=nths,nthe
! !        ndl   =st_lf(ip)%ndl   ; ndt   =st_lf(ip)%ndt   ; ns=ndl*ndt
! !        nstrtl=st_lf(ip)%nstrtl; nstrtt=st_lf(ip)%nstrtt; ltmtx=st_lf(ip)%ltmtx
! !        if(ltmtx==1)then
!            allocate(zab(ndt,kparam),zaa(ndl,kparam))
! !           kt=HACApK_aca(zaa,zab,param,ndl,ndt,nstrtl,nstrtt,lodl,st_bemv,kparam,eps,znrmmat,ACA_EPS)
! !           st_lf(ip)%kt=kt
! !           allocate(st_lf(ip)%a1(ndt,kt),st_lf(ip)%a2(ndl,kt),stat=ierr)
!            st_lf(ip)%a1(1:ndt,1:kt)=zab(1:ndt,1:kt)
!            st_lf(ip)%a2(1:ndl,1:kt)=zaa(1:ndl,1:kt)
!            deallocate(zab,zaa)
! !        elseif(ltmtx==2)then
! !           allocate(st_lf(ip)%a1(ndt,ndl),stat=ierr)
! !           do il=1,ndl; ill=il+nstrtl-1
! !              do it=1,ndt; itt=it+nstrtt-1
! !                 st_lf(ip)%a1(it,il)=HACApK_entry_ij(lodl(ill),lodt(itt),st_bemv)
! !              enddo
! !           enddo
! !        endif
! !     enddo
    
! !     do ip=1,nlf
! !        ndl=st_lf(ip)%ndl; nstrtl=st_lf(ip)%nstrtl
! !        if(nstrtl<lnps) lnps=nstrtl
! !        if(nstrtl+ndl>lnpe) lnpe=nstrtl+ndl
! !     enddo
!   end subroutine HACApK_fill_leafmtx_cuda0_kernel

!   subroutine HACApK_fill_leafmtx_cuda0(st_lf,st_bemv,param,znrmmat,lpmd,lnmtx,lodl,lodt,nd,nlf,lnps,lnpe,lthr)
!     use hacapk_base
!     ! type(st_HACApK_leafmtxp) ::  st_leafmtxp
!     type(st_HACApK_leafmtx) :: st_lf(:)
!     type(st_HACApK_calc_entry) :: st_bemv
!     real*8 ::param(:)
!     integer*4 :: lodl(nd),lodt(nd),lpmd(:),lnmtx(:),lthr(0:)
!     real*8, allocatable :: zab(:,:),zaa(:,:)
! 1000 format(5(a,i12)/)
!     eps=param(71); ACA_EPS=param(72)*eps; kparam=param(63)
    
!     ith = omp_get_thread_num()
!     nthr = omp_get_num_threads()
!     if(nthr == 0) write(* ,*) nthr ,ith
!     ith1 = ith+1
!     nths=lthr(ith); nthe=lthr(ith1)-1
!     ierr=0
!     do ip=nths,nthe
!        ndl   =st_lf(ip)%ndl   ; ndt   =st_lf(ip)%ndt   ; ns=ndl*ndt
!        nstrtl=st_lf(ip)%nstrtl; nstrtt=st_lf(ip)%nstrtt; ltmtx=st_lf(ip)%ltmtx
!        if(ltmtx==1)then
!           allocate(zab(ndt,kparam),zaa(ndl,kparam),stat=ierr)
!           kt=HACApK_aca(zaa,zab,param,ndl,ndt,nstrtl,nstrtt,lodl,st_bemv,kparam,eps,znrmmat,ACA_EPS)
!           st_lf(ip)%kt=kt
!           allocate(st_lf(ip)%a1(ndt,kt),st_lf(ip)%a2(ndl,kt),stat=ierr)
!           st_lf(ip)%a1(1:ndt,1:kt)=zab(1:ndt,1:kt)
!           st_lf(ip)%a2(1:ndl,1:kt)=zaa(1:ndl,1:kt)
!           deallocate(zab,zaa)
!        elseif(ltmtx==2)then
!           allocate(st_lf(ip)%a1(ndt,ndl),stat=ierr)
!           do il=1,ndl; ill=il+nstrtl-1
!              do it=1,ndt; itt=it+nstrtt-1
!                 st_lf(ip)%a1(it,il)=HACApK_entry_ij(lodl(ill),lodt(itt),st_bemv)
!              enddo
!           enddo
!        endif
!     enddo
    
!     do ip=1,nlf
!        ndl=st_lf(ip)%ndl; nstrtl=st_lf(ip)%nstrtl
!        if(nstrtl<lnps) lnps=nstrtl
!        if(nstrtl+ndl>lnpe) lnpe=nstrtl+ndl
!     enddo
!   end subroutine HACApK_fill_leafmtx_cuda0
  
  
endmodule m_HACApK_base_cuda


